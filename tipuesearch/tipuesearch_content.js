var tipuesearch = {"pages":[{"title":"植物空间转录组分析2：STEEL+Seurat","url":"/2023/02/24/2023-02-24-ST(2)/","text":"本文将继续使用兰花空间转录组的数据，同时运用文献中提到的 STEEL 聚类方法进行分析，该方法也是由戚继团队开发的，看文章感觉聚类效果不错。 目前该文章还未被接收，大家可以先用下软件，主要能提供聚类信息和每个聚类的 marker 基因，但个人认为可视化方面还有所欠缺，所以这个教程将结合 STEEL 的聚类方法与 Seurat 的可视化函数来完整复现文章的聚类图和拟时图 # STEEL 聚类分析 软件下载 STEEL (sourceforge.io) 使用说明 主要的参数就是 --beads --genes --pca --group .&#x2F;steel filtered_feature_bc_matrix spatial&#x2F;tissue_positions_list.csv --pca&#x3D;20 pca20out输出结果 genes 文件里面包含的就是聚类特异基因，map 文件就是聚类信息，我们使用 pca20out.map.40 的聚类信息进行后续的分析 # Seurat 聚类图 使用 Seurat 读取原始的数据，并将 STEEL 聚类信息读入 library (Seurat)library (dplyr)library (ggplot2)library (magrittr)library (cowplot)library (gtools)library (stringr)library (Matrix)library (tidyverse)library (patchwork)orc1&lt;- Load10X_Spatial (&quot;Slide_1&quot;)## 直接导入 STEEL 的聚类信息STEEL&lt;- read.delim (&quot;STEEL&#x2F;Slide1.map.40&quot;,row.names &#x3D; 1)orc1 [[&quot;seurat_clusters&quot;]] &lt;- NAclusters&lt;-data.frame (STEEL$Cluster)rownames (clusters) &lt;- rownames (STEEL)orc1 [[&quot;seurat_clusters&quot;]][rownames (clusters),] &lt;- clusters## 去除 NA 值只保留有聚类的orc1_new &lt;- orc1 [,rownames (clusters)]Idents (orc1_new) &lt;- &#39;seurat_clusters&#39;Idents (orc1_new) &lt;- factor (Idents (orc1_new),levels&#x3D;mixedsort (levels (Idents (orc1_new))))接下来就是利用 SpatialDimPlot 绘制聚类图了 orc1_new &lt;- SCTransform(orc1_new, assay &#x3D; &quot;Spatial&quot;, return.only.var.genes &#x3D; FALSE, verbose &#x3D; FALSE)orc1_new &lt;- RunPCA(orc1_new, features &#x3D; VariableFeatures(orc1_new)) orc1_new &lt;- RunTSNE(orc1_new, dims &#x3D; 1:20)p1 &lt;- DimPlot(orc1_new, reduction &#x3D; &quot;tsne&quot;, label &#x3D; TRUE)p2 &lt;- SpatialDimPlot(orc1_new, group.by &#x3D; &quot;seurat_clusters&quot;,label.size &#x3D; 3, pt.size.factor &#x3D; 1.3)pearplot &lt;- plot_grid(p1,p2)ggsave(&quot;STEEL&#x2F;tsne_Slide1_40.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 6, height &#x3D; 6) 这个结果其实已经和原文一模一样了，就是颜色不对应 单看某个聚类对应关系，完全一致 p1&lt;- SpatialDimPlot(orc1_new, cells.highlight &#x3D; CellsByIdentities(object &#x3D; orc1_new, idents &#x3D; c(1:40)), facet.highlight &#x3D; TRUE, ncol &#x3D; 5)ggsave(&quot;STEEL&#x2F;cluster_Slide1all.pdf&quot;, plot &#x3D; p1, width &#x3D; 19, height &#x3D; 12) 对应好聚类关系接下就是拟时分析了 # 拟时分析 在文章中做了两次拟时分析，本次分析只以 Fig2 的组织进行分析，其他的大家也可以自尝试 library (monocle)subdata &lt;- subset (orc1_new, idents &#x3D; c (19,21,37,38,39,40))# 选择要分析的亚群expression_matrix &#x3D; subdata@assays$Spatial@countscell_metadata &lt;- data.frame (group &#x3D; subdata [[&#39;orig.ident&#39;]],clusters &#x3D; Idents (subdata))gene_annotation &lt;- data.frame (gene_short_name &#x3D; rownames (expression_matrix), stringsAsFactors &#x3D; F) rownames (gene_annotation) &lt;- rownames (expression_matrix)pd &lt;- new (&quot;AnnotatedDataFrame&quot;, data &#x3D; cell_metadata)fd &lt;- new (&quot;AnnotatedDataFrame&quot;, data &#x3D; gene_annotation)HSMM &lt;- newCellDataSet (expression_matrix, phenoData &#x3D; pd, featureData &#x3D; fd, expressionFamily&#x3D;negbinomial.size ())HSMM &lt;- detectGenes (HSMM,min_expr &#x3D; 0.1)HSMM_myo &lt;- estimateSizeFactors (HSMM)HSMM_myo &lt;- estimateDispersions (HSMM_myo)disp_table &lt;- dispersionTable (HSMM_myo)disp.genes &lt;- subset (disp_table, mean_expression &gt;&#x3D; 0.1 )disp.genes &lt;- as.character (disp.genes$gene_id)HSMM_myo &lt;- reduceDimension (HSMM_myo, max_components &#x3D; 2, method &#x3D; &#39;DDRTree&#39;)HSMM_myo &lt;-orderCells (HSMM_myo,reverse &#x3D; T)#State 轨迹分布图plot1 &lt;- plot_cell_trajectory (HSMM_myo, color_by &#x3D; &quot;State&quot;)##Cluster 轨迹分布图plot2 &lt;- plot_cell_trajectory (HSMM_myo, color_by &#x3D; &quot;clusters&quot;)##Pseudotime 轨迹图plot3 &lt;- plot_cell_trajectory (HSMM_myo, color_by &#x3D; &quot;Pseudotime&quot;)plotc &lt;- plot1|plot2|plot3ggsave (&quot;STEEL&#x2F;Combination1.pdf&quot;, plot &#x3D; plotc, width &#x3D; 18, height &#x3D; 6.2)# 绘制拟时间cell_Pseudotime &lt;- data.frame (pData (HSMM_myo)$Pseudotime)rownames (cell_Pseudotime) &lt;- rownames (cell_metadata) # 把拟时间对应到到组织切片位置上orc1_new [[&#39;Pseudotime&#39;]] &lt;- NAorc1_new [[&#39;Pseudotime&#39;]][rownames (cell_Pseudotime),] &lt;- cell_Pseudotimep1 &lt;- SpatialFeaturePlot (orc1_new, features &#x3D; c (&quot;Pseudotime&quot;),pt.size.factor &#x3D; 1.3)ggsave (&quot;STEEL&#x2F;pseudotime_feature1.pdf&quot;, plot &#x3D; p1, width &#x3D; 8, height &#x3D; 9)主要的亮点就在于可以把拟时结果体现在我们的组织切片上，这样我们在 orderCells 这一步可以更加方便的判断每个 spot 的拟时间 可以看到和文章里的是一模一样的，接下来就是复现文章中的基因拟时分布和 BEAM 结果 data_subset &lt;- HSMM_myo [&#39;PAXXG054350&#39;,]p1&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;)data_subset &lt;- HSMM_myo [&#39;PAXXG051950&#39;,]p2&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;)data_subset &lt;- HSMM_myo [&#39;PAXXG086750&#39;,]p3&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;)data_subset &lt;- HSMM_myo [&#39;PAXXG345890&#39;,]p4&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;)data_subset &lt;- HSMM_myo [&#39;PAXXG010560&#39;,]p5&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;)data_subset &lt;- HSMM_myo [&#39;PAXXG074500&#39;,]p6&lt;-plot_genes_in_pseudotime (data_subset, color_by &#x3D; &quot;clusters&quot;) #color_by 可以换成 state 或者 pseudotimepearplot &lt;- plot_grid (p1,p2,p3,p4,p5,p6,align &#x3D; &quot;v&quot;,axis &#x3D; &quot;b&quot;,ncol &#x3D; 1)ggsave (&quot;STEEL&#x2F;gene_pseudotime1.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 5, height &#x3D; 15)# 拟时相关基因聚类热图 disp_table &lt;- dispersionTable (HSMM_myo)disp.genes &lt;- subset (disp_table, mean_expression &gt;&#x3D; 0.5&amp;dispersion_empirical &gt;&#x3D; 1*dispersion_fit)disp.genes &lt;- as.character (disp.genes$gene_id)mycds_sub &lt;- HSMM_myo [disp.genes,]diff_test &lt;- differentialGeneTest (HSMM_myo [disp.genes,], cores &#x3D; 4, fullModelFormulaStr &#x3D; &quot;~sm.ns (Pseudotime)&quot;)sig_gene_names &lt;- row.names (subset (diff_test, qval &lt; 1e-04))p2 &#x3D; plot_pseudotime_heatmap (HSMM_myo [sig_gene_names,], num_clusters&#x3D;6, show_rownames&#x3D;F, return_heatmap&#x3D;T)ggsave (&quot;STEEL&#x2F;pseudotime_heatmap1.pdf&quot;, plot &#x3D; p2, width &#x3D; 5, height &#x3D; 10)## BEAM 分析my_pseudotime_de &lt;- differentialGeneTest (HSMM_myo, cores &#x3D; 5)BEAM_res &lt;- BEAM (HSMM_myo, branch_point &#x3D; 1, cores &#x3D; 4)BEAM_res &lt;- BEAM_res [order (BEAM_res$qval),]BEAM_res &lt;- BEAM_res [,c (&quot;gene_short_name&quot;, &quot;pval&quot;, &quot;qval&quot;)]mycds_sub_beam &lt;- HSMM_myo [row.names (subset (BEAM_res, qval &lt; 1e-4)),]pdf (&quot;STEEL&#x2F;BEAM1.pdf&quot;, width &#x3D; 8, height &#x3D; 12)plot_genes_branched_heatmap (mycds_sub_beam, branch_point &#x3D; 1, num_clusters &#x3D; 6, cores &#x3D; 4,show_rownames &#x3D; FALSE)dev.off ()可以看到 BEAM 不太相同，但除了这个以外其他的都是完全一致，这次分析达到了文章中的效果，比较满意 #总结 目前植物空间转录组刚刚起步，相信今年会有很多文章出现，到时候主要就是看创新点在哪，能解决什么问题","tags":"bioinformatics spatial_transcriptome"},{"title":"植物空间转录组分析1：Seurat基本流程","url":"/2023/02/22/2023-02-22-ST(1)/","text":"空间转录组是 2022 生命科学十大创新产品名单，因此将来会在生物学领域有非常大的应用空间，目前植物类的相关文章较少，在本次的系列教程中，将使用复旦大学戚继团队兰花空间转录组的数据，希望大家一起学习，掌握植物空间转录组基本的分析方法 数据连接 OSF | Spatiotemporal atlas of organogenesis in development of orchid flowers, 与单细胞的数据结构基本一致，多了 spatial 这个文件夹，主要包含的就是切片信息和 spot 定位信息 # 前言 在本篇文章中，作者一共制作了兰花空间转录组切片，并使用了 STEEL 方法进行聚类，出于学习考虑，本次分析先使用 Seurat 的常见流程分析其中一个切片，后续推文中将使用文章中的 STELL 方法进行聚类并使用 Seurat 的其他函数进行后续分析 本次只分析 Slide1，感兴趣的可以试试其他切片 # 数据载入 和单细胞一样，只是多了 spatial 这个文件夹需要输入 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1. 安装依赖包 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;##BiocManager::install (c (&#39;Seurat&#39;,&#39;ggplot2&#39;,&#39;cowplot&#39;,&#39;dplyr&#39;))##BiocManager::install (&quot;monocle&quot;,force &#x3D; TRUE) library (Seurat)library (ggplot2)library (cowplot)library (dplyr)library (magrittr)library (gtools)library (stringr)library (Matrix)library (tidyverse)library (patchwork)##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2. 载入数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;orc1&lt;- Load10X_Spatial (&quot;Slide_1&quot;,filename &#x3D; &quot;filtered_feature_bc_matrix.h5&quot;,assay &#x3D; &quot;spatial&quot;)# 质量控制 不只是能体现小提琴图，还能将每个 spot 的测序质量体现在切片上，帮我们确定哪些组织可能会出现问题 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3. 质量控制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;dir.create (&quot;QC&quot;)##UMI 统计画图plot1 &lt;- VlnPlot (orc1, features &#x3D; &quot;nCount_Spatial&quot;, pt.size &#x3D; 0.1) + NoLegend ()plot2 &lt;- SpatialFeaturePlot (orc1, features &#x3D; &quot;nCount_Spatial&quot;) + theme (legend.position &#x3D; &quot;right&quot;)pearplot &lt;- plot_grid (plot1,plot2) ggsave (&quot;QC&#x2F;Slide1_UMI.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 12, height &#x3D; 5) ##Feature&#x2F;Gene 统计画图plot1 &lt;- VlnPlot (orc1, features &#x3D; &quot;nFeature_Spatial&quot;, pt.size &#x3D; 0.1) + NoLegend ()plot2 &lt;- SpatialFeaturePlot (orc1, features &#x3D; &quot;nFeature_Spatial&quot;) + theme (legend.position &#x3D; &quot;right&quot;)pearplot &lt;- plot_grid (plot1,plot2) ggsave (&quot;QC&#x2F;Slide1_Feature.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 12, height &#x3D; 5) 可以明显的看到，不管是 UMI 还是 Feature，在 spot 中差异主要是有与切片组织的细胞数目以及细胞类型导致的。比如，在花瓣中可以看到非常少的 UMI 以及 Feature，在中间的分生组织中，UMI 和 Feature 的数目非常多。因此，单细胞的标准方法 (如 LogNormalize 函数) 可能会有问题，在空间转录组分析中，一般使用其他方法进行标准化。 # 数据标准化 目前空间转录组数据推荐使用 sctransform，具体的原理我还没有看懂，所以先根据流程走一遍，看看效果 为了探究标准化方法的不同，sctransform 和 log 规范化结果如何与 UMIs 的数量相关。为了进行比较，首先运行 sctransform 来存储所有基因的值，并通过 NormalizeData 运行一个 log 规范化过程。 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;4. 数据标准化 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;## 目前空间转录组推荐使用 SCTransform，集合了单细胞标准化的 NormalizeData ()，ScaleData ()，FindVariableFeatures ()，dir.create (&quot;Normalize&quot;)orc1 &lt;- SCTransform (orc1, assay &#x3D; &quot;Spatial&quot;, return.only.var.genes &#x3D; FALSE, verbose &#x3D; FALSE)## 比较 SCTransform 与 log Normalization 的区别orc1 &lt;- NormalizeData (orc1, verbose &#x3D; FALSE, assay &#x3D; &quot;Spatial&quot;)## 计算 UMI 与 Feature 的相关性，分为 5 组orc1 &lt;- GroupCorrelation (orc1, group.assay &#x3D; &quot;Spatial&quot;, assay &#x3D; &quot;Spatial&quot;, slot &#x3D; &quot;data&quot;, do.plot &#x3D; FALSE)orc1 &lt;- GroupCorrelation (orc1, group.assay &#x3D; &quot;Spatial&quot;, assay &#x3D; &quot;SCT&quot;, slot &#x3D; &quot;scale.data&quot;, do.plot &#x3D; FALSE)p1 &lt;- GroupCorrelationPlot (orc1, assay &#x3D; &quot;Spatial&quot;, cor &#x3D; &quot;nCount_Spatial_cor&quot;) + ggtitle (&quot;Log Normalization&quot;) + theme (plot.title &#x3D; element_text (hjust &#x3D; 0.5))p2 &lt;- GroupCorrelationPlot (orc1, assay &#x3D; &quot;SCT&quot;, cor &#x3D; &quot;nCount_Spatial_cor&quot;) + ggtitle (&quot;SCTransform Normalization&quot;) + theme (plot.title &#x3D; element_text (hjust &#x3D; 0.5))p3 &lt;- plot_grid (p1, p2)ggsave (&quot;Normalize&#x2F;Normalization_cor_Slide1.pdf&quot;, plot &#x3D; p3, width &#x3D; 12, height &#x3D; 5) 对于上面的箱形图，计算每个特征 (基因) 与 UMIs 数量 (这里的 nCount_Spatial 变量) 的相关性。然后，根据基因的平均表达将它们分组，并生成这些相关性的箱形图。 同时这里需要注意，SCT 标准化后有个单独的 assay (SCT)，里面包含三个矩阵，分别为 count,data 以及 scale.data，log 标准化也有一个 assay (Spatial)，里面也包含三个矩阵，但是 scale.data 的数据为 0 标准化之后进行高变基因的筛选，这部分没什么可说的，与单细胞是一致的 top10 &lt;- head(VariableFeatures(orc1), 10) plot1 &lt;- VariableFeaturePlot(orc1) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE, size=2.5) ggsave(&quot;Normalize/VariableFeature_Slide1.pdf&quot;, plot = plot2, width = 9, height = 6) # 数据降维与聚类 由于文章中使用了 STEEL 方法，所以这次的分析只是走走流程，之后会按照文章中的 STEEL 方法进行测试 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5. 数据降维与聚类 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;dir.create (&quot;cluster&quot;)## PCA 降维并提取主成分orc1 &lt;- RunPCA (orc1, features &#x3D; VariableFeatures (orc1_new)) plot1 &lt;- DimPlot (orc1, reduction &#x3D; &quot;pca&quot;, group.by&#x3D;&quot;orig.ident&quot;) plot2 &lt;- ElbowPlot (orc1, ndims&#x3D;40, reduction&#x3D;&quot;pca&quot;) pearplot &lt;- plot_grid (plot1,plot2)ggsave (&quot;cluster&#x2F;PCA_Slide1.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 13, height &#x3D; 6)pdf (&quot;cluster&#x2F;PC_heatmap_Slide1.pdf&quot;,height &#x3D; 12,width &#x3D; 12)DimHeatmap (orc1, dims &#x3D; 1:9, nfeatures&#x3D;10, cells &#x3D; 200, balanced &#x3D; TRUE)dev.off ()## 细胞聚类## 此步利用 细胞 - PC 值 矩阵计算细胞之间的距离，## 然后利用距离矩阵来聚类。其中有两个参数需要人工选择，## 第一个是 FindNeighbors () 函数中的 dims 参数，需要指定哪些 pc 轴用于分析，选择依据是之前介绍的 cluster&#x2F;pca.png 文件中的右图。## 第二个是 FindClusters () 函数中的 resolution 参数，需要指定一个数值，用于决定 clusters 的相对数量，数值越大 cluters 越多。orc1 &lt;- FindNeighbors (orc1, dims &#x3D; 1:20) orc1 &lt;- FindClusters (orc1, resolution &#x3D; 0.9)metadata &lt;- orc1@meta.datatable (orc1@meta.data$seurat_clusters)cell_cluster &lt;- data.frame (cell_ID&#x3D;rownames (metadata), cluster_ID&#x3D;metadata$seurat_clusters)write.csv (cell_cluster,&#39;cluster&#x2F;cell_cluster_Slide1.csv&#39;,row.names &#x3D; F) 使用 resolution = 0.9 只生成了 12 个聚类，原文中有 40 个，大家在设置的时候可以把 resolution 调到 2 甚至 3 左右看看效果 ## 非线性降维## tsneorc1 &lt;- RunTSNE (orc1, dims &#x3D; 1:20)embed_tsne &lt;- Embeddings (orc1, &#39;tsne&#39;)write.csv (embed_tsne,&#39;cluster&#x2F;embed_tsne_Slide1.csv&#39;)p1 &lt;- DimPlot (orc1, reduction &#x3D; &quot;tsne&quot;, label &#x3D; TRUE)p2 &lt;- SpatialDimPlot (orc1, label.size &#x3D; 3, pt.size.factor &#x3D; 1.3)pearplot &lt;- plot_grid (p1,p2)ggsave (&quot;cluster&#x2F;tsne_Slide1.pdf&quot;, plot &#x3D; p2, width &#x3D; 6, height &#x3D; 6)## UMAPorc1 &lt;- RunUMAP (orc1,dims &#x3D; 1:20)embed_umap &lt;- Embeddings (orc1, &#39;umap&#39;)write.csv (embed_umap,&#39;cluster&#x2F;embed_umap_Slide1.csv&#39;)p1 &lt;- DimPlot (orc1, reduction &#x3D; &quot;umap&quot;, label &#x3D; TRUE)p2 &lt;- SpatialDimPlot (orc1, label &#x3D; TRUE, label.size &#x3D; 3, pt.size.factor &#x3D; 1.3)pearplot &lt;- plot_grid (p1,p2)ggsave (&quot;cluster&#x2F;umap_Slide1.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 13, height &#x3D; 6) #6. 部分基因展示 此处是我比较纠结的地方，因为一开始得到的数据和原文中有点不符，后来发现可能的原因是文章中使用的展示数据是 counts ## featureplotdir.create(&quot;featureplot&quot;)p1 &lt;- SpatialFeaturePlot(orc1, features &#x3D; &quot;PAXXG070630&quot;,slot&#x3D;&quot;counts&quot;,pt.size.factor &#x3D; 1.6,min.cutoff &#x3D; 0.1)p2 &lt;- SpatialFeaturePlot(orc1, features &#x3D; &quot;PAXXG070630&quot;,slot&#x3D;&quot;data&quot;,pt.size.factor &#x3D; 1.6,min.cutoff &#x3D; 0.1)p3 &lt;- SpatialFeaturePlot(orc1, features &#x3D; &quot;PAXXG070630&quot;,slot&#x3D;&quot;scale.data&quot;,pt.size.factor &#x3D; 1.6,min.cutoff &#x3D; 0.1)pearplot &lt;- plot_grid(p1,p2,p3,align &#x3D; &quot;v&quot;,axis &#x3D; &quot;b&quot;,ncol &#x3D; 3)ggsave(&quot;featureplot&#x2F;SCTSlide1.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 18, height &#x3D; 7) #总结 目前先把前期的工作的进行了一下，原文中进行了两个拟时分析，但因为聚类不一样所以先不进行分析，研究完 STEEL 之后再进行拟时分析。 总体来讲与单细胞变化不大，有优势也有劣势吧，对于细胞分型来说，空间转录组有先天优势，可以直接根据切片信息判断细胞类型，但是空间转录组最小的单位 spot，不能代表单个细胞，分辨率可能还存在问题","tags":"bioinformatics spatial_transcriptome"},{"title":"比较基因组学分析3：特异节点基因家族富集分析（非模式物种GO/KEEG库构建）","url":"/2022/12/15/2022-12-15-GO/","text":"# 1. 前言 上次讲到基因家族的收缩扩张分析，这次我们以某个节点为切入点，进行特异节点的功能富集分析 其实这篇教程适用于所有的非模式物种 (没有现成的 GO/KEGG 库的物种) 的富集分析 物种特异的比较简单就不进行实践了 # 2. 节点选择 这次选择一个进化上比较重要的节点，水生到陆生的过程，对应进化树为 node25 # 3. 获取目的基因 主要是目标基因与背景基因的选择，目标基因可以是该节点显著扩张的基因家族包含的所有物种基因，背景基因一般为该节点包含的 Orthogroup # 3.1 获取 node25 显著扩张的基因 cat Gamma_p0.05change.tab | cut -f1,27 | grep &quot;+[1-9]&quot; | cut -f1 &gt; node25significant.expand#node25 显著扩张的 orthogroupsIDgrep -f node0significant.expand Orthogroups.txt |sed &quot;s&#x2F;&#x2F;\\n&#x2F;g&quot; | grep -E &quot;Ath|Csa|Vvi|Aof|Osa|Zma|Nco|Atr|Tpl|Cri|Smo|Mpo|Ppa&quot; | sort | uniq &gt; node25significant.expand.genes目前我们得到了需要进行富集分析的目标基因，接下来是背景基因的选择 # 3.2 node25 背景基因选择 awk &#39;NR!&#x3D;1 &amp;&amp; $27&gt;0 &#123;print $0&#125;&#39; Gamma_count.tab | cut -f1 &gt; node25.orthogroups#node25 中存在基因的 orthogroupsIDgrep -f node25.orthogroups Orthogroups.txt |sed &quot;s&#x2F;&#x2F;\\n&#x2F;g&quot; | grep -E &quot;Ath|Csa|Vvi|Aof|Osa|Zma|Nco|Atr|Tpl|Cri|Smo|Mpo|Ppa&quot; | sort | uniq &gt; node25.genesnode25.genes 和 node25significant.expand.genes 就是我们进行富集分析所需要的基因号，接下来就是构建背景基因的 GO 和 KEGG 注释，由于是无参物种，所以我们需要自己构建 # 4 背景基因的 GO 和 KEGG 注释 # 4.1 GO/KEGG 注释 使用 eggnog 对背景基因进行注释 seqkit grep -f node25.genes ..&#x2F;..&#x2F;..&#x2F;allpep.fa &gt; node25background.fa # 提取背景基因，需要严格注意基因数是否一致emapper.py -m diamond -i node25background.fa -o node25 --cpu 16最后我们拿到 node25.emapper.annotations 文件，将前三行和 #删除 # 4.2 GO 注释库构建 获取 GO 的注释信息：下载地址：http://purl.obolibrary.org/obo/go/go-basic.obo 之后进行修饰 grep &quot;^id:&quot; go-basic.obo |awk &#39;&#123;print $2&#125;&#39; &gt; GO.idgrep &quot;^name:&quot; go-basic.obo |awk &#39;&#123;print $2&#125;&#39; &gt; GO.name grep &quot;^namespace:&quot; go-basic.obo |awk &#39;&#123;print $2&#125;&#39; &gt; GO.classpaste GO.id GO.name GO.class -d &quot;\\t&quot; &gt; GO.library文件一共有三列 GO:1903040 exon-exon junction complex assembly biological processGO:1903045 neural crest cell migration involved in sympathetic nervous system development biological processGO:1903046 meiotic cell cycle process biological processGO:1903043 positive regulation of chondrocyte hypertrophy biological processGO:1903044 protein localization to membrane raft biological processGO:1903049 negative regulation of acetylcholine-gated cation channel activity biological processGO:1903047 mitotic cell cycle process biological processGO:1903048 regulation of acetylcholine-gated cation channel activity biological processGO:1903012 positive regulation of bone development biological processGO:1903013 response to differentiation-inducing factor 1 biological processGO:1903010 regulation of bone development biological processGO:1903011 negative regulation of bone development biological processGO:1903016 negative regulation of exo-alpha-sialidase activity biological processGO:1903017 positive regulation of exo-alpha-sialidase activity biological processGO:1903014 cellular response to differentiation-inducing factor 1 biological processGO:1903015 regulation of exo-alpha-sialidase activity biological processGO:1903018 regulation of glycoprotein metabolic process biological processGO:1903019 negative regulation of glycoprotein metabolic process biological processGO:1903020 positive regulation of glycoprotein metabolic process biological processGO:1903023 regulation of ascospore-type prospore membrane assembly biological process# 4.3 KEGG 注释库构建 需要下载 ko00001.json： https://www.genome.jp/kegg-bin/get_htext?ko00001 # 需要下载 json 文件 (这是是经常更新的)# https:&#x2F;&#x2F;www.genome.jp&#x2F;kegg-bin&#x2F;get_htext?ko00001# 代码来自：http:&#x2F;&#x2F;www.genek.tv&#x2F;course&#x2F;225&#x2F;task&#x2F;4861&#x2F;showlibrary (jsonlite)library (purrr)library (RCurl)library (dplyr)library (stringr) kegg &lt;- function (json &#x3D; &quot;ko00001.json&quot;) &#123; pathway2name &lt;- tibble (Pathway &#x3D; character (), Name &#x3D; character ()) ko2pathway &lt;- tibble (Ko &#x3D; character (), Pathway &#x3D; character ()) kegg &lt;- fromJSON (json) for (a in seq_along (kegg [[&quot;children&quot;]][[&quot;children&quot;]])) &#123; A &lt;- kegg [[&quot;children&quot;]][[&quot;name&quot;]][[a]] for (b in seq_along (kegg [[&quot;children&quot;]][[&quot;children&quot;]][[a]][[&quot;children&quot;]])) &#123; B &lt;- kegg [[&quot;children&quot;]][[&quot;children&quot;]][[a]][[&quot;name&quot;]][[b]] for (c in seq_along (kegg [[&quot;children&quot;]][[&quot;children&quot;]][[a]][[&quot;children&quot;]][[b]][[&quot;children&quot;]])) &#123; pathway_info &lt;- kegg [[&quot;children&quot;]][[&quot;children&quot;]][[a]][[&quot;children&quot;]][[b]][[&quot;name&quot;]][[c]] pathway_id &lt;- str_match (pathway_info, &quot;ko [0-9]&#123;5&#125;&quot;)[1] pathway_name &lt;- str_replace (pathway_info, &quot;\\\\[PATH:ko [0-9]&#123;5&#125;\\\\]&quot;, &quot;&quot;) %&gt;% str_replace (&quot;[0-9]&#123;5&#125; &quot;,&quot;&quot;) pathway2name &lt;- rbind (pathway2name, tibble (Pathway &#x3D; pathway_id, Name &#x3D; pathway_name)) kos_info &lt;- kegg [[&quot;children&quot;]][[&quot;children&quot;]][[a]][[&quot;children&quot;]][[b]][[&quot;children&quot;]][[c]][[&quot;name&quot;]] kos &lt;- str_match (kos_info, &quot;K [0-9]*&quot;)[,1] ko2pathway &lt;- rbind (ko2pathway, tibble (Ko &#x3D; kos, Pathway &#x3D; rep (pathway_id, length (kos)))) &#125; &#125; &#125; colnames (ko2pathway) &lt;- c (&quot;KO&quot;,&quot;Pathway&quot;) save (pathway2name, ko2pathway, file &#x3D; &quot;kegg_info.RData&quot;) write.table (pathway2name,&quot;KEGG.library&quot;,sep&#x3D;&quot;\\t&quot;,row.names &#x3D; F) &#125; kegg (json &#x3D; &quot;ko00001.json&quot;)# 4.4 背景注释构建 主要是将自己的基因集与注释库结合 library (clusterProfiler)library (dplyr)library (stringr)options (stringsAsFactors &#x3D; F)##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;STEP1:GO 注释生成 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 自己构建的话，首先需要读入文件egg &lt;- read.delim (&quot;node25.emapper.annotations&quot;,header &#x3D; T,sep&#x3D;&quot;\\t&quot;)egg [egg&#x3D;&#x3D;&quot;&quot;]&lt;-NA #将空行变成 NA，方便下面的去除# 从文件中挑出基因 query 与 eggnog 注释信息##gene_info &lt;- egg %&gt;% ## dplyr::select (GID &#x3D; query, GENENAME &#x3D; eggNOG_OGs) %&gt;% na.omit ()# 挑出 query_name 与 GO 注释信息gterms &lt;- egg %&gt;% dplyr::select (query, GOs) %&gt;% na.omit ()gene_ids &lt;- egg$queryeggnog_lines_with_go &lt;- egg$GOs!&#x3D; &quot;&quot;eggnog_lines_with_goeggnog_annoations_go &lt;- str_split (egg [eggnog_lines_with_go,]$GOs, &quot;,&quot;)gene2go &lt;- data.frame (gene &#x3D; rep (gene_ids [eggnog_lines_with_go], times &#x3D; sapply (eggnog_annoations_go, length)), term &#x3D; unlist (eggnog_annoations_go))names (gene2go) &lt;- c (&#39;gene_id&#39;, &#39;ID&#39;)go2name &lt;- read.delim (&#39;GO.library&#39;, header &#x3D; FALSE, stringsAsFactors &#x3D; FALSE)names (go2name) &lt;- c (&#39;ID&#39;, &#39;Description&#39;, &#39;Ontology&#39;)go_anno &lt;- merge (gene2go, go2name, by &#x3D; &#39;ID&#39;, all.x &#x3D; TRUE)## 将 GO 注释信息保存save (go_anno,file &#x3D; &quot;node25_GO.rda&quot;)##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;STEP2:KEGG 注释生成 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;gene2ko &lt;- egg %&gt;% dplyr::select (GID &#x3D; query, KO &#x3D; KEGG_ko) %&gt;% na.omit (）pathway2name &lt;- read.delim (&quot;KEGG.library&quot;)colnames (pathway2name)&lt;-c (&quot;Pathway&quot;,&quot;Name&quot;)gene2ko$KO &lt;- str_replace (gene2ko$KO, &quot;ko:&quot;,&quot;&quot;)gene2pathway &lt;- gene2ko %&gt;% left_join (ko2pathway, by &#x3D; &quot;KO&quot;) %&gt;% dplyr::select (GID, Pathway) %&gt;% na.omit ()kegg_anno&lt;- merge (gene2pathway,pathway2name,by &#x3D; &#39;Pathway&#39;, all.x &#x3D; TRUE)[,c (2,1,3)]colnames (kegg_anno) &lt;- c (&#39;gene_id&#39;,&#39;pathway_id&#39;,&#39;pathway_description&#39;)save (kegg_anno,file &#x3D; &quot;node25_KEGG.rda&quot;)# 4.5 GO/KEEG 富集分析 利用生成的 node25_GO.rda、node25_KEGG.rda、以及之前的 node25significant.expand.genes 文件进行富集分析 我在分析的时候没有设置 p 的阈值，输出了所有的富集结果，毕竟作图也只需要 TOP10 或者 TOP20，大家按照需求设定 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;STEP3:GO 富集分析 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 目标基因列表 (全部基因)gene_select &lt;- read.delim (file &#x3D; &#39;node25significant.expand.genes&#39;, stringsAsFactors &#x3D; FALSE,header &#x3D; F)$V1#GO 富集分析# 默认以所有注释到 GO 的基因为背景集，也可通过 universe 参数输入背景集# 默认以 p&lt;0.05 为标准，Benjamini 方法校正 p 值，q 值阈值 0.2# 默认输出 top500 富集结果# 如果想输出所有富集结果（不考虑 p 值阈值等），将 p、q 等值设置为 1 即可# 或者直接在 enrichResult 类对象中直接提取需要的结果go_rich &lt;- enricher (gene &#x3D; gene_select, TERM2GENE &#x3D; go_anno [c (&#39;ID&#39;, &#39;gene_id&#39;)], TERM2NAME &#x3D; go_anno [c (&#39;ID&#39;, &#39;Description&#39;)], pvalueCutoff &#x3D; 1, pAdjustMethod &#x3D; &#39;BH&#39;, qvalueCutoff &#x3D; 1 )# 输出默认结果，即根据上述 p 值等阈值筛选后的tmp &lt;- merge (go_rich, go2name [c (&#39;ID&#39;, &#39;Ontology&#39;)], by &#x3D; &#39;ID&#39;)tmp &lt;- tmp [c (10, 1:9)]tmp &lt;- tmp [order (tmp$pvalue), ]write.table (tmp, &#39;node6expand.xls&#39;, sep &#x3D; &#39;\\t&#39;, row.names &#x3D; FALSE, quote &#x3D; FALSE)##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;STEP4:KEGG 注释 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;gene_select &lt;- read.delim (&#39;node25significant.expand.genes&#39;, stringsAsFactors &#x3D; FALSE,header &#x3D; F)$V1#KEGG 富集分析# 默认以所有注释到 KEGG 的基因为背景集，也可通过 universe 参数指定其中的一个子集作为背景集# 默认以 p&lt;0.05 为标准，Benjamini 方法校正 p 值，q 值阈值 0.2# 默认输出 top500 富集结果kegg_rich &lt;- enricher (gene &#x3D; gene_select, TERM2GENE &#x3D; kegg_anno [c (&#39;pathway_id&#39;, &#39;gene_id&#39;)], TERM2NAME &#x3D; kegg_anno [c (&#39;pathway_id&#39;, &#39;pathway_description&#39;)], pvalueCutoff &#x3D; 1, pAdjustMethod &#x3D; &#39;BH&#39;, qvalueCutoff &#x3D; 1, maxGSSize &#x3D; 500)# 输出默认结果，即根据上述 p 值等阈值筛选后的write.table (kegg_rich, &#39;node25significant.expand.KEGG.xls&#39;, sep &#x3D; &#39;\\t&#39;, row.names &#x3D; FALSE, quote &#x3D; FALSE)需要注意生成的文件中有一些 term 可能是重复的，比如 GO 富集结果的 16,17 行，仔细看 geneID 那一列就会发现两行的基因是完全一样的，需要删掉一个。还有一点就是在 GO/KEGG 富集的结果中，有一些是动物相关的 (KEGG 结果的第一行)，这些也请酌情考虑 # 5 GO/KEGG 绘图 此次使用 TOP10 的 term 进行绘图，看一下在陆生植物出现的关键进化节点主要是哪些基因功能发生了大规模扩张 library (ggplot2)pathway &#x3D; read.delim (&quot;node25significant.expand.GO.xls&quot;,header &#x3D; T,sep&#x3D;&quot;\\t&quot;)pathway$GeneRatio&lt;- pathway [,10]&#x2F;54700 ## 这个 54700 是 GeneRatio 的那个数值，自己修改pathway$log&lt;- -log10 (pathway [,6])library (dplyr)library (ggrepel)GO &lt;- arrange (pathway,pathway [,6])GO_dataset &lt;- GO [1:10,]# 按照 PValue 从低到高排序 [升序]GO_dataset$Description&lt;- factor (GO_dataset$Description,levels &#x3D; rev (GO_dataset$Description))GO_dataset$GeneRatio &lt;- as.numeric (GO_dataset$GeneRatio)GO_dataset$GeneRatioGO_dataset$log# 图片背景设定mytheme &lt;- theme (axis.title&#x3D;element_text (face&#x3D;&quot;bold&quot;, size&#x3D;8,colour &#x3D; &#39;black&#39;), #坐标轴标题 axis.text.y &#x3D; element_text (face&#x3D;&quot;bold&quot;, size&#x3D;6,colour &#x3D; &#39;black&#39;), #坐标轴标签 axis.text.x &#x3D; element_text (face &#x3D;&quot;bold&quot;,color&#x3D;&quot;black&quot;,angle&#x3D;0,vjust&#x3D;1,size&#x3D;8), axis.line &#x3D; element_line (size&#x3D;0.5, colour &#x3D; &#39;black&#39;), #轴线 panel.background &#x3D; element_rect (color&#x3D;&#39;black&#39;), #绘图区边框 plot.title &#x3D; element_text (face&#x3D;&quot;bold&quot;, size&#x3D;8,colour &#x3D; &#39;black&#39;,hjust &#x3D; 0.8), legend.key &#x3D; element_blank () #关闭图例边框)# 绘制 GO 气泡图p &lt;- ggplot (GO_dataset,aes (x&#x3D;GeneRatio,y&#x3D;Description,colour&#x3D;log,size&#x3D;Count,shape&#x3D;Ontology))+ geom_point ()+ scale_size (range&#x3D;c (2, 8))+ scale_colour_gradient (low &#x3D; &quot;#52c2eb&quot;,high &#x3D; &quot;#EA4F30&quot;)+ theme_bw ()+ labs (x&#x3D;&#39;Fold Enrichment&#39;,y&#x3D;&#39;GO Terms&#39;, #自定义 x、y 轴、标题内容 title &#x3D; &#39;Enriched GO Terms&#39;)+ labs (color&#x3D;expression (-log [10](pvalue)))+ theme (legend.title&#x3D;element_text (size&#x3D;8), legend.text &#x3D; element_text (size&#x3D;14))+ theme (axis.title.y &#x3D; element_text (margin &#x3D; margin (r &#x3D; 50)),axis.title.x &#x3D; element_text (margin &#x3D; margin (t &#x3D; 20)))+ theme (axis.text.x &#x3D; element_text (face &#x3D;&quot;bold&quot;,color&#x3D;&quot;black&quot;,angle&#x3D;0,vjust&#x3D;1))plot &lt;- p+mythemeplot# 保存图片ggsave (plot,filename &#x3D; &quot;node25GO.pdf&quot;,width &#x3D; 210,height &#x3D; 210,units &#x3D; &quot;mm&quot;,dpi&#x3D;300)ggsave (plot,filename &#x3D; &quot;node25GO.png&quot;,width &#x3D; 210,height &#x3D; 210,units &#x3D; &quot;mm&quot;,dpi&#x3D;300)KEGG 同理，大家修改运行参数和输入文件即可 pathway &#x3D; read.delim (&quot;node25significant.expand.KEGG.xls&quot;,header &#x3D; T,sep&#x3D;&quot;\\t&quot;)pathway$GeneRatio&lt;- pathway [,9]&#x2F;31537pathway$log&lt;- -log10 (pathway [,5])library (dplyr)library (ggrepel)GO &lt;- arrange (pathway,pathway [,5])GO_dataset &lt;- GO [1:10,]#Pathway 列最好转化成因子型，否则作图时 ggplot2 会将所有 Pathway 按字母顺序重排序# 将 Pathway 列转化为因子型GO_dataset$Description&lt;- factor (GO_dataset$Description,levels &#x3D; rev (GO_dataset$Description))GO_dataset$GeneRatio &lt;- as.numeric (GO_dataset$GeneRatio)GO_dataset&lt;- arrange (GO_dataset,GO_dataset [,5])GO_dataset$GeneRatioGO_dataset$log# 图片背景设定mytheme &lt;- theme (axis.title&#x3D;element_text (face&#x3D;&quot;bold&quot;, size&#x3D;8,colour &#x3D; &#39;black&#39;), #坐标轴标题 axis.text.y &#x3D; element_text (face&#x3D;&quot;bold&quot;, size&#x3D;6,colour &#x3D; &#39;black&#39;), #坐标轴标签 axis.text.x &#x3D; element_text (face &#x3D;&quot;bold&quot;,color&#x3D;&quot;black&quot;,angle&#x3D;0,vjust&#x3D;1,size&#x3D;8), axis.line &#x3D; element_line (size&#x3D;0.5, colour &#x3D; &#39;black&#39;), #轴线 panel.background &#x3D; element_rect (color&#x3D;&#39;black&#39;), #绘图区边框 plot.title &#x3D; element_text (face&#x3D;&quot;bold&quot;, size&#x3D;8,colour &#x3D; &#39;black&#39;,hjust &#x3D; 0.8), legend.key &#x3D; element_blank () #关闭图例边框)# 绘制 KEGG 气泡图p &lt;- ggplot (GO_dataset,aes (x&#x3D;GeneRatio,y&#x3D;Description,colour&#x3D;log,size&#x3D;Count))+ geom_point ()+ scale_size (range&#x3D;c (2, 8))+ scale_colour_gradient (low &#x3D; &quot;#52c2eb&quot;,high &#x3D; &quot;#EA4F30&quot;)+ theme_bw ()+ labs (x&#x3D;&#39;Fold Enrichment&#39;,y&#x3D;&#39;KEEG Terms&#39;, #自定义 x、y 轴、标题内容 title &#x3D; &#39;Enriched KEEG Terms&#39;)+ labs (color&#x3D;expression (-log [10](pvalue)))+ theme (legend.title&#x3D;element_text (size&#x3D;8), legend.text &#x3D; element_text (size&#x3D;14))+ theme (axis.title.y &#x3D; element_text (margin &#x3D; margin (r &#x3D; 50)),axis.title.x &#x3D; element_text (margin &#x3D; margin (t &#x3D; 20)))+ theme (axis.text.x &#x3D; element_text (face &#x3D;&quot;bold&quot;,color&#x3D;&quot;black&quot;,angle&#x3D;0,vjust&#x3D;1))plot &lt;- p+mythemeplot# 保存图片ggsave (plot,filename &#x3D; &quot;node25KEGG.pdf&quot;,width &#x3D; 210,height &#x3D; 210,units &#x3D; &quot;mm&quot;,dpi&#x3D;300)ggsave (plot,filename &#x3D; &quot;node25KEGG.png&quot;,width &#x3D; 210,height &#x3D; 210,units &#x3D; &quot;mm&quot;,dpi&#x3D;300)最后我们可以看到，在 GO 富集中，最显著的是水运输相关功能，KEGG 富集中，最显著的是昼夜节律，大家觉得陆生植物的进化和这两个功能有没有关系？欢迎讨论 # 6 结果整理 结合这三篇推文的结果，我们可以整理一张主图 # 总结 == 比较基因组学分析的基本内容已经介绍完了，如果说有遗漏的内容那应该就是加倍化事件，由于本次使用的数据集跨度过大所以没有增加 WGD 的分析，大家有什么问题欢迎交流 ==","tags":"bioinformatics comparative_genomics"},{"title":"比较基因组学分析2：基因家族收缩与扩张分析","url":"/2022/12/14/2022-12-14-CAFE/","text":"# 前言 # 上篇推文中介绍到比较基因组学分析常用套路的第一步，利用单拷贝基因构建具有分化时间的物种树，补充一点，对于跨度较大的物种，可以选择单拷贝基因的方法，比如此次分析使用的物种。对于目级或者科级水平来讲，推荐使用共线性基因建树。以十字花科为例，如果用单拷贝基因，可能只有 1000 多组，但是使用共线性可能有接近 5000 组。共线性基因建树可以使用 WGDI 的方法，这部分内容我以后会探索一下。 本篇推文主要讲基因家族的收缩与扩张分析，使用的软件是 cafe5，2020 年发表，相较于 cafe4 来讲操作更加方便并且新增了模型 (Gamma) # 安装 命令行提示符git clone https:&#x2F;&#x2F;github.com&#x2F;hahnlab&#x2F;CAFE5.gitcd CAFE5.&#x2F;configuremake安装过程其实有点复杂，可能不同的服务器会出现不同的错误，这个请自行解决 # CAFE5 使用 输入文件至少要两个，一个是基因家族数目统计文件 Genefamilies_Count.tsv，一个是树文件 tree.txt（带有分化时间），还可以增加一个 lambda 文件 # 主要参数 命令行提示符--fixed_alpha, -aAlpha value of the discrete gamma distribution to use in category calculations. If not specified, the alpha parameter will be estimated by maximum likelihood.--lambda_per_family, -bEstimate lambda by family (for testing purposes only).--cores, -cNumber of processing cores to use, requires an integer argument. Default&#x3D;All available cores.--error_model, -eRun with no file name to estimate the global error model file. This file can be provided in subsequent runs by providing the path to the Error model file with no spaces (e.g. -eBase_error_model.txt).--Expansion, -EExpansion parameter for Nelder-Mead optimizer, Default&#x3D;2.--rootdist, -fPath to root distribution file for simulating datasets.--help, -hHelp menu with a list of all commands.--infile, -iPath to tab delimited gene families file to be analyzed - Required for estimation.--Iterations, -IMaximum number of iterations that will be performed in lambda search. Default&#x3D;300 (increase this number if likelihood is still improving when limit is hit).--n_gamma_cats, -kNumber of gamma categories to use. If specified, the Gamma model will be used to run calculations; otherwise the Base model will be used.--fixed_lambda, -lValue (between 0 and 1) for a single user provided lambda value, otherwise lambda is estimated.--log_config, -LTurn on logging, provide name of the configuration file for logging (see example log.config file).--fixed_multiple_lambdas, -mMultiple lambda values, comma separated, must be used in conjunction with lambda tree (-y).--output_prefix, -oOutput directory - Name of directory automatically created for output. Default&#x3D;results.--poisson, -pUse a Poisson distribution for the root frequency distribution. If no -p flag is given, a uniform distribution will be used. A value can be specified (-p10, or --poisson&#x3D;10); otherwise the distribution will be estimated from the gene families.--pvalue, -PP-value to use for determining significance of family size change, Default&#x3D;0.05.--chisquare_compare, -rChi square compare (not tested).--Reflection, -RReflection parameter for Nelder-Mead optimizer, Default&#x3D;1.--simulate, -sSimulate families. Either provide an argument of the number of families to simulate (-s100, or --simulate&#x3D;100) or provide a rootdist file giving a set of root family sizes to match. Without such a file, the families will be generated with root sizes selected randomly between 0 and 100.--tree, -tPath to file containing newick formatted tree - Required for estimation.--lambda_tree, -yPath to lambda tree, for use with multiple lambdas.--zero_root, -zInclude gene families that don&#39;t exist at the root, not recommended.其实主要用的就是 - i -p -k -y -t 这些参数 # 输入文件准备 # Genefamilies_Count.tsv 制表符分隔的基因家族计数文件，通常用 OrthoMCL, OrthoFinder 等软件获取计数信息。 示例格式 命令行提示符Desc Family ID human chimp orang baboon gibbon macaque marmoset rat mouse cat horse cowATPase ORTHOMCL1 52 55 54 57 54 56 56 53 52 57 55 54(null) ORTHOMCL2 76 51 41 39 45 36 37 67 79 37 41 49HMG box ORTHOMCL3 50 49 48 48 46 49 48 55 52 51 47 55(null) ORTHOMCL4 43 43 47 53 44 47 46 59 58 51 50 55Dynamin ORTHOMCL5 43 40 43 44 31 46 33 79 70 43 49 50............DnaJ ORTHOMCL10016 45 46 50 46 46 47 46 48 49 45 44 48我们首先利用 OrthoFinder 的 Orthogroups.GeneCount.tsv 文件生成符合要求的输入文件 命令行提示符cp Results_May02&#x2F;Orthogroups&#x2F;Orthogroups.GeneCount.tsv CAFE&#x2F;awk &#39;OFS&#x3D;&quot;\\t&quot; &#123;$NF&#x3D;&quot;&quot;; print&#125;&#39; Orthogroups.GeneCount.tsv &gt; tmp &amp;&amp; awk &#39;&#123;print &quot;(null)&quot;&quot;\\t&quot;$0&#125;&#39; tmp &gt; cafe.input.tsv &amp;&amp; sed -i &#39;1s&#x2F;(null)&#x2F;Desc&#x2F;g&#39; cafe.input.tsv &amp;&amp; rm tmp查看文件格式 命令行提示符Desc Orthogroup Aof.pro Ath.pro Atr.pro Cba.pro Cri.pro Csa.pro Csu.pro Kle.pro Mpo.pro Nco.pro Osa.pro Ppa.pro Smo.pro Tpl.pro Vca.pro Vvi.pro Zma.pro(null) OG0000000 145 112 95 5 372 129 3 1 2 217 126 16 206 419 4 177 117(null) OG0000001 9 4 3 1691 9 96 2 56 2 4 21 0 2 5 3 2 0(null) OG0000002 32 117 62 1 92 117 2 0 20 81 119 77 40 193 5 107 161(null) OG0000003 37 104 54 3 89 76 4 5 10 74 144 22 47 134 8 79 154(null) OG0000004 73 104 51 4 40 80 2 10 12 76 87 33 22 136 5 97 135(null) OG0000005 28 46 36 11 37 47 0 3 50 81 81 32 48 120 0 54 73(null) OG0000006 41 43 74 6 38 57 0 4 25 57 52 19 33 155 0 87 40(null) OG0000007 58 52 60 0 18 42 0 0 12 50 56 17 57 99 1 82 52(null) OG0000008 38 57 26 7 52 47 4 6 19 40 59 43 20 29 1 41 80(null) OG0000009 46 57 26 1 25 46 1 2 11 52 65 29 13 50 1 48 87生成之后还需要剔除不同物种间拷贝数差异过大的基因家族，否则会报错，有内置脚本可以使用，我在运行的时候需要去掉第一行才能使用 命令行提示符python ~&#x2F;soft&#x2F;CAFE5&#x2F;tutorial&#x2F;clade_and_size_filter.py -i cafe.input.tsv -o gene_family_filter.txt -s笨方法 命令行提示符awk &#39;NR&#x3D;&#x3D;1 || $3&lt;100 &amp;&amp; $4&lt;100 &amp;&amp; $5&lt;100 &amp;&amp; $6&lt;100 &amp;&amp; $7&lt;100 &amp;&amp; $8&lt;100 &amp;&amp; $9&lt;100 &amp;&amp; $10&lt;100 &amp;&amp; $11&lt;100 &amp;&amp; $12&lt;100 &amp;&amp; $13&lt;100 &amp;&amp; $14&lt;100 &amp;&amp; $15&lt;100 &amp;&amp; $16&lt;100 &amp;&amp; $17&lt;100 &amp;&amp; $18&lt;100 &amp;&amp; $19&lt;100 &#123;print $0&#125;&#39; cafe.input.tsv &gt;gene_family_filter.txt最后的文件格式，保证第一行的物种名字与进化树的一致即可 命令行提示符Desc Orthogroup Aof Ath Atr Cba Cri Csa Csu Kle Mpo Nco Osa Ppa Smo Tpl Vca Vvi Zma(null) OG0000020 26 37 23 4 35 28 0 1 24 28 43 24 27 47 0 35 42(null) OG0000021 49 41 31 7 30 31 8 2 7 26 49 15 11 31 0 36 45(null) OG0000022 27 25 31 0 27 34 2 1 23 25 46 18 27 44 1 39 45(null) OG0000024 37 40 27 0 22 30 1 11 9 33 38 18 25 43 0 37 39(null) OG0000029 28 26 23 2 24 25 1 2 5 32 34 31 17 35 1 30 40(null) OG0000030 23 30 16 1 23 27 1 1 27 26 26 16 15 49 1 28 35(null) OG0000031 28 36 26 3 27 23 8 1 3 17 37 10 18 38 3 34 28(null) OG0000032 18 16 25 0 24 19 0 5 4 25 36 6 38 49 1 38 35(null) OG0000033 19 17 20 0 12 16 4 6 18 35 42 4 23 39 3 45 28(null) OG0000035 17 37 17 8 28 24 2 2 5 30 41 8 6 26 2 32 37(null) OG0000036 22 15 17 3 22 19 7 12 13 20 24 20 30 38 3 35 22(null) OG0000039 14 27 36 0 34 24 0 2 2 12 41 4 47 13 0 37 26(null) OG0000040 15 30 9 1 19 35 0 2 11 25 26 19 12 48 0 39 27# tree.txt 本步骤直接使用 mcmctree 生成的 FigTree.tre 文件修改一下即可使用 命令行提示符grep &quot;UTREE 1 &#x3D;&quot; FigTree.tre | sed -E -e &quot;s&#x2F;\\[[^]]*\\]&#x2F;&#x2F;g&quot; -e &quot;s&#x2F;[ \\t]&#x2F;&#x2F;g&quot; -e &quot;&#x2F;^$&#x2F;d&quot; -e &quot;s&#x2F;UTREE1&#x3D;&#x2F;&#x2F;&quot; &gt; tree.txt# 运行 CAFE5 命令行提示符cafe5 -i gene_family_filter.txt -t tree.txt -o out -c 1## 如果使用 Gamma 模型与泊松分布 cafe5 -i gene_family_filter.txt -t tree.txt -o out -c 1 -k 2 -p ## 注意 - k 可以调，一般为 2-5结果还是报错 查了一下解决方法，可以将 lambda 值调低 (0.0001) 再进行计算 重新运行 命令行提示符cafe5 -i gene_family_filter.txt -t tree.txt -o out -c 16 -l 0.0001 -k 2 -p当大家出现这种错误时，可以尝试这种解决方案，单单删除这些家族是没用的。 # CAFE5 输出结果 # 结果文件 命令行提示符Gamma_asr.tre ## 每个基因家族的树文件Gamma_branch_probabilities.tab ## 每个分支计算的概率Gamma_category_likelihoods.txt Gamma_change.tab ## 每一个基因家族在每个节点的收缩与扩增数目Gamma_clade_results.txt ## 每个节点基因家族的扩增 &#x2F; 收缩数目Gamma_count.txt ## 每一个基因家族在每个节点的数目Gamma_family_likelihoods.txtGamma_family_results.txt ## 基因家族变化的 p 值和是否显著的结果Gamma_results.txt ## 模型，最终似然值，最终 Lambda 值等参数信息。我们主要用的文件有 Gamma_asr.tre (主要对应后面表格中的节点)、Gamma_change.tab (看哪些基因家族在哪个节点发生变化)、Gamma_clade_results.txt (体现在树上，每个节点基因家族的收缩 / 扩增数目)、Gamma_family_results.txt (显著扩增 / 收缩的基因家族) # 每个节点基因家族收缩 / 扩增数目的体现 其实有绘图脚本，但是很久没有更新，可能不适用于 CAFE5，我们可以自己画 将基因家族的扩增 / 收缩数目体现在树上，需要两个文件，Gamma_asr.tre，Gamma_clade_results.txt 命令行提示符cat Gamma_clade_results.txt#Taxon_ID Increase DecreaseMpo&lt;21&gt; 232 1298Ppa&lt;20&gt; 2231 371&lt;31&gt; 134 65&lt;25&gt; 949 220&lt;23&gt; 134 209Atr&lt;13&gt; 516 922Kle&lt;29&gt; 493 741&lt;12&gt; 245 56&lt;28&gt; 314 340&lt;4&gt; 118 176Cri&lt;17&gt; 1669 287&lt;22&gt; 214 184&lt;19&gt; 445 93&lt;16&gt; 291 352Osa&lt;3&gt; 579 572Aof&lt;6&gt; 935 840&lt;8&gt; 142 112Csa&lt;1&gt; 326 834&lt;7&gt; 640 138Tpl&lt;15&gt; 1147 395&lt;14&gt; 204 273Nco&lt;11&gt; 631 559Zma&lt;2&gt; 1776 232Vvi&lt;5&gt; 958 433&lt;10&gt; 413 112&lt;9&gt; 345 66Smo&lt;18&gt; 842 1315Cba&lt;24&gt; 744 1664&lt;30&gt; 23 17Ath&lt;0&gt; 1090 291Csu&lt;27&gt; 305 1560Vca&lt;26&gt; 438 1040命令行提示符less Gamma_asr.treBEGIN TREES; TREE OG0000021 &#x3D; ((Kle&lt;29&gt;*_2:820.007,(((Mpo&lt;21&gt;*_7:428.285,Ppa&lt;20&gt;*_15:428.285)&lt;23&gt;_12:70.3982,((Cri&lt;17&gt;_30:404.796,(Tpl&lt;15&gt;_31:308.175,(Atr&lt;13&gt;_31:208.47,(Nco&lt;11&gt;*_26:176.909,(((Osa&lt;3&gt;*_49:45.2652,Zma&lt;2&gt;_45:45.2652)&lt;7&gt;_45:60.4652,Aof&lt;6&gt;*_49:105.73)&lt;9&gt;*_44:25.8965,(Vvi&lt;5&gt;_36:101.378,(Csa&lt;1&gt;*_31:83.0358,Ath&lt;0&gt;*_41:83.0358)&lt;4&gt;_36:18.3421)&lt;8&gt;_36:30.2489)&lt;10&gt;*_36:45.2824)&lt;12&gt;_31:31.5605)&lt;14&gt;_31:99.7053)&lt;16&gt;*_30:96.6205)&lt;19&gt;*_27:48.1939,Smo&lt;18&gt;_11:452.99)&lt;22&gt;*_13:45.694)&lt;25&gt;*_12:190.787,Cba&lt;24&gt;_7:689.47)&lt;28&gt;*_7:130.537)&lt;31&gt;_5:177.864,(Csu&lt;27&gt;*_8:874.03,Vca&lt;26&gt;*_0:874.03)&lt;30&gt;_5:123.841)&lt;32&gt;_5可以看到少了个 32 我们可以利用 Gamma_change.tab 文件去找一下 经查看确实没有，忽略这一部分 将两个文件的 nodeid 对应即可绘图 # 其他整理 相较于 CAFE4，这些结果并没有直接体现显著扩张 / 收缩的基因家族，或者我们想找一下某个节点具体扩张的基因，可以结合目前拿到的输出文件进行进一步整理 命令行提示符cat Gamma_family_results.txt |grep &quot;y&quot;|cut -f1 &gt;p0.05.significant # 提取显著扩张或收缩的 orthogroupsIDgrep -f p0.05.significant Gamma_change.tab &gt; Gamma_p0.05change.tab# 显著扩张 &#x2F; 收缩的基因家族在每个节点的收缩与扩增数目cat Gamma_p0.05change.tab | cut -f1,2 | grep &quot;+[1-9]&quot; | cut -f1 &gt; node0significant.expand#Ath 显著扩张的 orthogroupsIDwc -l node0significant.expand#Ath 显著扩张的基因家族数目cp ..&#x2F;..&#x2F;Results_May02&#x2F;Orthogroups&#x2F;Orthogroups.tsv .&#x2F;grep -f node0significant.expand Orthogroups.tsv | cut -f3 | sed &quot;s&#x2F;&#x2F;\\n&#x2F;g&quot; | sed &quot;s&#x2F;\\t&#x2F;\\n&#x2F;g&quot; | sed &quot;s&#x2F;,&#x2F;&#x2F;g&quot; | sort | uniq &gt; node0significant.expand.genes# 提取 Ath 显著扩张的基因，方法一cp ..&#x2F;..&#x2F;Results_May02&#x2F;Orthogroups&#x2F;Orthogroups.txt .&#x2F;grep -f node0significant.expand Orthogroups.txt |sed &quot;s&#x2F;&#x2F;\\n&#x2F;g&quot; | grep &quot;Ath&quot; | sort | uniq &gt; node0significant.expand.genes# 提取 Ath 显著扩张的基因，方法二# 结语 总体来说，个人感觉 CAFE5 要比 CAFE4 方便很多，但是输出结果的可视化方面还需要加强，下一篇推文将简单实践某个节点的基因功能富集分析 (GO/KEGG), 类似于分析下图的红色节点。","tags":"bioinformatics comparative_genomics"},{"title":"比较基因组学分析1：构建单拷贝基因树","url":"/2022/12/08/2022-12-08-SingleCopy/","text":"# 前言 之前有写过单拷贝基因构建物种树的流程，现在我对流程进行优化，而且将会增加后续的基因家族收缩与扩张分析，希望对大家的分析有所帮助 # 物种选择 在此我不在介绍软件的原理和安装了，大家可以去看我之前的推文 物种选择此次包含了整个绿色植物，从绿藻门到被子植物 大部分基因组是在 jgi phytozome 上下载的 绿藻门 Chlorophyte：小球藻：Coccomyxa subellipsoidea (Csu), 团藻：Volvox carteri (Vca) 轮藻门 Charophyta：布氏轮藻：Chara braunii (Cba), Klebsormidium nitens (Kle) 苔藓植物门 Bryophyta：地钱：Marchantia polymorpha (Mpo), 小立碗藓：Physcomitrium patens (Ppa) 石松类 Lycopsida： 江南卷柏：Selaginella moellendorffii (Smo) 蕨类 Ferns： 水蕨：Ceratopteris richardii (Cri) 裸子植物门 Gymnospermae：北美乔柏 Thuja plicata (Tpl) 基部被子植物 Basial Angiosperm：无油樟：Amborella trichopoda (Atr), 睡莲：Nymphaea colorata (Nco) 双子叶植物 Eudicot：葡萄：Vitis vinifera (Vvi), 拟南芥：Arabidopsis thaliana (Ath), 黄瓜：Cucumis sativus (Csa) 单子叶植物 Monocot: 芦笋：Asparagus officinalis (Aof), 水稻：Oryza sativa (Osa), 玉米：Zea mays (Zma) 下载完成后我对每个蛋白序列的 ID 前面加上了物种简写，方便后续使用 sed -i &quot;s/&gt;/&gt;Ath/g&quot; Ath.pro.fasta # Orthofinder 获得单拷贝基因 将所有物种的蛋白文件放到 CGA 文件夹下 命令行提示符orthofinder -t 16 -f CGA&#x2F;我们主要使用 Orthoogroups 查看正交群的基因和使用 Single_Copy_Orthologue_Sequences 里的单拷贝基因构建系统发育树 WorkingDirectory 其中包含运算过程的中间文件，例如 diamond 结果，如果我们想去掉某一物种，在 SpeciesIDs.txt 中将该物种注释掉 命令行提示符0: Aof.pro.fasta1: Ath.pro.fasta2: Atr.pro.fasta3: Cba.pro.fasta4: Cri.pro.fasta5: Csa.pro.fasta6: Csu.pro.fasta7: Kle.pro.fasta8: Mpo.pro.fasta9: Nco.pro.fasta10: Osa.pro.fasta11: Ppa.pro.fasta#12: Pum.pro.fasta13: Smo.pro.fasta14: Tpl.pro.fasta15: Vca.pro.fasta16: Vvi.pro.fasta17: Zma.pro.fasta命令行提示符orthofinder -b WorkingDirectory如果想增加额外的物种进行分析，可以按照如下方式运行 命令行提示符orthofinder -b WorkingDirectory -f new_fasta_directory# 利用单拷贝基因构建系统发育树 Orthofinder 的 Single_Copy_Orthologue_Sequences 下存放着单拷贝同源基因的序列，我们可以利用这些序列构建系统发育树 建树方法可以分为串联法与并联法 不同的是，串联法是将得到的单拷贝同源基因比对后进行了串联，每个物种都得到一个很大的序列，然后进行建树；并联法是将每个单拷贝同源基因集比对后建树，然后再利用 Astral 构建了物种树，这里目前只讲串联法，并联法正在研究 # 串联法建树 命令行提示符vi test.shfor i in *.fado file&#x3D;$&#123;i%.fa*&#125; mafft --maxiterate 1000 --localpair &quot;$&#123;file&#125;.fa&quot; &gt; &quot;$&#123;file&#125;.aln&quot; ## 多序列比对 (也可以添加一步，将蛋白文件转为 cds 文件再进行后续的分析，pal2nal.pl &quot;$&#123;file&#125;.aln&quot; &quot;$&#123;file&#125;.cds&quot; -output fasta &gt; &quot;$&#123;file&#125;.cds.aln) Gblocks &quot;$&#123;file&#125;.aln&quot; -b4&#x3D;5 -b5&#x3D;h -t&#x3D;p -e&#x3D;.gb ## 提取保守序列 seqkit seq &quot;$&#123;file&#125;.aln.gb&quot; -w 0 &gt; &quot;$&#123;file&#125;.new.aln&quot; ## 多行序列并为一行 awk &#39;&#123;if (NR%2&#x3D;&#x3D;1) print substr ($1, 1, 4); else print $0&#125;&#39; &quot;$&#123;file&#125;.new.aln&quot; &gt; &quot;$&#123;file&#125;.final.aln&quot; ## ID 修饰done这一步需要的软件 (mafft,Gblocks,seqkit) 请自行安装 接下来将所有的 aln 文件串联 命令行提示符seqkit concat *.final.aln &gt; all.fa将所有单拷贝基因串联在一起后，进行模型预测，这次使用 modeltestng 进行预测 命令行提示符modeltest-ng -i all.fa -d aa -o modeltest -p 16在 modeltest.out 文件中，我们可以看到我们需要的模型并且可以直接 copy 命令 接下来进行建树 命令行提示符raxmlHPC-PTHREADS-SSE3 -T 32 -f a -x 123 -p 123 -N 10000 -m PROTGAMMAILGF -k -O -o Csu,Vca -n all.tre -s all.fa得到 RAxML_bipartitions.all.tre 文件查看树结构 结果和进化关系是一致的 # 并联法建树 并联法建树使用 Astral，将所有的单拷贝基因树合并为一颗物种树 命令行提示符orthDir&#x3D;~&#x2F;CGApaper&#x2F;protein&#x2F;OrthoFinder&#x2F;Results_May02 #基于 Orthofinder 结果cat $orthDir&#x2F;Orthogroups&#x2F;Orthogroups_SingleCopyOrthologues.txt |while read aa; do cat $orthDir&#x2F;Gene_Trees&#x2F;$aa\\_tree.txt |awk &#39;&#123;print $0&#125;&#39; ;done &gt; SingleCopy.treessed -r &#39;s&#x2F;([(,]&#123;1&#125;[A-Za-z]+)_[^:]+&#x2F;\\1&#x2F;g&#39; SingleCopy.trees &gt; Astral_input.treesjava -jar ~&#x2F;soft&#x2F;ASTRAL-5.7.1&#x2F;astral.5.7.1.jar -i Astral_input.trees -o Astral_output.tree -t 8最后得到 Astral_output.tree，里面包含了不同拓扑结构的可能性，目前先到这一步 命令行提示符(Csu,(Vca,(Kle,(Cba,((Smo,(Cri,(Tpl,((Atr,Nco)&#39;[q1&#x3D;0.56;q2&#x3D;0.24;q3&#x3D;0.21]&#39;:0.3957605767189867,((Ath,(Vvi,Csa)&#39;[q1&#x3D;0.59;q2&#x3D;0.24;q3&#x3D;0.17]&#39;:0.47671301702525964)&#39;[q1&#x3D;0.9;q2&#x3D;0.06;q3&#x3D;0.04]&#39;:1.82319624265162,(Aof,(Zma,Osa)&#39;[q1&#x3D;0.98;q2&#x3D;0.01;q3&#x3D;0.01]&#39;:3.3756896221149395)&#39;[q1&#x3D;0.73;q2&#x3D;0.11;q3&#x3D;0.16]&#39;:0.8957898742947543)&#39;[q1&#x3D;0.59;q2&#x3D;0.13;q3&#x3D;0.28]&#39;:0.4793457920367108)&#39;[q1&#x3D;0.95;q2&#x3D;0.01;q3&#x3D;0.04]&#39;:2.471696418051194)&#39;[q1&#x3D;0.92;q2&#x3D;0.02;q3&#x3D;0.06]&#39;:2.040688555382602)&#39;[q1&#x3D;0.62;q2&#x3D;0.18;q3&#x3D;0.2]&#39;:0.5471348976356571)&#39;[q1&#x3D;0.37;q2&#x3D;0.32;q3&#x3D;0.32]&#39;:0.04487496622879318,(Ppa,Mpo)&#39;[q1&#x3D;0.74;q2&#x3D;0.15;q3&#x3D;0.1]&#39;:0.9286981407683164)&#39;[q1&#x3D;0.86;q2&#x3D;0.07;q3&#x3D;0.07]&#39;:1.5475625087160123)&#39;[q1&#x3D;0.56;q2&#x3D;0.21;q3&#x3D;0.23]&#39;:0.4056697116894409)&#39;[q1&#x3D;0.98;q2&#x3D;0.02;q3&#x3D;0.01]&#39;:3.121909101338843):0.0);# 物种分化时间计算 此次使用 mcmctree 计算物种的分化时间，首先在 timetree 上查询物种的分化时间进行标定，修改树文件，需要注意在标定时间是尽量较早的节点和较晚的节点都进行标定 命令行提示符17 1((Kle,(((Mpo,Ppa),((Cri,(Tpl,(Atr,(Nco,(((Osa,Zma)&#39;&gt;42&lt;52&#39;,Aof)&#39;&gt;104&lt;125&#39;,(Vvi,(Csa,Ath))&#39;&gt;98&lt;117&#39;)&#39;&gt;85&lt;128&#39;)&#39;&gt;173&lt;199&#39;)&#39;&gt;136&gt;247&#39;)&#39;&gt;289&lt;330&#39;)&#39;&gt;392&lt;422&#39;,Smo)&#39;410&lt;468&#39;)&#39;&gt;472&lt;515&#39;,Cba)),(Csu,Vca)&#39;&gt;800&lt;1000&#39;)&#39;&gt;725&lt;1200&#39;;配置文件书写 命令行提示符cp ~&#x2F;soft&#x2F;paml4.9i&#x2F;mcmctree.ctl mcmctree1.ctlvi mcmctree1.ctl seed &#x3D; -1 seqfile &#x3D; all.fa treefile &#x3D; all.tre outfile &#x3D; out ndata &#x3D; 1 ## 必须注意为 1 seqtype &#x3D; 2 * 0: nucleotides; 1:codons; 2:AAs ## 序列格式，蛋白就选择 AA usedata &#x3D; 3 * 0: no data; 1:seq like; 2:use in.BV; 3: out.BV ## 此步骤先设为 3 clock &#x3D; 3 * 1: global clock; 2: independent rates; 3: correlated rates RootAge &#x3D; &lt;1.0 * safe constraint on root age, used if no fossil for root. model &#x3D; 0 * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85 alpha &#x3D; 0 * alpha for gamma rates at sites ncatG &#x3D; 5 * No. categories in discrete gamma cleandata &#x3D; 0 * remove sites with ambiguity data (1:yes, 0:no)? BDparas &#x3D; 1 1 0 * birth, death, sampling kappa_gamma &#x3D; 6 2 * gamma prior for kappa alpha_gamma &#x3D; 1 1 * gamma prior for alpha rgene_gamma &#x3D; 2 2 * gamma prior for overall rates for genes sigma2_gamma &#x3D; 1 10 * gamma prior for sigma^2 (for clock&#x3D;2 or 3) finetune &#x3D; 1: 0.1 0.1 0.1 0.01 .5 * auto (0 or 1) : times, musigma2, rates, mixing, paras, FossilErr print &#x3D; 1 burnin &#x3D; 20000 sampfreq &#x3D; 2 nsample &#x3D; 100000*** Note: Make your window wider (100 columns) before running the program.之后运行 命令行提示符mcmctree mcmctree.ctl运行结果产生一个文件名为 out.BV，我们拷贝到两次分化时间估计的目录里，并用 in.BV 作为新的命名 命令行提示符cp out.BV ..&#x2F;02.Time&#x2F;rep1&#x2F;in.BVcp out.BV ..&#x2F;02.Time&#x2F;rep2&#x2F;in.BV之后在运行两次重复 首先修改配置文件 命令行提示符seed &#x3D; -1 seqfile &#x3D; all.fa treefile &#x3D; all.tre outfile &#x3D; out ndata &#x3D; 1 seqtype &#x3D; 2 * 0: nucleotides; 1:codons; 2:AAs usedata &#x3D; 2 * 0: no data; 1:seq like; 2:use in.BV; 3: out.BV clock &#x3D; 3 * 1: global clock; 2: independent rates; 3: correlated rates RootAge &#x3D; &lt;1.0 * safe constraint on root age, used if no fossil for root. model &#x3D; 0 * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85 alpha &#x3D; 0 * alpha for gamma rates at sites ncatG &#x3D; 5 * No. categories in discrete gamma cleandata &#x3D; 0 * remove sites with ambiguity data (1:yes, 0:no)? BDparas &#x3D; 1 1 0 * birth, death, sampling kappa_gamma &#x3D; 6 2 * gamma prior for kappa alpha_gamma &#x3D; 1 1 * gamma prior for alpha rgene_gamma &#x3D; 2 2 * gamma prior for overall rates for genes sigma2_gamma &#x3D; 1 10 * gamma prior for sigma^2 (for clock&#x3D;2 or 3) finetune &#x3D; 1: 0.1 0.1 0.1 0.01 .5 * auto (0 or 1) : times, musigma2, rates, mixing, paras, FossilErr print &#x3D; 1 burnin &#x3D; 800000 sampfreq &#x3D; 40 nsample &#x3D; 6500000*** Note: Make your window wider (100 columns) before running the program.最后我们会得到如下文件 命令行提示符all.fa all.phy all.tre FigTree.tre in.BV mcmctree.ctl mcmc.txt out SeedUsed检查两次结果的 FigTree.tre 文件，如果相差不大就可以使用 之后可以进行基因家族的收缩与扩张分析了，这部分之后在写","tags":"bioinformatics comparative_genomics"},{"title":"RNAseq教程(5)","url":"/2021/01/12/2021-01-12-RNAseq(21)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 5. De novo RNA-Seq Assembly and Analysis Using Trinity 任务 Generating a Trinity de novo RNA-Seq assembly Evaluating the quality of the assembly Quantifying transcript expression levels Identifying differentially expressed (DE) transcripts Functionally annotating transcripts using Trinotate and predicting coding regions using TransDecoder Examining functional enrichments for DE transcripts using GOseq Interactively Exploring annotations and expression data via TrinotateWeb # 数据内容 在本课程中，将使用本文的数据：通过 RNA-Seq 定义光滑念珠菌的转录组特征 Linde et al. Nucleic Acids Res. 2015 WT 以及 GSNO 的数据。 vi SRR_Acc_List.txtSRR1582646SRR1582647SRR1582648SRR1582649SRR1582650SRR1582651prefetch --option-file Seqs&#x2F;SRR_ACC_Lists.txt .&#x2F;vi sh.shcat SRR_Acc_List.txt |while read idofastq-dump --defline-seq &#39;@$sn[_$rn]&#x2F;$ri&#39; --split-files -A $i $&#123;i&#125;&#x2F;$&#123;i&#125;.sradonesh sh.sh下载结束后给所有文件重命名 GSNO_SRR1582646_1.fastqGSNO_SRR1582646_2.fastqGSNO_SRR1582647_1.fastqGSNO_SRR1582647_2.fastqGSNO_SRR1582648_1.fastqGSNO_SRR1582648_2.fastqwt_SRR1582649_1.fastqwt_SRR1582649_2.fastqwt_SRR1582650_1.fastqwt_SRR1582650_2.fastqwt_SRR1582651_1.fastqwt_SRR1582651_2.fastq","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(4.5)","url":"/2021/01/09/2021-01-09-RNAseq(20)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 4.5 Transcript Assembly Visualization (Splicing Visualization) # Visualizing Results at the Command Line 从 “de_novo” 模式查看合并后的 GTF 文件。请记住，这个合并的 GTF 文件结合了 UHR 和 HBR (每个单独的 GTF 也在前面生成)。 cd denovohead stringtie_merged.gtf有关该文件格式的细节，请查阅以下链接 https://ccb.jhu.edu/software/stringtie/gff.shtml#gffcompare http://cole-trapnell-lab.github.io/cufflinks/cuffmerge/index.html http://cole-trapnell-lab.github.io/cufflinks/cuffcompare/index.html#transfrag-class-codes 在 “de_novo” 结果中，有多少基因至少有一个由 StringTie 组装的转录本？ cat stringtie_merged.gtf | perl -ne &#39;if ($_ &#x3D;~ &#x2F;gene_id\\s+\\&quot;(\\S+)\\&quot;\\;&#x2F;)&#123;print &quot;$1\\n&quot;&#125;&#39; | sort | uniq | wc -l565有多少基因至少组装了一个潜在的新转录本？ head gffcompare.stringtie_merged.gtf.tmapgrep &quot;j&quot; gffcompare.stringtie_merged.gtf.tmapgrep &quot;j&quot; gffcompare.stringtie_merged.gtf.tmap | cut -f 1 | sort | uniq | wc -l174显示具有最高阅读支持度的基因间区域 (候选新转录区域) 的转录本 cd denovogrep -w &quot;u&quot; gffcompare.stringtie_merged.gtf.tmap | sort -n -k 10 | column -t- - u MSTRG.481 MSTRG.481.1 3 0.000000 0.000000 0.000000 260 MSTRG.481.1 -- - u MSTRG.482 MSTRG.482.1 2 0.000000 0.000000 0.000000 267 MSTRG.482.1 -- - u MSTRG.54 MSTRG.54.1 2 0.000000 0.000000 0.000000 279 MSTRG.54.1 -- - u MSTRG.434 MSTRG.434.1 3 0.000000 0.000000 0.000000 281 MSTRG.434.1 -- - u MSTRG.484 MSTRG.484.1 2 0.000000 0.000000 0.000000 319 MSTRG.484.1 -- - u MSTRG.3 MSTRG.3.1 2 0.000000 0.000000 0.000000 320 MSTRG.3.1 -- - u MSTRG.200 MSTRG.200.1 2 0.000000 0.000000 0.000000 344 MSTRG.200.1 -- - u MSTRG.391 MSTRG.391.1 2 0.000000 0.000000 0.000000 346 MSTRG.391.1 -- - u MSTRG.2 MSTRG.2.1 2 0.000000 0.000000 0.000000 400 MSTRG.2.1 -- - u MSTRG.94 MSTRG.94.1 3 0.000000 0.000000 0.000000 424 MSTRG.94.1 -- - u MSTRG.410 MSTRG.410.1 2 0.000000 0.000000 0.000000 939 MSTRG.410.1 -# 使用 RegTools 来注释所有的可变剪切 RegTools 用于帮助描述单个外显子剪接事件，并帮助识别对基因表达或剪接模式有直接影响的新剪接事件。更多细节请参考 RegTools 手册。 使用 RegTools 的基本功能来提取可变剪切。每个 bam 的 bed 文件，它总结了 RNA-seq 数据中所表示的所有不同的外显子 - 外显子剪接事件。我们还将使用 RegTools 对这些连接进行注释，以参考我们的 GTF 转录组文件: cd alignregtools junctions extract -s 0 HBR.bam -o HBR.junctions.bedhead HBR.junctions.bedregtools junctions annotate HBR.junctions.bed ..&#x2F;chr22_with_ERCC92.fa ..&#x2F;chr22_with_ERCC92.gtf &gt; HBR.junctions.anno.bedhead HBR.junctions.anno.bedregtools junctions extract -s 0 UHR.bam -o UHR.junctions.bedhead UHR.junctions.bedregtools junctions annotate UHR.junctions.bed ..&#x2F;chr22_with_ERCC92.fa ..&#x2F;chr22_with_ERCC92.gtf &gt; UHR.junctions.anno.bedhead UHR.junctions.anno.bed现在从样本中找出任何可能涉及新外显子跳跃、受体位点使用或供体位点使用的连接 (相对于参考转录组 GTF)。 grep -P -w &quot;NDA|A|D&quot; HBR.junctions.anno.bed | perl -ne &#39;chomp; @l&#x3D;split(&quot;\\t&quot;,$_); if ($l[4] &gt; 3)&#123;print &quot;$_\\n&quot;&#125;&#39;grep -P -w &quot;NDA|A|D&quot; UHR.junctions.anno.bed | perl -ne &#39;chomp; @l&#x3D;split(&quot;\\t&quot;,$_); if ($l[4] &gt; 3)&#123;print &quot;$_\\n&quot;&#125;&#39;# 转换成 GTF 文件查看 为了更容易比较仅 ref-only, ref-guided, de novo 的结果的输出，我们现在将生成合并后的 GTF 文件的过滤版本，我们将删除转录本，除非有证据表明它们的表达。 wget https:&#x2F;&#x2F;github.com&#x2F;griffithlab&#x2F;rnaseq_tutorial&#x2F;blob&#x2F;master&#x2F;scripts&#x2F;stringtie_filter_gtf.plperl stringtie_filter_gtf.pl --expression_metric&#x3D;FPKM --result_dirs&#x3D;&#39;HBR_Rep1,HBR_Rep2,HBR_Rep3,UHR_Rep1,UHR_Rep2,UHR_Rep3&#39; --input_gtf_file&#x3D;&#39;..&#x2F;chr22_with_ERCC92.gtf&#39; --filtered_gtf_file&#x3D;&#39;chr22_with_ERCC92.filtered.gtf&#39; --exp_cutoff&#x3D;0 --min_sample_count&#x3D;2","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(4.4)","url":"/2021/01/07/2021-01-07-RNAseq(19)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 4.4 Differential (Expression) Splicing Use Ballgown and Stringtie to compare the UHR and HBR conditions against reference guided and de novo transcript assemblies. 参考 Stringtie 手册获得更详细的解释:https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual Ballgown 的 github 页面也有 Ballgown 的说明文档:https://github.com/alyssafrazee/ballgown 计算已知 / 新 (参考引导模式) 转录本的 UHR 和 HBR 表达估计数 使用参考引导的合并 GTF 和 Ballgown 的输出表重新运行 Stringtie。将结果存储在一个新目录中，这样我们仍然可以检查在没有合并 GTF 的情况下生成的结果。 r ref_guided_mergedcd ref_guided_mergedstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep1&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep1.bamstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep2&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep2.bamstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep3&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep3.bamstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep1&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep1.bamstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep2&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep2.bamstringtie -p 8 -G ..&#x2F;ref_guided&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep3&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep3.bam运行 Ballgown 使用参考指导，合并转录 mkdir -p ref_guided_merged&#x2F;cd ref_guided_merged&#x2F;printf &quot;\\&quot;ids\\&quot;,\\&quot;type\\&quot;,\\&quot;path\\&quot;\\n\\&quot;UHR_Rep1\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;UHR_Rep1\\&quot;\\n\\&quot;UHR_Rep2\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;UHR_Rep2\\&quot;\\n\\&quot;UHR_Rep3\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;UHR_Rep3\\&quot;\\n\\&quot;HBR_Rep1\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;HBR_Rep1\\&quot;\\n\\&quot;HBR_Rep2\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;HBR_Rep2\\&quot;\\n\\&quot;HBR_Rep3\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;ref_guided_merged&#x2F;HBR_Rep3\\&quot;\\n&quot; &gt; UHR_vs_HBR.csv请参阅 Differential Expression 关于运行 Ballgown 确定 DE 基因 / 转录单的详细信息。 计算已知 / 新的 (从头开始模式) 转录本的 UHR 和 HBR 表达估计: 使用新生合并的 GTF 重新运行 Stringtie，并为 Ballgown 输出表。将结果存储在一个新目录中，这样我们仍然可以检查在没有合并 GTF 的情况下生成的结果。 mkdir de_novo_mergedcd de_novo_mergedstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep1&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep1.bamstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep2&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep2.bamstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o HBR_Rep3&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;HBR_Rep3.bamstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep1&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep1.bamstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep2&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep2.bamstringtie -p 8 -G ..&#x2F;de_novo&#x2F;stringtie_merged.gtf -e -B -o UHR_Rep3&#x2F;transcripts.gtf $RNA_ALIGN_DIR&#x2F;UHR_Rep3.bam运行 Ballgown，使用重新合并的转录本 printf &quot;\\&quot;ids\\&quot;,\\&quot;type\\&quot;,\\&quot;path\\&quot;\\n\\&quot;UHR_Rep1\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;UHR_Rep1\\&quot;\\n\\&quot;UHR_Rep2\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;UHR_Rep2\\&quot;\\n\\&quot;UHR_Rep3\\&quot;,\\&quot;UHR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;UHR_Rep3\\&quot;\\n\\&quot;HBR_Rep1\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;HBR_Rep1\\&quot;\\n\\&quot;HBR_Rep2\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;HBR_Rep2\\&quot;\\n\\&quot;HBR_Rep3\\&quot;,\\&quot;HBR\\&quot;,\\&quot;$RNA_HOME&#x2F;expression&#x2F;stringtie&#x2F;de_novo_merged&#x2F;HBR_Rep3\\&quot;\\n&quot; &gt; UHR_vs_HBR.csv","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(4.3)","url":"/2021/01/05/2021-01-05-RNAseq(18)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 4.3 Stringle Merge 使用 Stringtie 将所有库中的预测转录本合并成一个统一的转录组。参考 Stringtie 手册获得更详细的解释：https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual Options specified below: &quot;assembly_GTF_list.txt&quot; is a text file &quot;manifest&quot; with a list (one per line) of GTF files that you would like to merge together into a single GTF file. '-p 8' tells stringtie to use eight CPUs '-o' tells stringtie to write output to a particular file or directory '-G' tells stringtie where to find reference gene annotations. It will use these annotations to gracefully merge novel isoforms (for de novo runs) and known isoforms and maximize overall assembly quality. 合并所有 6 个 Stringtie 结果： ls -1 *Rep*&#x2F;transcripts.gtf &gt; assembly_GTF_list.txtcat assembly_GTF_list.txtstringtie --merge -p 8 -o stringtie_merged.gtf -G $RNA_REF_GTF assembly_GTF_list.txtstringtie --merge -p 8 -o stringtie_merged.gtf -G ..&#x2F;chr22_with_ERCC92.gtf assembly_GTF_list.txt结果的转录本是什么样子的？ awk &#39;&#123;if($3&#x3D;&#x3D;&quot;transcript&quot;) print&#125;&#39; stringtie_merged.gtf | cut -f 1,4,9 | less将参考引导的转录本与已知的注释进行比较。这使我们能够评估组装 RNA-seq 数据的转录预测的质量。更多细节，请参考 Stringtie GFF 和 Cuffcompare 手册。 gffcompare -r ..&#x2F;chr22_with_ERCC92.gtf -o gffcompare stringtie_merged.gtfcat gffcompare.stats将合并的注释与已知的注释进行比较后，它是什么样子的？与一般的 gtf 有什么不同？ awk &#39;&#123;if($3&#x3D;&#x3D;&quot;transcript&quot;) print&#125;&#39; gffcompare.annotated.gtf | cut -f 1,4,9 | less对于 de novo 模式: ls -1 *Rep*&#x2F;transcripts.gtf &gt; assembly_GTF_list.txtcat assembly_GTF_list.txtstringtie --merge -p 8 -o stringtie_merged.gtf assembly_GTF_list.txt将重新合并的转录本与已知的注释进行比较: gffcompare -r ..&#x2F;chr22_with_ERCC92.gtf -o gffcompare stringtie_merged.gtfcat gffcompare.stats","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(4.2)","url":"/2021/01/02/2021-01-02-RNAseq(17)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 4.2 Stringtie De Novo Mode 在上一个模块中，使用 Stringtie 的 '-G' 和 '-e' 选项在 'reference only' 模式下运行 Stringtie 本次教程将运行 Stringle 的 de novo 模式 额外选项如下 '-p 8' tells Stringtie to use eight CPUs '-l' name prefix for output transcripts (default: STRG) '-o' output path/file name for the assembled transcripts GTF (default: stdout) mkdir denovostringtie -p 8 -l HBR_Rep1 -o denovo&#x2F;HBR_Rep1&#x2F;transcripts.gtf HBR_Rep1.bam后续处理相同","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(4.1)","url":"/2020/12/31/2020-12-31-RNAseq(16)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 4.1 Reference Guided Transcript Assembly 利用 Stringle 和 Ballgown 发现从头组装的转录本和差异表达 在上一个模块中，使用 Stringtie 的 '-G' 和 '-e' 选项在 'reference only' 模式下运行 Stringtie。 在本模块中，我们将以另外两种模式运行 Stringtie:“reference guided” 模式及 (2)“de novo” 模式。在已知转录本的帮助下，Stringtie 可以预测每个文库中存在的转录本。然后，Stringtie 将为每个由数据组装的转录本分配任意的转录本 id，并估计这些转录本的表达。这种方法的一个复杂之处在于，在每个库中，都可能预测出一组不同的转录本。可能有很多相似之处，但是在每个库的输出文件中，转录的数量和它们的确切结构是不同的。因此，在跨库进行比较之前，需要确定哪些转录本在跨库之间相互对应。Stringtie 提供了一个 merge 命令来组合来自不同库的预测文本 GTF 文件。 一旦有了一个合并的 GTF 文件，就可以用它来运行 Stringtie，而不是我们以前使用的已知的 transcripts GTF 文件。合并的 GTF 被用来重新计算表达估计在准备运行 Ballgown 使用合并新转录本。 To run Stringtie in 'reference guided' mode: use the '-G' option WITHOUT '-e' To run Stringtie in 'de novo' mode do NOT specify either of the '-G' OR '-e' options. 参考 Stringtie 手册获得更详细的说明:https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual # Running Stringtie in Reference Guided Mode 使用我们在前面模块中生成的对齐，现在只使用 '-G' 选项在 reference guided 模式下运行 Stringtie。 额外选项如下 '-p 8' tells Stringtie to use eight CPUs '-G ' reference annotation to use for guiding the assembly process (GTF/GFF3) '-l' name prefix for output transcripts (default: STRG) '-o' output path/file name for the assembled transcripts GTF (default: stdout) 首先，创建一个输出目录，然后以 reference guided 模式运行 stringtie。 mkdir ref_guidedstringtie -p 1 -G ..&#x2F;chr22_with_ERCC92.gtf -l HBR_Rep1 -o ref_guided&#x2F;HBR_Rep1&#x2F;transcripts.gtf HBR_Rep1.bam所有做相同处理","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(3.4)","url":"/2020/12/29/2020-12-29-RNAseq(15)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 3.4 Alignment Free Expression Estimation (Kallisto) # 获取转录本的 fasta 序列 请注意，我们已经在 RNA-seq 教程的前面有了参考基因组序列的 fasta 序列。然而，Kallisto 直接作用于目标 cDNA / 转录本序列。记住，我们有 22 号染色体上基因的转录模型。这些转录模型是以 GTF 格式从 Ensembl 下载的。GTF 包含组成每个转录本的外显子的坐标描述，但不包含转录本序列本身。所以目前我们没有 Kallisto 需要的转录序列。我们有很多地方可以得到这些转录序列。 为了将 Kallisto 结果与 StringTie 的表达式结果进行比较，我们将创建一个定制的 Fasta 文件，该文件对应于用于 StringTie 分析的文本。我们如何以 Fasta 格式获得这些转录序列？ 我们可以下载完整的人类 fasta 转录本数据库并只提取出 22 号染色体上的基因。或者我们可以使用来自 tophat 的名为 gtf_to_fasta 的工具从我们的 GTF 文件中生成 fasta 序列。这种方法很方便，因为它还包括控制中的 ERCC 峰值序列，允许我们为这些特征生成 Kallisto 丰度估计值。 gtf_to_fasta chr22_with_ERCC92.gtf chr22_with_ERCC92.fa chr22_ERCC92_transcripts.fa使用 less 查看文件 chr22_ERCC92_transcripts.fa。请注意，该文件有混乱的文字记录名称。使用下面的 hairball perl 一行代码来整理每个 fasta 序列的标题行 cat chr22_ERCC92_transcripts.fa | perl -ne &#39;if ($_ &#x3D;~&#x2F;^\\&gt;\\d+\\s+\\w+\\s+(ERCC\\S+)[\\+\\-]&#x2F;)&#123;print &quot;&gt;$1\\n&quot;&#125; elsif ($_ &#x3D;~ &#x2F;\\d+\\s+(ENST\\d+)&#x2F;)&#123;print &quot;&gt;$1\\n&quot;&#125; else &#123;print $_&#125;&#39; &gt; chr22_ERCC92_transcripts.clean.fawc -l chr22_ERCC92_transcripts*.fa 126025 chr22_ERCC92_transcripts.clean.fa 126025 chr22_ERCC92_transcripts.fa 252050 总用量使用 less chr22_ERCC92_transcripts.clean.fa 查看生成的 “clean” 文件。使用 tail 查看文件末尾 chr22_ERCC92_transcripts.clean.fa。请注意，我们对 22 号染色体上的每个集合转录本都有一个 fasta 记录，我们对每个 ERCC spike-in 序列都有一个额外的 fasta 记录。 cat chr22_ERCC92_transcripts.clean.fa | grep &quot;&gt;&quot; | perl -ne &#39;$_ &#x3D;~ s&#x2F;\\&gt;&#x2F;&#x2F;; print $_&#39; | sort | uniq &gt; transcript_id_list.txt# Build a Kallisto transcriptome index 请记住，Kallisto 并不进行比对或使用参考基因组序列。相反，它执行伪比对以确定读段与目标 (本例中为转录序列) 的兼容性。然而，与 Tophat 或 STAR 等对齐算法类似，Kallisto 需要一个索引来高效、快速地评估这种兼容性。 kallisto index --index&#x3D;chr22_ERCC92_transcripts_kallisto_index ..&#x2F;chr22_ERCC92_transcripts.clean.fa# Generate abundance estimates for all samples using Kallisto 正如使用 StringTie 和 HT-Seq 所做的那样，使用 Kallisto 为每个演示样本生成转录本丰度。 kallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;UHR_Rep1_ERCC-Mix1 --threads&#x3D;4 --plaintext UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gzkallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;UHR_Rep2_ERCC-Mix1 --threads&#x3D;4 --plaintext UHR_Rep2_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz UHR_Rep2_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gzkallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;UHR_Rep3_ERCC-Mix1 --threads&#x3D;4 --plaintext UHR_Rep3_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz UHR_Rep3_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gzkallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;HBR_Rep1_ERCC-Mix2 --threads&#x3D;4 --plaintext HBR_Rep1_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz HBR_Rep1_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gzkallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;HBR_Rep2_ERCC-Mix2 --threads&#x3D;4 --plaintext HBR_Rep2_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz HBR_Rep2_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gzkallisto quant --index&#x3D;chr22_ERCC92_transcripts_kallisto_index --output-dir&#x3D;HBR_Rep3_ERCC-Mix2 --threads&#x3D;4 --plaintext HBR_Rep3_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz HBR_Rep3_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gz创建一个 TSV 文件，其中包含所有六个样本的 TPM 丰度估计值。 paste *&#x2F;abundance.tsv | cut -f 1,2,5,10,15,20,25,30 &gt; transcript_tpms_all_samples.tsvls -1 *&#x2F;abundance.tsv | perl -ne &#39;chomp $_; if ($_ &#x3D;~ &#x2F;(\\S+)\\&#x2F;abundance\\.tsv&#x2F;)&#123;print &quot;\\t$1&quot;&#125;&#39; | perl -ne &#39;print &quot;target_id\\tlength$_\\n&quot;&#39; &gt; header.tsvcat header.tsv transcript_tpms_all_samples.tsv | grep -v &quot;tpm&quot; &gt; transcript_tpms_all_samples.tsv2mv transcript_tpms_all_samples.tsv2 transcript_tpms_all_samples.tsvrm -f header.tsvhead transcript_tpms_all_samples.tsvtail transcript_tpms_all_samples.tsv","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(3.3)","url":"/2020/12/26/2020-12-26-RNAseq(14)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 3.3 DE Visualization 在正确的目录（之前的 UHR_vs_HBR.csv），然后启动 R: # Load libraries needed for this analysislibrary(ballgown)library(genefilter)library(dplyr)library(devtools)# Define a path for the output PDF to be writtenoutfile&#x3D;&quot;~&#x2F;workspace&#x2F;rnaseq&#x2F;de&#x2F;ballgown&#x2F;ref_only&#x2F;Tutorial_Part2_ballgown_output.pdf&quot;# Load phenotype datapheno_data &#x3D; read.csv(&quot;UHR_vs_HBR.csv&quot;)# Display the phenotype datapheno_data# Load the ballgown object from fileload(&#39;bg.rda&#39;)# The load command, loads an R object from a file into memory in our R session.# You can use ls() to view the names of variables that have been loadedls()# Print a summary of the ballgown objectbg# Open a PDF file where we will save some plots. We will save all figures and then view the PDF at the endpdf(file&#x3D;outfile)# Extract FPKM values from the &#39;bg&#39; objectfpkm &#x3D; texpr(bg,meas&#x3D;&quot;FPKM&quot;)# View the last several rows of the FPKM tabletail(fpkm)# Transform the FPKM values by adding 1 and convert to a log2 scalefpkm &#x3D; log2(fpkm+1)# View the last several rows of the transformed FPKM tabletail(fpkm)# Create boxplots to display summary statistics for the FPKM values for each sampleboxplot(fpkm,col&#x3D;as.numeric(pheno_data$type)+1,las&#x3D;2,ylab&#x3D;&#39;log2(FPKM+1)&#39;)# Display the transcript ID for a single row of databallgown::transcriptNames(bg)[2763]# Display the gene name for a single row of databallgown::geneNames(bg)[2763]# Create a BoxPlot comparing the expression of a single gene for all replicates of both conditionsplot(fpkm[2763,] ~ pheno_data$type, border&#x3D;c(2,3), main&#x3D;paste(ballgown::geneNames(bg)[2763],&#39; : &#39;, ballgown::transcriptNames(bg)[2763]),pch&#x3D;19, xlab&#x3D;&quot;Type&quot;, ylab&#x3D;&#39;log2(FPKM+1)&#39;)# Add the FPKM values for each sample onto the plotpoints(fpkm[2763,] ~ jitter(as.numeric(pheno_data$type)), col&#x3D;as.numeric(pheno_data$type)+1, pch&#x3D;16)# Create a plot of transcript structures observed in each replicate and color transcripts by expression levelplotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample HBR_Rep1&#39;), sample&#x3D;c(&#39;HBR_Rep1&#39;))plotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample HBR_Rep2&#39;), sample&#x3D;c(&#39;HBR_Rep2&#39;))plotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample HBR_Rep3&#39;), sample&#x3D;c(&#39;HBR_Rep3&#39;))plotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample UHR_Rep1&#39;), sample&#x3D;c(&#39;UHR_Rep1&#39;))plotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample UHR_Rep2&#39;), sample&#x3D;c(&#39;UHR_Rep2&#39;))plotTranscripts(ballgown::geneIDs(bg)[2763], bg, main&#x3D;c(&#39;Gene in sample UHR_Rep3&#39;), sample&#x3D;c(&#39;UHR_Rep3&#39;))#plotMeans(&#39;TST&#39;,bg,groupvar&#x3D;&quot;type&quot;,legend&#x3D;FALSE)# Close the PDF device where we have been saving our plotsdev.off()# Exit the R sessionquit(save&#x3D;&quot;no&quot;)查看一下输出的 pdf 文件 # 额外分析 运行 R 脚本 #Tutorial_Part3_Supplementary_R.R#Malachi Griffith, mgriffit[AT]wustl.edu#Obi Griffith, obigriffith[AT]wustl.edu#Jason Walker, jason.walker[AT]wustl.edu#McDonnell Genome Institute, Washington University School of Medicine#R tutorial for Informatics for RNA-sequence Analysis workshops#Starting from the output of the RNA-seq Tutorial Part 1.#Load librarieslibrary(ggplot2)library(gplots)library(GenomicRanges)library(ballgown)#If X11 not available, open a pdf device for output of all plotspdf(file&#x3D;&quot;Tutorial_Part3_Supplementary_R_output.pdf&quot;)#### Import the gene expression data from the HISAT2&#x2F;StringTie&#x2F;Ballgown tutorial#Set working directory where results files existworking_dir &#x3D; &quot;~&#x2F;workspace&#x2F;rnaseq&#x2F;de&#x2F;ballgown&#x2F;ref_only&quot;setwd(working_dir)# List the current contents of this directorydir()#Import expression and differential expression results from the HISAT2&#x2F;StringTie&#x2F;Ballgown pipelineload(&#39;bg.rda&#39;)# View a summary of the ballgown objectbg# Load gene names for lookup later in the tutorialbg_table &#x3D; texpr(bg, &#39;all&#39;)bg_gene_names &#x3D; unique(bg_table[, 9:10])# Pull the gene_expression data frame from the ballgown objectgene_expression &#x3D; as.data.frame(gexpr(bg))#### Working with &#39;dataframes&#39;#View the first five rows of data (all columns) in one of the dataframes createdhead(gene_expression)#View the column namescolnames(gene_expression)#View the row namesrow.names(gene_expression)#Determine the dimensions of the dataframe. &#39;dim()&#39; will return the number of rows and columnsdim(gene_expression)#Get the first 3 rows of data and a selection of columnsgene_expression[1:3,c(1:3,6)]#Do the same thing, but using the column names instead of numbersgene_expression[1:3, c(&quot;FPKM.UHR_Rep1&quot;,&quot;FPKM.UHR_Rep2&quot;,&quot;FPKM.UHR_Rep3&quot;,&quot;FPKM.HBR_Rep3&quot;)]#Assign colors to each. You can specify color by RGB, Hex code, or name#To get a list of color names:colours()data_colors&#x3D;c(&quot;tomato1&quot;,&quot;tomato2&quot;,&quot;tomato3&quot;,&quot;royalblue1&quot;,&quot;royalblue2&quot;,&quot;royalblue3&quot;)#View expression values for the transcripts of a particular gene symbol of chromosome 22. e.g. &#39;TST&#39;#First determine the rows in the data.frame that match &#39;TST&#39;, aka. ENSG00000128311, then display only those rows of the data.framei &#x3D; row.names(gene_expression) &#x3D;&#x3D; &quot;ENSG00000128311&quot;gene_expression[i,]#What if we want to view values for a list of genes of interest all at once?#genes_of_interest &#x3D; c(&quot;TST&quot;, &quot;MMP11&quot;, &quot;LGALS2&quot;, &quot;ISX&quot;)genes_of_interest &#x3D; c(&quot;ENSG00000128311&quot;,&quot;ENSG00000099953&quot;,&quot;ENSG00000100079&quot;,&quot;ENSG00000175329&quot;)i &#x3D; which(row.names(gene_expression) %in% genes_of_interest)gene_expression[i,]# Load the transcript to gene index from the ballgown objecttranscript_gene_table &#x3D; indexes(bg)$t2ghead(transcript_gene_table)#Each row of data represents a transcript. Many of these transcripts represent the same gene. Determine the numbers of transcripts and unique genes length(row.names(transcript_gene_table)) #Transcript countlength(unique(transcript_gene_table[,&quot;g_id&quot;])) #Unique Gene count#### Plot #1 - the number of transcripts per gene. #Many genes will have only 1 transcript, some genes will have several transcripts#Use the &#39;table()&#39; command to count the number of times each gene symbol occurs (i.e. the # of transcripts that have each gene symbol)#Then use the &#39;hist&#39; command to create a histogram of these counts#How many genes have 1 transcript? More than one transcript? What is the maximum number of transcripts for a single gene?counts&#x3D;table(transcript_gene_table[,&quot;g_id&quot;])c_one &#x3D; length(which(counts &#x3D;&#x3D; 1))c_more_than_one &#x3D; length(which(counts &gt; 1))c_max &#x3D; max(counts)hist(counts, breaks&#x3D;50, col&#x3D;&quot;bisque4&quot;, xlab&#x3D;&quot;Transcripts per gene&quot;, main&#x3D;&quot;Distribution of transcript count per gene&quot;)legend_text &#x3D; c(paste(&quot;Genes with one transcript &#x3D;&quot;, c_one), paste(&quot;Genes with more than one transcript &#x3D;&quot;, c_more_than_one), paste(&quot;Max transcripts for single gene &#x3D; &quot;, c_max))legend(&quot;topright&quot;, legend_text, lty&#x3D;NULL)#### Plot #2 - the distribution of transcript sizes as a histogram#In this analysis we supplied StringTie with transcript models so the lengths will be those of known transcripts#However, if we had used a de novo transcript discovery mode, this step would give us some idea of how well transcripts were being assembled#If we had a low coverage library, or other problems, we might get short &#39;transcripts&#39; that are actually only pieces of real transcriptsfull_table &lt;- texpr(bg , &#39;all&#39;)hist(full_table$length, breaks&#x3D;50, xlab&#x3D;&quot;Transcript length (bp)&quot;, main&#x3D;&quot;Distribution of transcript lengths&quot;, col&#x3D;&quot;steelblue&quot;)#### Summarize FPKM values for all 6 replicates#What are the minimum and maximum FPKM values for a particular library?min(gene_expression[,&quot;FPKM.UHR_Rep1&quot;])max(gene_expression[,&quot;FPKM.UHR_Rep1&quot;])#Set the minimum non-zero FPKM values for use later.#Do this by grabbing a copy of all data values, coverting 0&#39;s to NA, and calculating the minimum or all non NA values#zz &#x3D; fpkm_matrix[,data_columns]#zz[zz&#x3D;&#x3D;0] &#x3D; NA#min_nonzero &#x3D; min(zz, na.rm&#x3D;TRUE)#min_nonzero#Alternatively just set min value to 1min_nonzero&#x3D;1# Set the columns for finding FPKM and create shorter names for figuresdata_columns&#x3D;c(1:6)short_names&#x3D;c(&quot;UHR_1&quot;,&quot;UHR_2&quot;,&quot;UHR_3&quot;,&quot;HBR_1&quot;,&quot;HBR_2&quot;,&quot;HBR_3&quot;)#### Plot #3 - View the range of values and general distribution of FPKM values for all 4 libraries#Create boxplots for this purpose#Display on a log2 scale and add the minimum non-zero value to avoid log2(0)boxplot(log2(gene_expression[,data_columns]+min_nonzero), col&#x3D;data_colors, names&#x3D;short_names, las&#x3D;2, ylab&#x3D;&quot;log2(FPKM)&quot;, main&#x3D;&quot;Distribution of FPKMs for all 6 libraries&quot;)#Note that the bold horizontal line on each boxplot is the median#### Plot #4 - plot a pair of replicates to assess reproducibility of technical replicates#Tranform the data by converting to log2 scale after adding an arbitrary small value to avoid log2(0)x &#x3D; gene_expression[,&quot;FPKM.UHR_Rep1&quot;]y &#x3D; gene_expression[,&quot;FPKM.UHR_Rep2&quot;]plot(x&#x3D;log2(x+min_nonzero), y&#x3D;log2(y+min_nonzero), pch&#x3D;16, col&#x3D;&quot;blue&quot;, cex&#x3D;0.25, xlab&#x3D;&quot;FPKM (UHR, Replicate 1)&quot;, ylab&#x3D;&quot;FPKM (UHR, Replicate 2)&quot;, main&#x3D;&quot;Comparison of expression values for a pair of replicates&quot;)#Add a straight line of slope 1, and intercept 0abline(a&#x3D;0,b&#x3D;1)#Calculate the correlation coefficient and display in a legendrs&#x3D;cor(x,y)^2legend(&quot;topleft&quot;, paste(&quot;R squared &#x3D; &quot;, round(rs, digits&#x3D;3), sep&#x3D;&quot;&quot;), lwd&#x3D;1, col&#x3D;&quot;black&quot;)#### Plot #5 - Scatter plots with a large number of data points can be misleading ... regenerate this figure as a density scatter plotcolors &#x3D; colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;, &quot;#007FFF&quot;, &quot;cyan&quot;,&quot;#7FFF7F&quot;, &quot;yellow&quot;, &quot;#FF7F00&quot;, &quot;red&quot;, &quot;#7F0000&quot;))smoothScatter(x&#x3D;log2(x+min_nonzero), y&#x3D;log2(y+min_nonzero), xlab&#x3D;&quot;FPKM (UHR, Replicate 1)&quot;, ylab&#x3D;&quot;FPKM (UHR, Replicate 2)&quot;, main&#x3D;&quot;Comparison of expression values for a pair of replicates&quot;, colramp&#x3D;colors, nbin&#x3D;200)#### Plot all sets of replicates on a single plot#Create an function that generates an R plot. This function will take as input the two libraries to be compared and a plot name and colorplotCor &#x3D; function(lib1, lib2, name, color)&#123; x&#x3D;gene_expression[,lib1] y&#x3D;gene_expression[,lib2] zero_count &#x3D; length(which(x&#x3D;&#x3D;0)) + length(which(y&#x3D;&#x3D;0)) plot(x&#x3D;log2(x+min_nonzero), y&#x3D;log2(y+min_nonzero), pch&#x3D;16, col&#x3D;color, cex&#x3D;0.25, xlab&#x3D;lib1, ylab&#x3D;lib2, main&#x3D;name) abline(a&#x3D;0,b&#x3D;1) rs&#x3D;cor(x,y, method&#x3D;&quot;pearson&quot;)^2 legend_text &#x3D; c(paste(&quot;R squared &#x3D; &quot;, round(rs, digits&#x3D;3), sep&#x3D;&quot;&quot;), paste(&quot;Zero count &#x3D; &quot;, zero_count, sep&#x3D;&quot;&quot;)) legend(&quot;topleft&quot;, legend_text, lwd&#x3D;c(1,NA), col&#x3D;&quot;black&quot;, bg&#x3D;&quot;white&quot;, cex&#x3D;0.8)&#125;#Open a plotting page with room for two plots on one pagepar(mfrow&#x3D;c(1,2))#Plot #6 - Now make a call to our custom function created above, once for each library comparisonplotCor(&quot;FPKM.UHR_Rep1&quot;, &quot;FPKM.HBR_Rep1&quot;, &quot;UHR_1 vs HBR_1&quot;, &quot;tomato2&quot;)plotCor(&quot;FPKM.UHR_Rep2&quot;, &quot;FPKM.HBR_Rep2&quot;, &quot;UHR_2 vs HBR_2&quot;, &quot;royalblue2&quot;)##### One problem with these plots is that there are so many data points on top of each other, that information is being lost#Regenerate these plots using a density scatter plotplotCor2 &#x3D; function(lib1, lib2, name, color)&#123; x&#x3D;gene_expression[,lib1] y&#x3D;gene_expression[,lib2] zero_count &#x3D; length(which(x&#x3D;&#x3D;0)) + length(which(y&#x3D;&#x3D;0)) colors &#x3D; colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;, &quot;#007FFF&quot;, &quot;cyan&quot;,&quot;#7FFF7F&quot;, &quot;yellow&quot;, &quot;#FF7F00&quot;, &quot;red&quot;, &quot;#7F0000&quot;)) smoothScatter(x&#x3D;log2(x+min_nonzero), y&#x3D;log2(y+min_nonzero), xlab&#x3D;lib1, ylab&#x3D;lib2, main&#x3D;name, colramp&#x3D;colors, nbin&#x3D;275) abline(a&#x3D;0,b&#x3D;1) rs&#x3D;cor(x,y, method&#x3D;&quot;pearson&quot;)^2 legend_text &#x3D; c(paste(&quot;R squared &#x3D; &quot;, round(rs, digits&#x3D;3), sep&#x3D;&quot;&quot;), paste(&quot;Zero count &#x3D; &quot;, zero_count, sep&#x3D;&quot;&quot;)) legend(&quot;topleft&quot;, legend_text, lwd&#x3D;c(1,NA), col&#x3D;&quot;black&quot;, bg&#x3D;&quot;white&quot;, cex&#x3D;0.8)&#125;#### Plot #7 - Now make a call to our custom function created above, once for each library comparisonpar(mfrow&#x3D;c(1,2))plotCor2(&quot;FPKM.UHR_Rep1&quot;, &quot;FPKM.HBR_Rep1&quot;, &quot;UHR_1 vs HBR_1&quot;, &quot;tomato2&quot;)plotCor2(&quot;FPKM.UHR_Rep2&quot;, &quot;FPKM.HBR_Rep2&quot;, &quot;UHR_2 vs HBR_2&quot;, &quot;royalblue2&quot;)#### Compare the correlation &#39;distance&#39; between all replicates#Do we see the expected pattern for all eight libraries (i.e. replicates most similar, then tumor vs. normal)?#Calculate the FPKM sum for all 6 librariesgene_expression[,&quot;sum&quot;]&#x3D;apply(gene_expression[,data_columns], 1, sum)#Identify the genes with a grand sum FPKM of at least 5 - we will filter out the genes with very low expression across the boardi &#x3D; which(gene_expression[,&quot;sum&quot;] &gt; 5)#Calculate the correlation between all pairs of datar&#x3D;cor(gene_expression[i,data_columns], use&#x3D;&quot;pairwise.complete.obs&quot;, method&#x3D;&quot;pearson&quot;)#Print out these correlation valuesr#### Plot #8 - Convert correlation to &#39;distance&#39;, and use &#39;multi-dimensional scaling&#39; to display the relative differences between libraries#This step calculates 2-dimensional coordinates to plot points for each library#Libraries with similar expression patterns (highly correlated to each other) should group together#What pattern do we expect to see, given the types of libraries we have (technical replicates, biologal replicates, tumor&#x2F;normal)?d&#x3D;1-rmds&#x3D;cmdscale(d, k&#x3D;2, eig&#x3D;TRUE)par(mfrow&#x3D;c(1,1))plot(mds$points, type&#x3D;&quot;n&quot;, xlab&#x3D;&quot;&quot;, ylab&#x3D;&quot;&quot;, main&#x3D;&quot;MDS distance plot (all non-zero genes)&quot;, xlim&#x3D;c(-0.12,0.12), ylim&#x3D;c(-0.12,0.12))points(mds$points[,1], mds$points[,2], col&#x3D;&quot;grey&quot;, cex&#x3D;2, pch&#x3D;16)text(mds$points[,1], mds$points[,2], short_names, col&#x3D;data_colors)# Calculate the differential expression results including significanceresults_genes &#x3D; stattest(bg, feature&#x3D;&quot;gene&quot;, covariate&#x3D;&quot;type&quot;, getFC&#x3D;TRUE, meas&#x3D;&quot;FPKM&quot;)results_genes &#x3D; merge(results_genes,bg_gene_names,by.x&#x3D;c(&quot;id&quot;),by.y&#x3D;c(&quot;gene_id&quot;))#### Plot #9 - View the distribution of differential expression values as a histogram#Display only those that are significant according to Ballgownsig&#x3D;which(results_genes$pval&lt;0.05)results_genes[,&quot;de&quot;] &#x3D; log2(results_genes[,&quot;fc&quot;])hist(results_genes[sig,&quot;de&quot;], breaks&#x3D;50, col&#x3D;&quot;seagreen&quot;, xlab&#x3D;&quot;log2(Fold change) UHR vs HBR&quot;, main&#x3D;&quot;Distribution of differential expression values&quot;)abline(v&#x3D;-2, col&#x3D;&quot;black&quot;, lwd&#x3D;2, lty&#x3D;2)abline(v&#x3D;2, col&#x3D;&quot;black&quot;, lwd&#x3D;2, lty&#x3D;2)legend(&quot;topleft&quot;, &quot;Fold-change &gt; 4&quot;, lwd&#x3D;2, lty&#x3D;2)#### Plot #10 - Display the grand expression values from UHR and HBR and mark those that are significantly differentially expressedgene_expression[,&quot;UHR&quot;]&#x3D;apply(gene_expression[,c(1:3)], 1, mean)gene_expression[,&quot;HBR&quot;]&#x3D;apply(gene_expression[,c(4:6)], 1, mean)x&#x3D;log2(gene_expression[,&quot;UHR&quot;]+min_nonzero)y&#x3D;log2(gene_expression[,&quot;HBR&quot;]+min_nonzero)plot(x&#x3D;x, y&#x3D;y, pch&#x3D;16, cex&#x3D;0.25, xlab&#x3D;&quot;UHR FPKM (log2)&quot;, ylab&#x3D;&quot;HBR FPKM (log2)&quot;, main&#x3D;&quot;UHR vs HBR FPKMs&quot;)abline(a&#x3D;0, b&#x3D;1)xsig&#x3D;x[sig]ysig&#x3D;y[sig]points(x&#x3D;xsig, y&#x3D;ysig, col&#x3D;&quot;magenta&quot;, pch&#x3D;16, cex&#x3D;0.5)legend(&quot;topleft&quot;, &quot;Significant&quot;, col&#x3D;&quot;magenta&quot;, pch&#x3D;16)#Get the gene symbols for the top N (according to corrected p-value) and display them on the plottopn &#x3D; order(abs(results_genes[sig,&quot;fc&quot;]), decreasing&#x3D;TRUE)[1:25]topn &#x3D; order(results_genes[sig,&quot;qval&quot;])[1:25]text(x[topn], y[topn], results_genes[topn,&quot;gene_name&quot;], col&#x3D;&quot;black&quot;, cex&#x3D;0.75, srt&#x3D;45)#### Write a simple table of differentially expressed transcripts to an output file#Each should be significant with a log2 fold-change &gt;&#x3D; 2sigpi &#x3D; which(results_genes[,&quot;pval&quot;]&lt;0.05)sigp &#x3D; results_genes[sigpi,]sigde &#x3D; which(abs(sigp[,&quot;de&quot;]) &gt;&#x3D; 2)sig_tn_de &#x3D; sigp[sigde,]#Order the output by or p-value and then break ties using fold-changeo &#x3D; order(sig_tn_de[,&quot;qval&quot;], -abs(sig_tn_de[,&quot;de&quot;]), decreasing&#x3D;FALSE)output &#x3D; sig_tn_de[o,c(&quot;gene_name&quot;,&quot;id&quot;,&quot;fc&quot;,&quot;pval&quot;,&quot;qval&quot;,&quot;de&quot;)]write.table(output, file&#x3D;&quot;SigDE_supplementary_R.txt&quot;, sep&#x3D;&quot;\\t&quot;, row.names&#x3D;FALSE, quote&#x3D;FALSE)#View selected columns of the first 25 lines of outputoutput[1:25,c(1,4,5)]#You can open the file &quot;SigDE.txt&quot; in Excel, Calc, etc.#It should have been written to the current working directory that you set at the beginning of the R tutorialdir()#### Plot #11 - Create a heatmap to vizualize expression differences between the eight samples#Define custom dist and hclust functions for use with heatmapsmydist&#x3D;function(c) &#123;dist(c,method&#x3D;&quot;euclidian&quot;)&#125;myclust&#x3D;function(c) &#123;hclust(c,method&#x3D;&quot;average&quot;)&#125;main_title&#x3D;&quot;sig DE Transcripts&quot;par(cex.main&#x3D;0.8)sig_genes&#x3D;results_genes[sig,&quot;id&quot;]sig_gene_names&#x3D;results_genes[sig,&quot;gene_name&quot;]data&#x3D;log2(as.matrix(gene_expression[sig_genes,data_columns])+1)heatmap.2(data, hclustfun&#x3D;myclust, distfun&#x3D;mydist, na.rm &#x3D; TRUE, scale&#x3D;&quot;none&quot;, dendrogram&#x3D;&quot;both&quot;, margins&#x3D;c(6,7), Rowv&#x3D;TRUE, Colv&#x3D;TRUE, symbreaks&#x3D;FALSE, key&#x3D;TRUE, symkey&#x3D;FALSE, density.info&#x3D;&quot;none&quot;, trace&#x3D;&quot;none&quot;, main&#x3D;main_title, cexRow&#x3D;0.3, cexCol&#x3D;1, labRow&#x3D;sig_gene_names,col&#x3D;rev(heat.colors(75)))dev.off()#The output file can be viewed in your browser at the following url:#Note, you must replace __YOUR_IP_ADDRESS__ with your own amazon instance IP#http:&#x2F;&#x2F;__YOUR_IP_ADDRESS__&#x2F;workspace&#x2F;rnaseq&#x2F;de&#x2F;ballgown&#x2F;ref_only&#x2F;Tutorial_Part3_Supplementary_R_output.pdf#To exit R type:quit(save&#x3D;&quot;no&quot;)","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(3.2)","url":"/2020/12/24/2020-12-24-RNAseq(13)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 3.2 Differential Expression # Ballgown 用 Ballgown 比较肿瘤和正常情况。详情请参考手册: https://www.bioconductor.org/packages/release/bioc/html/ballgown.html ` 使用所有复制，对已知 (仅参考模式) 转录本进行 UHR 与 HBR 比较: 首先创建一个文件，列出我们的 6 个表达式文件，然后查看该文件，检查这些结果: printf &quot;\\&quot;ids\\&quot;,\\&quot;type\\&quot;,\\&quot;path\\&quot;\\n\\&quot;UHR_Rep1\\&quot;,\\&quot;UHR\\&quot;,\\&quot;UHR_Rep1\\&quot;\\n\\&quot;UHR_Rep2\\&quot;,\\&quot;UHR\\&quot;,\\&quot;UHR_Rep2\\&quot;\\n\\&quot;UHR_Rep3\\&quot;,\\&quot;UHR\\&quot;,\\&quot;UHR_Rep3\\&quot;\\n\\&quot;HBR_Rep1\\&quot;,\\&quot;HBR\\&quot;,\\&quot;HBR_Rep1\\&quot;\\n\\&quot;HBR_Rep2\\&quot;,\\&quot;HBR\\&quot;,\\&quot;HBR_Rep2\\&quot;\\n\\&quot;HBR_Rep3\\&quot;,\\&quot;HBR\\&quot;,\\&quot;HBR_Rep3\\&quot;\\n&quot; &gt; UHR_vs_HBR.csvcat UHR_vs_HBR.csvR#Jason Walker, jason.walker[AT]wustl.edu#Malachi Griffith, mgriffit[AT]wustl.edu#Obi Griffith, obigriffith[AT]wustl.edu#The Genome McDonnell Institute, Washington University School of Medicine#R tutorial for Informatics for RNA-sequence Analysis workshopslibrary(ballgown)library(genefilter)library(dplyr)library(devtools)# Load phenotype data from a file we saved in the current working directorypheno_data &#x3D; read.csv(&quot;UHR_vs_HBR.csv&quot;)# Load ballgown data structure and save it to a variable &quot;bg&quot;bg &#x3D; ballgown(samples&#x3D;as.vector(pheno_data$path), pData&#x3D;pheno_data)# Display a description of this objectbg# Load all attributes including gene namebg_table &#x3D; texpr(bg, &#39;all&#39;)bg_gene_names &#x3D; unique(bg_table[, 9:10])# Save the ballgown object to a file for later usesave(bg, file&#x3D;&#39;bg.rda&#39;)# Perform differential expression (DE) analysis with no filteringresults_transcripts &#x3D; stattest(bg, feature&#x3D;&quot;transcript&quot;, covariate&#x3D;&quot;type&quot;, getFC&#x3D;TRUE, meas&#x3D;&quot;FPKM&quot;)results_genes &#x3D; stattest(bg, feature&#x3D;&quot;gene&quot;, covariate&#x3D;&quot;type&quot;, getFC&#x3D;TRUE, meas&#x3D;&quot;FPKM&quot;)results_genes &#x3D; merge(results_genes, bg_gene_names, by.x&#x3D;c(&quot;id&quot;), by.y&#x3D;c(&quot;gene_id&quot;))# Save a tab delimited file for both the transcript and gene resultswrite.table(results_transcripts, &quot;UHR_vs_HBR_transcript_results.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)write.table(results_genes, &quot;UHR_vs_HBR_gene_results.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)# Filter low-abundance genes. Here we remove all transcripts with a variance across the samples of less than onebg_filt &#x3D; subset (bg,&quot;rowVars(texpr(bg)) &gt; 1&quot;, genomesubset&#x3D;TRUE)# Load all attributes including gene namebg_filt_table &#x3D; texpr(bg_filt , &#39;all&#39;)bg_filt_gene_names &#x3D; unique(bg_filt_table[, 9:10])# Perform DE analysis now using the filtered dataresults_transcripts &#x3D; stattest(bg_filt, feature&#x3D;&quot;transcript&quot;, covariate&#x3D;&quot;type&quot;, getFC&#x3D;TRUE, meas&#x3D;&quot;FPKM&quot;)results_genes &#x3D; stattest(bg_filt, feature&#x3D;&quot;gene&quot;, covariate&#x3D;&quot;type&quot;, getFC&#x3D;TRUE, meas&#x3D;&quot;FPKM&quot;)results_genes &#x3D; merge(results_genes, bg_filt_gene_names, by.x&#x3D;c(&quot;id&quot;), by.y&#x3D;c(&quot;gene_id&quot;))# Output the filtered list of genes and transcripts and save to tab delimited fileswrite.table(results_transcripts, &quot;UHR_vs_HBR_transcript_results_filtered.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)write.table(results_genes, &quot;UHR_vs_HBR_gene_results_filtered.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)# Identify the significant genes with p-value &lt; 0.05sig_transcripts &#x3D; subset(results_transcripts, results_transcripts$pval&lt;0.05)sig_genes &#x3D; subset(results_genes, results_genes$pval&lt;0.05)# Output the signifant gene results to a pair of tab delimited fileswrite.table(sig_transcripts, &quot;UHR_vs_HBR_transcript_results_sig.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)write.table(sig_genes, &quot;UHR_vs_HBR_gene_results_sig.tsv&quot;, sep&#x3D;&quot;\\t&quot;, quote&#x3D;FALSE, row.names &#x3D; FALSE)# Exit the R sessionquit(save&#x3D;&quot;no&quot;)运行结束后查看结果 head UHR_vs_HBR_gene_results.tsv这条染色体上有多少个基因？ grep -v feature UHR_vs_HBR_gene_results.tsv | wc -l在 UHR 或 HBR 中有多少通过过滤？ grep -v feature UHR_vs_HBR_gene_results_filtered.tsv | wc -l在这条染色体上发现了多少差异表达基因 (p 值 &lt; 0.05)? grep -v feature UHR_vs_HBR_gene_results_sig.tsv | wc -l展示前 20 个 DE 基因。看看 IGV 中的一些基因 —— 它们有意义吗？ grep -v feature UHR_vs_HBR_gene_results_sig.tsv | sort -rnk 3 | head -n 20 #Higher abundance in UHRgrep -v feature UHR_vs_HBR_gene_results_sig.tsv | sort -nk 3 | head -n 20 #Higher abundance in HBR将 P&lt;0.05 的所有基因保存到一个新文件中。 grep -v feature UHR_vs_HBR_gene_results_sig.tsv | cut -f 6 | sed &#39;s&#x2F;\\&quot;&#x2F;&#x2F;g&#39; &gt; DE_genes.txthead DE_genes.txt# edgeR mkdir -p de&#x2F;htseq_countscd de&#x2F;htseq_countsperl -ne &#39;if ($_ &#x3D;~ &#x2F;gene_id\\s\\&quot;(ENSG\\S+)\\&quot;\\;&#x2F;) &#123; $id &#x3D; $1; $name &#x3D; undef; if ($_ &#x3D;~ &#x2F;gene_name\\s\\&quot;(\\S+)&quot;\\;&#x2F;) &#123; $name &#x3D; $1; &#125;; &#125;; if ($id &amp;&amp; $name) &#123;print &quot;$id\\t$name\\n&quot;;&#125; if ($_&#x3D;~&#x2F;gene_id\\s\\&quot;(ERCC\\S+)\\&quot;&#x2F;)&#123;print &quot;$1\\t$1\\n&quot;;&#125;&#39; $RNA_REF_GTF | sort | uniq &gt; ENSG_ID2Name.txthead ENSG_ID2Name.txtcut -f 1 ENSG_ID2Name.txt | sort | uniq | wccut -f 2 ENSG_ID2Name.txt | sort | uniq | wccut -f 2 ENSG_ID2Name.txt | sort | uniq -c | sort -r | head#Malachi Griffith, mgriffit[AT]wustl.edu#Obi Griffith, obigriffith[AT]wustl.edu#The McDonnell Genome Institute, Washington University School of Medicine#R tutorial for Informatics for RNA-sequence Analysis workshops######################## Loading Data into R #########################Set working directory where output will goworking_dir &#x3D; &quot;path_to&#x2F;de&#x2F;htseq_counts&quot;setwd(working_dir)#Read in gene mappingmapping&#x3D;read.table(&quot;~&#x2F;workspace&#x2F;rnaseq&#x2F;de&#x2F;htseq_counts&#x2F;ENSG_ID2Name.txt&quot;, header&#x3D;FALSE, stringsAsFactors&#x3D;FALSE, row.names&#x3D;1)# Read in count matrixrawdata&#x3D;read.table(&quot;~&#x2F;workspace&#x2F;rnaseq&#x2F;expression&#x2F;htseq_counts&#x2F;gene_read_counts_table_all_final.tsv&quot;, header&#x3D;TRUE, stringsAsFactors&#x3D;FALSE, row.names&#x3D;1)# Check dimensionsdim(rawdata)# Require at least 25% of samples to have count &gt; 25quant &lt;- apply(rawdata,1,quantile,0.75)keep &lt;- which((quant &gt;&#x3D; 25) &#x3D;&#x3D; 1)rawdata &lt;- rawdata[keep,]dim(rawdata)################## Running edgeR ################### load edgeRlibrary(&#39;edgeR&#39;)# make class labelsclass &lt;- factor( c( rep(&quot;UHR&quot;,3), rep(&quot;HBR&quot;,3) ))# Get common gene namesgenes&#x3D;rownames(rawdata)gene_names&#x3D;mapping[genes,1]# Make DGEList objecty &lt;- DGEList(counts&#x3D;rawdata, genes&#x3D;genes, group&#x3D;class)nrow(y)# TMM Normalizationy &lt;- calcNormFactors(y)# Estimate dispersiony &lt;- estimateCommonDisp(y, verbose&#x3D;TRUE)y &lt;- estimateTagwiseDisp(y)# Differential expression testet &lt;- exactTest(y)# Print top genestopTags(et)# Print number of up&#x2F;down significant genes at FDR &#x3D; 0.05 significance levelsummary(de &lt;- decideTestsDGE(et, p&#x3D;.05))detags &lt;- rownames(y)[as.logical(de)]# Output DE genes# Matrix of significantly DE genesmat &lt;- cbind( genes,gene_names, sprintf(&#39;%0.3f&#39;,log10(et$table$PValue)), sprintf(&#39;%0.3f&#39;,et$table$logFC))[as.logical(de),]colnames(mat) &lt;- c(&quot;Gene&quot;, &quot;Gene_Name&quot;, &quot;Log10_Pvalue&quot;, &quot;Log_fold_change&quot;)# Order by log fold changeo &lt;- order(et$table$logFC[as.logical(de)],decreasing&#x3D;TRUE)mat &lt;- mat[o,]# Save tablewrite.table(mat, file&#x3D;&quot;DE_genes.txt&quot;, quote&#x3D;FALSE, row.names&#x3D;FALSE, sep&#x3D;&quot;\\t&quot;)#To exit R type the followingquit(save&#x3D;&quot;no&quot;)与其他结果比较 cat DE_genes.txtcat &#x2F;de&#x2F;htseq_counts&#x2F;DE_genes.txtcut -f 1 DE_genes.txt | sort &gt; ballgown_DE_gene_symbols.txtcut -f 2 de&#x2F;htseq_counts&#x2F;DE_genes.txt | sort &gt; htseq_counts_edgeR_DE_gene_symbols.txt","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(3.1)","url":"/2020/12/22/2020-12-22-RNAseq(12)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 3.1 Expression # Stringtie 使用 Stringtie 从上一个模块中 HISAT2 生成的 SAM/BAM 文件中生成表达量统计 注意使用 Stringtie 从头发现转录本和差异表达 在本模块中，我们将以有参模式模式运行 Stringtie。为了简化和减少运行时间，只使用已知的转录本。但是，Stringtie 可以预测每个文库中存在的可能的转录本 (通过删除 Stringtie 命令中的 '-G' 选项)。然后，Stringtie 将为每个由数据组装的转录本分配任意的转录本 id，并估计这些转录本的表达。 Stringtie 提供了一个 merge 命令合并不同文库的 gtf 文件 旦您有了一个合并的 GTF 文件，您就可以使用这个文件再次运行 Stringtie，而不是我们上面使用的已知的 transcripts GTF 文件 Stringtie 还提供了 “gffcompare” 来比较预测的转录本和已知的转录本 参考 Stringtie 手册获得更详细的解释: https://ccb.jhu.edu/software/stringtie/index.shtml?t=manual String 的基础使用 stringtie &lt;aligned_reads.bam&gt; [options]* '-p 8' tells Stringtie to use eight CPUs '-G &lt;known transcripts file&gt;' reference annotation to use for guiding the assembly process (GTF/GFF3) '-e' only estimate the abundance of given reference transcripts (requires -G) '-B' enable output of Ballgown table files which will be created in the same directory as the output GTF (requires -G, -o recommended) '-o' output path/file name for the assembled transcripts GTF (default: stdout) '-A' output path/file name for gene abundance estimates stringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o HBR_Rep1&#x2F;transcripts.gtf -A HBR_Rep1&#x2F;gene_abundances.tsv HBR_Rep1.bamstringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o HBR_Rep2&#x2F;transcripts.gtf -A HBR_Rep2&#x2F;gene_abundances.tsv HBR_Rep2.bamstringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o HBR_Rep3&#x2F;transcripts.gtf -A HBR_Rep3&#x2F;gene_abundances.tsv HBR_Rep3.bamstringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o UHR_Rep1&#x2F;transcripts.gtf -A UHR_Rep1&#x2F;gene_abundances.tsv UHR_Rep1.bamstringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o UHR_Rep2&#x2F;transcripts.gtf -A UHR_Rep2&#x2F;gene_abundances.tsv UHR_Rep2.bamstringtie -p 8 -G ..&#x2F;chr22_with_ERCC92.gtf -e -B -o UHR_Rep3&#x2F;transcripts.gtf -A UHR_Rep3&#x2F;gene_abundances.tsv UHR_Rep3.bamStringtie 的原始输出是什么样子的？有关 Stringtie 输出文件的详细信息，请参阅 Stringtie 手册 (输出部分) less -S UHR_Rep1&#x2F;transcripts.gtf查看表达量 awk &#39;&#123;if ($3&#x3D;&#x3D;&quot;transcript&quot;) print&#125;&#39; UHR_Rep1&#x2F;transcripts.gtf | cut -f 1,4,9 | less22 15690026 gene_id &quot;ENSG00000198062&quot;; transcript_id &quot;ENST00000343518&quot;; ref_gene_name &quot;POTEH&quot;; cov &quot;0.106554&quot;; FPKM &quot;2.778050&quot;; TPM &quot;3.623655&quot;;22 15690078 gene_id &quot;ENSG00000198062&quot;; transcript_id &quot;ENST00000621704&quot;; ref_gene_name &quot;POTEH&quot;; cov &quot;0.519912&quot;; FPKM &quot;13.555018&quot;; TPM &quot;17.681002&quot;;基因和转录本水平表达值也可以在这两个文件中查看: less -S UHR_Rep1&#x2F;t_data.ctabless -S UHR_Rep1&#x2F;gene_abundances.tsv创建一个整洁的表达式矩阵文件。这将在基因和转录水平上进行，还将产生各种不同的表达量表示方法：覆盖率、FPKM 和 TPM。 wget https:&#x2F;&#x2F;github.com&#x2F;griffithlab&#x2F;rnaseq_tutorial&#x2F;blob&#x2F;master&#x2F;scripts&#x2F;stringtie_expression_matrix.plchmod +x stringtie_expression_matrix.pl.&#x2F;stringtie_expression_matrix.pl --expression_metric&#x3D;TPM --result_dirs&#x3D;&#39;HBR_Rep1,HBR_Rep2,HBR_Rep3,UHR_Rep1,UHR_Rep2,UHR_Rep3&#39; --transcript_matrix_file&#x3D;transcript_tpm_all_samples.tsv --gene_matrix_file&#x3D;gene_tpm_all_samples.tsv.&#x2F;stringtie_expression_matrix.pl --expression_metric&#x3D;FPKM --result_dirs&#x3D;&#39;HBR_Rep1,HBR_Rep2,HBR_Rep3,UHR_Rep1,UHR_Rep2,UHR_Rep3&#39; --transcript_matrix_file&#x3D;transcript_fpkm_all_samples.tsv --gene_matrix_file&#x3D;gene_fpkm_all_samples.tsv.&#x2F;stringtie_expression_matrix.pl --expression_metric&#x3D;Coverage --result_dirs&#x3D;&#39;HBR_Rep1,HBR_Rep2,HBR_Rep3,UHR_Rep1,UHR_Rep2,UHR_Rep3&#39; --transcript_matrix_file&#x3D;transcript_coverage_all_samples.tsv --gene_matrix_file&#x3D;gene_coverage_all_samples.tsvhead transcript_tpm_all_samples.tsv gene_tpm_all_samples.tsv# HTSEQ-COUNT (粗略介绍) http://www-huber.embl.de/users/anders/HTSeq/doc/count.html htseq-count [options] &lt;sam_file&gt; &lt;gff_file&gt; '--format' specify the input file format one of BAM or SAM. Since we have BAM format files, select 'bam' for this option. '--order' provide the expected sort order of the input file. Previously we generated position sorted BAM files so use 'pos'. '--mode' determines how to deal with reads that overlap more than one feature. We believe the 'intersection-strict' mode is best. '--stranded' specifies whether data is stranded or not. The TruSeq strand-specific RNA libraries suggest the 'reverse' option for this parameter. '--minaqual' will skip all reads with alignment quality lower than the given minimum value '--type' specifies the feature type (3rd column in GFF file) to be used. (default, suitable for RNA-Seq and Ensembl GTF files: exon) '--idattr' The feature ID used to identity the counts in the output table. The default, suitable for RNA-SEq and Ensembl GTF files, is gene_id. mkdir -p htseq_countscd htseq_countshtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;UHR_Rep1.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; UHR_Rep1_gene.tsvhtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;UHR_Rep2.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; UHR_Rep2_gene.tsvhtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;UHR_Rep3.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; UHR_Rep3_gene.tsvhtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;HBR_Rep1.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; HBR_Rep1_gene.tsvhtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;HBR_Rep2.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; HBR_Rep2_gene.tsvhtseq-count --format bam --order pos --mode intersection-strict --stranded reverse --minaqual 1 --type exon --idattr gene_id ..&#x2F;HBR_Rep3.bam ..&#x2F;..&#x2F;chr22_with_ERCC92.gtf &gt; HBR_Rep3_gene.tsvcd htseq_counts&#x2F;join UHR_Rep1_gene.tsv UHR_Rep2_gene.tsv | join - UHR_Rep3_gene.tsv | join - HBR_Rep1_gene.tsv | join - HBR_Rep2_gene.tsv | join - HBR_Rep3_gene.tsv &gt; gene_read_counts_table_all.tsvecho &quot;GeneID UHR_Rep1 UHR_Rep2 UHR_Rep3 HBR_Rep1 HBR_Rep2 HBR_Rep3&quot; &gt; header.txtcat header.txt gene_read_counts_table_all.tsv | grep -v &quot;__&quot; | perl -ne &#39;chomp $_; $_ &#x3D;~ s&#x2F;\\s+&#x2F;\\t&#x2F;g; print &quot;$_\\n&quot;&#39; &gt; gene_read_counts_table_all_final.tsvrm -f gene_read_counts_table_all.tsv header.txthead gene_read_counts_table_all_final.tsv","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(2.5)","url":"/2020/12/19/2020-12-19-RNAseq(11)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 2.5 Alignment QC # 使用 samtools 和 FastQC 来评估比对结果 使用 samtools view 查看 SAM/BAM 比对文件的格式 samtools view -H UHR.bamsamtools view UHR.bam | head尝试过滤 BAM 文件以排除某些标记。这可以通过 samtools view -f -F 选项实现 -f INT required flag -F INT filtering flag Try requiring that alignments are 'paired' and 'mapped in a proper pair' (=3). Also filter out alignments that are 'unmapped', the 'mate is unmapped', and 'not primary alignment' (=268) samtools view -f 3 -F 268 UHR.bam | head现在要求只对 “PCR or optical duplicate” 进行比对。有多少 reads 符合这个标准？为什么？ samtools view -f 1024 UHR.bam | head使用 samtools flagstat 获取比对的基本情况。比对到上 reads 的百分比是多少？ samtools flagstat UHR.bam1174953 + 0 in total (QC-passed reads + QC-failed reads)24539 + 0 secondary0 + 0 supplementary0 + 0 duplicates1173741 + 0 mapped (99.90% : N&#x2F;A)1150414 + 0 paired in sequencing575207 + 0 read1575207 + 0 read21143860 + 0 properly paired (99.43% : N&#x2F;A)1148598 + 0 with itself and mate mapped604 + 0 singletons (0.05% : N&#x2F;A)6 + 0 with mate mapped to a different chr6 + 0 with mate mapped to a different chr (mapQ&gt;&#x3D;5)samtools flagstat HBR.bam793963 + 0 in total (QC-passed reads + QC-failed reads)7597 + 0 secondary0 + 0 supplementary0 + 0 duplicates793356 + 0 mapped (99.92% : N&#x2F;A)786366 + 0 paired in sequencing393183 + 0 read1393183 + 0 read2783124 + 0 properly paired (99.59% : N&#x2F;A)785496 + 0 with itself and mate mapped263 + 0 singletons (0.03% : N&#x2F;A)0 + 0 with mate mapped to a different chr0 + 0 with mate mapped to a different chr (mapQ&gt;&#x3D;5)SAM/BAM 格式的详细信息可以在这里找到:http://samtools.sourceforge.net/SAM1.pdf # Using FastQC 你可以使用 FastQC 来执行基本的 BAM 文件的 QC (Pre-Alignment QC)。输出非常类似于在 fastq 文件上运行 FastQC。","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(2.4)","url":"/2020/12/17/2020-12-17-RNAseq(10)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 2.4 Alignment Visualization 在我们可以在 IGV 浏览器中查看我们的结果之前，我们需要索引我们的 BAM 文件。为此，我们将使用 samtools 索引。为了方便以后，为所有 bam 文件建立索引。 cd alignfind *.bam -exec echo samtools index &#123;&#125; \\; | sh# 可视化比对结果 在 IGV 加载 UHR 与 HBR 的 bam 文件 # 练习： 尝试在 RNAseq 数据中找到一个变量位置: HINT: DDX17 is a highly expressed gene with several variants in its 3 prime UTR. Other highly expressed genes you might explore are: NUP50, CYB5R3, and EIF3L (all have at least one transcribed variant). Are these variants previously known (e.g., present in dbSNP)? How should we interpret the allele frequency of each variant? Remember that we have rather unusual samples here in that they are actually pooled RNAs corresponding to multiple individuals (genotypes). Take note of the genomic position of your variant. We will need this later. # BAM read counting 首先，使用 samtools mpileup 来可视化相应的区域。 mkdir bam_readcountcd bam_readcountsamtools mpileup -f ..&#x2F;chr22_only.fa -r 22:18918457-18918467 ..&#x2F;align&#x2F;UHR.bam ..&#x2F;align&#x2F;HBR.bam每一行由染色体、位点、碱基、覆盖位点的 reads 数、reads base 和 base 质量组成。在 read 碱基列，点表示与正链参考碱基匹配，逗号表示反链匹配，ACGTN 表示正链不匹配，ACGTN 表示反链不匹配。模式 +[0-9]+[ACGTNacgtn]+ 表示在这个参考位置和下一个参考位置之间有一个插入。插入的长度由模式中的整数给出，然后是插入的序列。有关输出的更多解释，请参阅 samtools pileup/mpileup 文档 http://samtools.sourceforge.net/pileup.shtml http://samtools.sourceforge.net/mpileup.shtml 现在，使用 bam-readcount 来计数。首先，创建一个 bed 文件，其中包含一些感兴趣的位置 (我们将创建一个名为 snvs 的文件。使用 echo 命令 bed)。 它将包含一个单行，指定 chr22 上的变量位置，例如。 echo &quot;22 38483683 38483683&quot;echo &quot;22 38483683 38483683&quot; &gt; snvs.bed在这个列表上运行 bam-readcount 查看肿瘤和正常合并的 bam 文件 bam-readcount -l snvs.bed -f ..&#x2F;chr22_only.fa ..&#x2F;align&#x2F;HBR.bam 2&gt;&#x2F;dev&#x2F;null 1&gt;HBR_bam-readcounts.txtbam-readcount -l snvs.bed -f ..&#x2F;chr22_only.fa ..&#x2F;align&#x2F;UHR.bam 2&gt;&#x2F;dev&#x2F;null 1&gt;UHR_bam-readcounts.txt从这个输出中，可以解析每个碱基的 reads 计数 cat UHR_bam-readcounts.txt | perl -ne &#39;@data&#x3D;split(&quot;\\t&quot;, $_); @Adata&#x3D;split(&quot;:&quot;, $data[5]); @Cdata&#x3D;split(&quot;:&quot;, $data[6]); @Gdata&#x3D;split(&quot;:&quot;, $data[7]); @Tdata&#x3D;split(&quot;:&quot;, $data[8]); print &quot;UHR Counts\\t$data[0]\\t$data[1]\\tA: $Adata[1]\\tC: $Cdata[1]\\tT: $Tdata[1]\\tG: $Gdata[1]\\n&quot;;&#39;UHR Counts 22 38483683 A: 163 C: 0 T: 0 G: 163cat HBR_bam-readcounts.txt | perl -ne &#39;@data&#x3D;split(&quot;\\t&quot;, $_); @Adata&#x3D;split(&quot;:&quot;, $data[5]); @Cdata&#x3D;split(&quot;:&quot;, $data[6]); @Gdata&#x3D;split(&quot;:&quot;, $data[7]); @Tdata&#x3D;split(&quot;:&quot;, $data[8]); print &quot;HBR Counts\\t$data[0]\\t$data[1]\\tA: $Adata[1]\\tC: $Cdata[1]\\tT: $Tdata[1]\\tG: $Gdata[1]\\n&quot;;&#39;HBR Counts 22 38483683 A: 75 C: 0 T: 0 G: 131","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(2.3)","url":"/2020/12/15/2020-12-15-RNAseq(9)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 2.3 IGV # 1.introduction # Description of the lab 高通量测序最受欢迎的工具 -IGV(Integrative Genomics Viewer) 伴随本教程的文件 IGV Lecture - Brief IGV Lecture - Long, from Broad Institute 完成本次教程可实现以下工作 可视化各种基因组数据 快速导航基因组 可视化 reads 比对情况 肉眼验证 SNP/SNV # Requirements Integrative Genomics Viewer Ability to run Java Note that while most tutorials in this course are performed on the cloud, IGV will always be run on your local machine # Compatibility 本教程是为 IGV v2.3 准备的，可以在 IGV 下载页面上找到。强烈建议使用这个版本。 # Data Set for IGV 使用公开的来自 HCC1143 细胞系的 Illumina 序列数据。HCC1143 细胞系是从一名患有乳腺癌的 52 岁白人妇女体内产生的。这个细胞系的附加信息可以在这里找到:HCC1143 (tumor, TNM stage IIA, grade 3, primary ductal carcinoma) 以及 HCC1143/BL(matched normal EBV transformed lymphoblast cell line). 从细胞系 HCC1143 产生的 reads 比对到这个区域 Chromosome 21: 19,000,000-20,000,000 HCC1143.normal.21.19M-20M.bam HCC1143.normal.21.19M-20M.bam.bai # 2. Getting familiar with IGV # Get familiar with the interface 载入一个基因组: 默认情况下，IGV 加载 Human hg19。如果你研究的是另一个版本的人类基因组，或者另一种物种，你可以通过点击左上角的下拉菜单来改变基因组。在这个教程中，我们将使用人类 hg19。 也可以采用以下方式 ( File -&gt; Load from Server... ): Ensembl genes (or your favourite source of gene annotations) GC Percentage dbSNP 1.3.1 or 1.3.7 Navigation： 在这个参考基因组中可以看到染色体列表，选择 1 号染色体。 location 字段 (在界面的左上角) 中输入，导航到 chr1:10 000- 11000，然后单击 Go。这显示了 1 号染色体的窗口宽 1000 个碱基对，从 10000 号位置开始。 IGV 以颜色序列的形式显示基因组中的碱基序列 (例如 A = 绿色，C = 蓝色，等等)。这使得重复序列，比如在这个区域开始处发现的那些序列，很容易识别。放大一点使用 + 按钮看到参考基因组序列的单个碱基。 你可以在基因组坐标所在的框中输入你感兴趣的基因，然后按 Enter/Return 键。试试你最喜欢的基因，或者 BRCA1。 基因用线和框表示。线代表内含子区域，框代表外显子区域。箭头表示该基因的转录方向 / 链。当一个外显子框变窄，这表示一个 UTR。 # Region Lists 有时，保存当前位置或加载感兴趣的区域真的很有用。为此，IGV 中有一个区域导航器。要访问它，单击 Regions &gt; Region Navigator。在浏览基因组时，可以随时按 Add 按钮保存一些书签。 # Loading Read Alignments 我们将使用乳腺癌细胞系 HCC1143 来可视化比对结果。在速度方面，只有一小部分 chr21 将装载 (19M:20M)。 HCC1143 Alignments to hg19: HCC1143.normal.21.19M-20M.bam HCC1143.normal.21.19M-20M.bam.bai 复制文件到你的本地，并在 IGV 中选择 File &gt; Load from File... ，选择 bam 文件，并单击 OK。注意，为了让 IGV 正确地加载它们，bam 文件和索引文件必须在同一个目录中。 # Visualizing read alignments 选择染色体位点： chr21:19,480,041-19,480,386 To start our exploration, right click on the track-name, and select the following options: Sort alignments by start location Group alignments by pair orientation 通过右键点击比对界面和切换选项来试验各种设置。想想哪一种方法最适合特定的任务 (例如，质量控制、SNP 调用、CNV 查找)。 # 3.Inspecting SNPs, SNVs, and SVs # Two neighbouring SNPs Navigate to region chr21:19,479,237-19,479,814 Note two heterozygous variants, one corresponds to a known dbSNP ( G/T on the right) the other does not ( C/T on the left) Zoom in and center on the C/T SNV on the left, sort by base (window chr21:19,479,321 is the SNV position) Sort alignments by base Color alignments by read strand # Homopolymer region with indel Navigate to position chr21:19,518,412-19,518,497 # Coverage by GC Navigate to position chr21:19,611,925-19,631,555 . Note that the range contains areas where coverage drops to zero in a few places. **Example ** Use Collapsed view Use Color alignments by -&gt; insert size and pair orientation Load GC track See concordance of coverage with GC content # Heterozygous SNPs on different alleles Navigate to region chr21:19,666,833-19,667,007 **Example ** Sort by base (at position chr21:19,666,901 ) 对于这两个 snp，等位基因之间没有联系，因为两个 snp 的 reads 都只包含一个或另一个 # 4.Automating Tasks in IGV 我们可以使用 Tools 菜单调用运行批处理脚本。IGV 网站描述了批处理脚本: Batch file requirements: https://www.broadinstitute.org/igv/batch Commands recognized in a batch script: https://www.broadinstitute.org/software/igv/PortCommands We also need to provide sample attribute file as described here: http://www.broadinstitute.org/software/igv/?q=SampleInformation 下载数据集的批处理脚本和属性文件: Batch script: Run_batch_IGV_snapshots.txt Attribute file: Igv_HCC1143_attributes.txt","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(2.2)","url":"/2020/12/12/2020-12-12-RNAseq(8)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 2.2 Alignment # HISAT2 alignment 用 HISAT2 比对基因组和转录组。 首先，为对齐结果创建适当的输出目录 mkdir alignHISAT2 的输出是每个数据集的 SAM/BAM 文件。 参考 HISAT2 帮助手册获得更多说明： https://ccb.jhu.edu/software/hisat2/manual.shtml HISAT2 基本用法: #hisat2 [options]* -x &lt;ht2-idx&gt; &#123;-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt; | --sra-acc &lt;SRA accession number&gt;&#125; [-S &lt;sam&gt;]额外参数如下: '-p 8' tells HISAT2 to use eight CPUs for bowtie alignments. '--rna-strandness RF' specifies strandness of RNAseq library. We will specify RF since the TruSeq strand-specific library was used to make these libraries. See here for options. '--rg-id $ID' specifies a read group ID that is a unique identifier. '--rg SM:$SAMPLE_NAME' specifies a read group sample name. This together with rg-id will allow you to determine which reads came from which sample in the merged bam later on. '--rg LB:$LIBRARY_NAME' specifies a read group library name. This together with rg-id will allow you to determine which reads came from which library in the merged bam later on. '--rg PL:ILLUMINA' specifies a read group sequencing platform. '--rg PU:$PLATFORM_UNIT' specifies a read group sequencing platform unit. Typically this consists of FLOWCELL-BARCODE.LANE '--dta' Reports alignments tailored for transcript assemblers. '-x /path/to/hisat2/index' The HISAT2 index filename prefix (minus the trailing .X.ht2) built earlier including splice sites and exons. '-1 /path/to/read1.fastq.gz' The read 1 FASTQ file, optionally gzip(.gz) or bzip2(.bz2) compressed. '-2 /path/to/read2.fastq.gz' The read 2 FASTQ file, optionally gzip(.gz) or bzip2(.bz2) compressed. '-S /path/to/output.sam' The output SAM format text file of alignments. hisat2 -p 8 --rg-id&#x3D;UHR_Rep1 --rg SM:UHR --rg LB:UHR_Rep1_ERCC-Mix1 --rg PL:ILLUMINA --rg PU:CXX1234-ACTGAC.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;UHR_Rep1.sam hisat2 -p 8 --rg-id&#x3D;UHR_Rep2 --rg SM:UHR --rg LB:UHR_Rep2_ERCC-Mix1 --rg PL:ILLUMINA --rg PU:CXX1234-TGACAC.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 UHR_Rep2_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 UHR_Rep2_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;UHR_Rep2.sam hisat2 -p 8 --rg-id&#x3D;UHR_Rep3 --rg SM:UHR --rg LB:UHR_Rep3_ERCC-Mix1 --rg PL:ILLUMINA --rg PU:CXX1234-CTGACA.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 UHR_Rep3_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 UHR_Rep3_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;UHR_Rep3.sam hisat2 -p 8 --rg-id&#x3D;HBR_Rep1 --rg SM:HBR --rg LB:HBR_Rep1_ERCC-Mix2 --rg PL:ILLUMINA --rg PU:CXX1234-TGACAC.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 HBR_Rep1_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 HBR_Rep1_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;HBR_Rep1.sam hisat2 -p 8 --rg-id&#x3D;HBR_Rep2 --rg SM:HBR --rg LB:HBR_Rep2_ERCC-Mix2 --rg PL:ILLUMINA --rg PU:CXX1234-GACACT.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 HBR_Rep2_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 HBR_Rep2_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;HBR_Rep2.sam hisat2 -p 8 --rg-id&#x3D;HBR_Rep3 --rg SM:HBR --rg LB:HBR_Rep3_ERCC-Mix2 --rg PL:ILLUMINA --rg PU:CXX1234-ACACTG.1 -x INDEX&#x2F;index --dta --rna-strandness RF -1 HBR_Rep3_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1.fastq.gz -2 HBR_Rep3_ERCC-Mix2_Build37-ErccTranscripts-chr22.read2.fastq.gz -S align&#x2F;HBR_Rep3.sam注意：在上面的对齐中，我们将每个库视为一个独立的数据集。如果你有一个库的多个数据，你可以在一个 HISAT2 命令中将它们对齐在一起。要组合多个 reads 文件，您需要为 '-1' 输入参数提供所有 read1 文件作为逗号分隔的列表，然后为 '-2' 输入参数提供所有 read2 文件作为逗号分隔的列表，(其中两个列表的顺序相同): 还可以使用 samtool # SAM 转换为 BAM 将 HISAT2 sam 文件转换为 bam 文件，并按对齐位置排序 # 合并 BAM 文件 将所有 UHR 数据和所有 HBR 数据合并成一个 BAM 文件。注意：这可以通过几种方式来完成，比如 “samtools merge”，“bamtools merge”，或者使用 picard-tools (见下文)。我们选择第三种方法是因为它在合并 bam 头信息方面做得最好。注意:sambamba 也保留头部信息。 cd alignjava -Xmx2g -jar ..&#x2F;..&#x2F;picard.jar MergeSamFiles OUTPUT&#x3D;UHR.bam INPUT&#x3D;UHR_Rep1.bam INPUT&#x3D;UHR_Rep2.bam INPUT&#x3D;UHR_Rep3.bamjava -Xmx2g -jar ..&#x2F;..&#x2F;picard.jar MergeSamFiles OUTPUT&#x3D;HBR.bam INPUT&#x3D;HBR_Rep1.bam INPUT&#x3D;HBR_Rep2.bam INPUT&#x3D;HBR_Rep3.bam计算对齐 (BAM) 文件，确保所有文件都成功创建 (总共应该有 8 个) ls -l *.bam | wc -l8ls *.bamHBR.bam HBR_Rep2.bam UHR.bam UHR_Rep2.bamHBR_Rep1.bam HBR_Rep3.bam UHR_Rep1.bam UHR_Rep3.bam# 练习 6 任务：对额外的数据集执行一些比对。用你在上面学到的技巧来对齐阅读。尝试使用 HISAT2。还要练习将 SAM 转换为 BAM 文件，并合并 BAM 文件。 在练习 3 中创建的名为 “practice” 的单独工作目录中进行分析。 .sam 和.bam 文件之间有什么区别？ sam 文件是一个纯文本序列比对映射文件。bam 文件是相同信息的二进制压缩版本。 如果您像上面所做的那样对结果 BAM 文件进行排序，那么结果是否按 read 名称排序？还是 position? 按照 position 排序 可以查看 BAM 文件的哪些列以确定排序的样式？ 第一、第三和第四列包含 reads 名称、染色体和位置。 samtools view HCC1395_normal.bam | head | cut -f 1,3,4可以使用什么命令仅查看 BAM 头？ samtools view -H HCC1395_normal.bam","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(2.1)","url":"/2020/12/10/2020-12-10-RNAseq(7)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 2.1 Adapter Trim (可选步骤) 使用 Flexbar 从读取的 FASTQ 文件中修剪 reads。这个步骤的输出将为每个数据集裁剪 FASTQ 文件。 参考 Flexbar 帮助文档获得更详细的解释: https://github.com/seqan/flexbar https://github.com/seqan/flexbar/wiki Flexbar 基本用法: flexbar -r reads [-t target] [-b barcodes] [-a adapters] [options]额外选项如下： '--adapter-min-overlap 7' requires a minimum of 7 bases to match the adapter '--adapter-trim-end RIGHT' uses a trimming strategy to remove the adapter from the 3 prime or RIGHT end of the read '--max-uncalled 300' allows as many as 300 uncalled or N bases (MiSeq read lengths can be 300bp) '--min-read-length' the minimum read length allowed after trimming is 25bp. '--threads 8' use 8 threads '--zip-output GZ' the input FASTQ files are gzipped so we will output gzipped FASTQ to save space '--adapters' define the path to the adapter FASTA file to trim '--reads' define the path to the read 1 FASTQ file of reads '--reads2' define the path to the read 2 FASTQ file of reads '--target' a base path for the output files. The value will _1.fastq.gz and _2.fastq.gz for read 1 and read 2 respectively '--pre-trim-left' trim a fixed number of bases at left read end. For example, to trim 5 bases at the left side of reads: --pre-trim-left 5 '--pre-trim-right' trim a fixed number of bases at right read end. For example, to trim 5 bases at the right side of reads: --pre-trim-right 5 '--pre-trim-phred' trim based on phred quality value to deal with higher error rates towards the end of reads. For example, to trim the 3 prime end until quality offset value 30 or higher is reached, specify: --pre-trim-phred 30 # Flexbar trim 首先，为输出设置一些目录 mkdir trim下载必要的 Illumina 接头序列文件。 wget http:&#x2F;&#x2F;genomedata.org&#x2F;rnaseq-tutorial&#x2F;illumina_multiplex.fa使用 flexbar 删除 illumina 接头序列 (如果有的话)，并修剪每个读取的前 13 个碱基。 ..&#x2F;flexbar-3.4.0-linux&#x2F;flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --pre-trim-left 13 --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read1.fastq.gz --reads2 UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22.read2.fastq.gz --target trim&#x2F;UHR_Rep1_ERCC-Mix1_Build37-ErccTranscripts-chr22可选练习：比较裁剪前后 FastQC 文件的质控报告。所有 fastqc 报告都可以在命令行上生成。 fastqc *.fastq.gz# 练习 5 作业：使用上面的方法，修剪你在之前的实践练习中下载的正常样本和肿瘤样本 reads 文件。注意：尝试去掉上面使用的硬左修剪选项 (”--pre-trim-left”)。一旦你削减了读取，使用 FastQC 工具比较修剪前和修剪后的 FastQ 文件。 mkdir trimmedwget http:&#x2F;&#x2F;genomedata.org&#x2F;rnaseq-tutorial&#x2F;illumina_multiplex.faflexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_normal_rep1_r1.fastq.gz --reads2 hcc1395_normal_rep1_r2.fastq.gz --target trimmed&#x2F;hcc1395_normal_rep1flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_normal_rep2_r1.fastq.gz --reads2 hcc1395_normal_rep2_r2.fastq.gz --target trimmed&#x2F;hcc1395_normal_rep2flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_normal_rep3_r1.fastq.gz --reads2 hcc1395_normal_rep3_r2.fastq.gz --target trimmed&#x2F;hcc1395_normal_rep3flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_tumor_rep1_r1.fastq.gz --reads2 hcc1395_tumor_rep1_r2.fastq.gz --target trimmed&#x2F;hcc1395_tumor_rep1flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_tumor_rep2_r1.fastq.gz --reads2 hcc1395_tumor_rep2_r2.fastq.gz --target trimmed&#x2F;hcc1395_tumor_rep2flexbar --adapter-min-overlap 7 --adapter-trim-end RIGHT --adapters illumina_multiplex.fa --max-uncalled 300 --min-read-length 25 --threads 8 --zip-output GZ --reads hcc1395_tumor_rep3_r1.fastq.gz --reads2 hcc1395_tumor_rep3_r2.fastq.gz --target trimmed&#x2F;hcc1395_tumor_rep3修剪后，hcc1395 正常样本 1 号重复，reads1 的读长范围是多少？25-151 FastQC 报告中哪些部分最适合观察修剪的效果？'Basic Statistics', 'Sequence Length Distribution' 以及 'Adapter Content' 在 “Per base sequence content section” 部分，你看到了什么模式？什么可以解释这种模式呢？ 前 9 个碱基位置显示出一个尖状的模式，表明每个碱基在我们的读取 / 片段的开头有偏倚的表示。一种可能的解释是，cDNA 合成的随机六聚体引物在文库准备过程中以非随机的方式产生。因此碎片的生成 (以及最终的 reads) 在开始时有一个非随机模式。","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(1.6)","url":"/2020/12/08/2020-12-08-RNAseq(6)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 1.6 Pre-Alignment QC 在对齐之前，你可以使用 FastQC 来确定你的数据质量: http://www.bioinformatics.babraham.ac.uk/projects/fastqc/ 还有一个视频教程 http://www.youtube.com/watch?v=bz93ReOv87Y 尝试在 fastq 文件上运行 FastQC: fastqc *.fastq.gz 查看一下结果 HBR_Rep1_ERCC-Mix2_Build37-ErccTranscripts-chr22.read1_fastqc.html # 练习 4 作业：在前面的实践练习中下载的其他 fastq 文件中运行 FASTQC。 提示：请记住，将这些数据存储在一个名为 “practice” 的独立工作目录中。 在文件 hcc1395_normal_1.fastq 上运行 FASTQC。并通过检查输出来回答这些问题。 问题 How many total sequences are there? 331,958 What is the range (x - y) of read lengths observed? 151 What is the most common average sequence quality score? 41 What does the Adaptor Content warning tell us? 有一些证据表明，Illumina 接头在 reads 的 3' 端。这表明去除对于该数据来说可能是必须的。","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(1.5)","url":"/2020/12/05/2020-12-05-RNAseq(5)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(1.4)","url":"/2020/12/03/2020-12-03-RNAseq(4)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 1.4 Indexing # 创建 HISAT 索引 为 chr22 和 ERCC spikein 序列创建 HISAT2 索引。HISAT2 可以将外显子和剪接位点合并到索引文件中进行对齐。首先创建一个剪接站点文件，然后创建一个外显子文件。最后制作 FM 索引。 要了解更多关于 HISAT2 索引策略与其他软件的不同之处，请参阅说明书。 hisat2_extract_splice_sites.py chr22_with_ERCC92.gtf &gt;INDEX&#x2F;splicesites.tsvhisat2_extract_exons.py chr22_with_ERCC92.gtf &gt;INDEX&#x2F;exons.tsvhisat2-build -p 8 --ss INDEX&#x2F;splicesites.tsv --exon INDEX&#x2F;exons.tsv chr22_with_ERCC92.fa INDEX&#x2F;index[可选] 为所有染色体创建索引，而不是仅仅为 chr22，你会做以下操作: 注意：下面的例子没有利用将剪接位点和外显子添加到索引。如果需要，可以使用完整的 GTF 生成这些文件，并使用适当的选项将它们添加到命令中。 警告：为了索引整个人类基因组，HISAT2 需要 160GB 内存。AWS 实例大小将耗尽 RAM。 #cd &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;data&#x2F;fasta&#x2F;GRCh38#hisat2-build -p 8 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa Homo_sapiens.GRCh38.dna_sm.primary_assembly","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(1.3)","url":"/2020/12/01/2020-12-01-RNAseq(3)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 1.3 Annotations # Obtain known gene/transcript annotations 在本教程中，我们将仅对 22 号染色体使用从 Ensembl (homo_sapiens.grch38.86 . gtl .gz) 获得的注释。 wget http:&#x2F;&#x2F;genomedata.org&#x2F;rnaseq-tutorial&#x2F;annotations&#x2F;GRCh38&#x2F;chr22_with_ERCC92.gtf看看 gtf 文件的内容。按 “q” 退出 “less” 显示。 less -p start_codon -S chr22_with_ERCC92.gtf在 gtf 文件中有多少个基因 id ? 我们可以使用 perl 命令行命令来找出答案 perl -ne &#39;if ($_ &#x3D;~ &#x2F;(gene_id\\s\\&quot;ENSG\\w+\\&quot;)&#x2F;)&#123;print &quot;$1\\n&quot;&#125;&#39; chr22_with_ERCC92.gtf | sort | uniq | wc -l1318现在查看 GTF 格式的单个转录本的结构。完成后按 “q” 退出 “less” 显示。 grep ENST00000342247 chr22_with_ERCC92.gtf | less -p &quot;exon\\s&quot; -STo learn more, see: http://perldoc.perl.org/perlre.html#Regular-Expressions http://www.perl.com/pub/2004/08/09/commandline.html # 一些定义 参考基因组：一个物种的染色体的核苷酸序列。基因是参考基因组的功能单位，基因注释描述了从这些基因座表达的转录本的结构。 基因注释：生物名词对基因组的基因 / 转录模式的描述。转录本模型由参考基因组上转录本外显子的坐标组成。还可以提供其他信息，如生成转录本的链、基因名称、转录本的编码部分、替代转录本起始位点和其他信息。 GTF (. GTF) 文件：一种常见的文件格式，称为基因转移格式，用于存储基因和转录本注释信息。你可以在这里了解更多关于这个格式的信息:http://genome.ucsc.edu/FAQ/FAQformat#format4 # 基因注释的目的 (gtf 文件) 当运行 HISAT2/StringTie/Ballgown 流程时，已知的基因 / 转录注释被用于以下几个目的: 在 HISAT2 索引创建步骤中，可以提供注释来创建表示转录本的本地索引以及整个参考基因组的全局索引。这允许更快的映射和更好的映射跨外显子边界和剪接位点。如果仍然找不到对齐，它将尝试确定读是否对应一个新的外显子 - 外显子连接。有关更多细节，请参阅索引部分。 在 StringTie 步骤中，可以使用.gtf 文件指定转录模型，以指导组装过程，并使用 '-G' 和 '-e' 选项将表达估计限制为预定义的转录。“-e” 选项将为您的 gtf 文件中的每个转录本提供一个表达估计数，为您提供一个 “microarray like” 表达结果 在 StringTie 步骤中，如果指定了 '-G' 选项而没有指定 '-e' 选项，则 gtf 文件仅用于评估组装结果。不再假设只有已知的转录本模型是正确的，所得到的表达估计将与已知的和新的 / 预测的转录本相对应。 在 StringTie 和 gffcompare 步骤期间，将使用.gtf 文件来确定将使用 Ballgown 检查差异表达的转录本。这些可能是您从公共来源下载的已知记录，也可能是 StringTie 从前面的读取数据中预测的.gtf 的记录。 # 注释文件来源 ENSEMBL FTP SITE UCSC TABLE BROWSER HISAT2 Precomputed Genome Index # 注意事项 关于染色体命名的约定： 为了使 RNA-seq 分析工作，gtf 文件中的染色体名称必须与参考基因组 (即参考基因组 fasta 文件) 中的染色体名称相匹配。如果得到一个 StringTie 结果，其中所有转录本的表达式值都为 0，那么可能忽略了这一点。不幸的是，Ensembl、NCBI 和 UCSC 不能在许多物种的染色体命名上达成一致，因此这个问题可能经常出现。你可以通过从相同的来源 (例如，Ensembl) 获得一个完整的参考基因组和基因注释包来避免这种情况。 关于参考基因组构建： 您的注释必须与您的参考基因组 fasta 文件相同的参考基因组构建相对应。例如，两者都对应 UCSC 的 human build 'hg38'， NCBI 的 human build 'GRCh38' 等。即使你的参考基因组和注释都来自 UCSC 或 Ensembl，它们仍然可能对应于该基因组的不同版本。这将在任何 RNA-seq 管道中引起问题。","tags":"bioinformatics rnaseq"},{"title":"RNAseq教程(1.2)","url":"/2020/11/28/2020-11-28-RNAseq(2)/","text":"# 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 1.2 Reference Genomes 从 Ensembl、iGenomes、NCBI 或 UCSC 获得参考基因组。在本例分析中，我们将使用人 GRCh38 版本的 Ensembl 基因组。此外，我们实际上将只使用单个染色体 (chr22) 和 ERCC spikein 来执行分析，以使它运行得更快…… 创建必要的工作目录 mkdir RNA_ref这些 s 数据可以在 ftp://ftp.ensembl.org/pub/release-86/fasta/homo_sapiens/dna/ 找到。你可以使用 wget 下载 homo_sapien . grch38 .dna_sm.primary_assembly.fa.gz 文件，然后解压缩 / 解压。 cd RNA_refwget http:&#x2F;&#x2F;genomedata.org&#x2F;rnaseq-tutorial&#x2F;fasta&#x2F;GRCh38&#x2F;chr22_with_ERCC92.fals查看该文件的前 10 行。为什么会是这个样子 head chr22_with_ERCC92.fa这个文件中有多少行和字符？这条染色体有多长 (碱基和 Mbp) wc chr22_with_ERCC92.fa 848761 848764 51751056 chr22_with_ERCC92.fa查看大约从该文件中间开始的 10 行。大小写字符的意义是什么？ head -n 425000 chr22_with_ERCC92.fa | tailggaggctgaggcaggagaatcgcttgaacatgggaggtggaagttgcagtgagccgaaactgcgccattgcactatagcctgggcaacaagagtgaaagtctgtcttgaaaaaaaaaaaTCAGATGTTCTATGTAAAAATGCTATCTAtgattgaagtataaaactttacctccctttatgttcctttgccctccccactatttattattgtcttgattatatcttctatatgcattgagaggtgttataacttttgtatcaatcaccaaatttaatttagaaaatataagaggagaagaaaagtctattacatttactcatatttttgcttactgtgttctttcttccttcttgatgttccagaatttcttttattgcttcttttctgcttagaaaactttatctttttctttcatctttcttttttcctcctcctcctcctcctcctttttttttttttttttttttttttttttaataaagagacagggtctcactctatcacccagactggagttcagtgatgcaatcatagctcattgcaaccttgaactcctgggctcaagtgatcctcccacctcagcctcctgagtagctgg在整个参考基因组文件中每个碱基的计数是多少 (跳过每个序列的标题行)? cat chr22_with_ERCC92.fa | grep -v &quot;&gt;&quot; | perl -ne &#39;chomp $_; $bases&#123;$_&#125;++ for split &#x2F;&#x2F;; if (eof)&#123;print &quot;$_ $bases&#123;$_&#125;\\n&quot; for sort keys %bases&#125;&#39;A 4455938C 4406493G 4411768N 10710000T 4445994Y 1a 5950524c 4772185g 4853055n 948691t 5946575请记住引用序列 (染色体) 的名称必须与注释 gtf 文件 (在下一节中描述) 中匹配。 # 练习 2 22 号染色体上有多少个碱基对应于重复的元素？整个长度占的百分比是多少 cat chr22_with_ERCC92.fa | perl -ne &#39;if ($_ &#x3D;~ &#x2F;\\&gt;22&#x2F;)&#123;$chr22&#x3D;1&#125;; if ($_ &#x3D;~ &#x2F;\\&gt;ERCC&#x2F;)&#123;$chr22&#x3D;0&#125;; if ($chr22)&#123;print &quot;$_&quot;;&#125;&#39; &gt; chr22_only.facat chr22_only.fa | grep -v &quot;&gt;&quot; | perl -ne &#39;chomp $_; $r+&#x3D; $_ &#x3D;~ tr&#x2F;a&#x2F;A&#x2F;; $r +&#x3D; $_ &#x3D;~ tr&#x2F;c&#x2F;C&#x2F;; $r +&#x3D; $_ &#x3D;~ tr&#x2F;g&#x2F;G&#x2F;; $r +&#x3D; $_ &#x3D;~ tr&#x2F;t&#x2F;T&#x2F;; $l +&#x3D; length($_); if (eof)&#123;$p &#x3D; sprintf(&quot;%.2f&quot;, ($r&#x2F;$l)*100); print &quot;\\nrepeat bases &#x3D; $r\\ntotal bases &#x3D; $l\\npercent repeat bases &#x3D; $p%\\n\\n&quot;&#125;&#39;repeat bases &#x3D; 21522339total bases &#x3D; 50818468percent repeat bases &#x3D; 42.35%22 号染色体序列中出现多少个 EcoRI 限制位点？EcoRI 限制性内切酶识别序列为 5'- GAATTC -'3。 cat chr22_only.fa | grep -v &quot;&gt;&quot; | perl -ne &#39;chomp $_; $s &#x3D; uc($_); print $_;&#39; | perl -ne &#39;$c +&#x3D; $_ &#x3D;~ s&#x2F;GAATTC&#x2F;XXXXXX&#x2F;g; if (eof)&#123;print &quot;\\nEcoRI site (GAATTC) count &#x3D; $c\\n\\n&quot;;&#125;&#39;EcoRI site (GAATTC) count &#x3D; 3935","tags":"bioinformatics rnaseq"},{"title":"基因结构注释（4）：整合预测结果","url":"/2020/11/26/2020-11-26-annotion(4)/","text":"# 参考链接 如何对基因组进行注释 从头预测，同源注释和转录组整合都会得到一个预测结果，相当于收集了大量证据，下一步就是通过这些证据定义出更加可靠的基因结构，这一步可以通过人工排查，也可以使用 EVidenceModeler (EVM). EVM 对 gene_prediction.gff3 有特殊的要求，就是 GFF 文件需要反映出一个基因的结构，gene-&gt;(mRNA -&gt; (exon-&gt;cds (?))(+))(+), 表示一个基因可以有多个 mRNA，即基因的可变剪接，一个 mRNA 都可以由一个或者多个 exon (外显子), 外显子可以是非翻译区 (UTR), 也可以是编码区 (CDS). 而 GlimmerHMM, SNAP 等 这三类根据人为经验来确定其可信度，从直觉上就是用 PASA 根据 mRNA 得到的结果高于从头预测。 软件下载： wget -4 https:&#x2F;&#x2F;github.com&#x2F;EVidenceModeler&#x2F;EVidenceModeler&#x2F;archive&#x2F;v1.1.1.tar.gztar xf v1.1.1.tar.gz# 权重文件创建 首先将 EVM 文件夹下的 simple_example/weights.txt 复制到自己的目录 第一列是来源类型 (ABINITIO_PREDICTION, PROTEIN, TRANSCRIPT), 第二列对应着 GFF3 文件的第二列，第三列则是权重. 根据需要修改成自己的，用制表符分割 # EVM 运行 准备好权重文件后，可以运行 EVM 了 cat augustus.gff genemark.gff &gt; denovo.gffevidence_modeler.pl --genome genome.fa --weights weights.txt \\ --gene_predictions denovo.gff \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments \\ transcripts.fasta.transdecoder.genome.gff3 \\ &gt;evm.out最后生成的文件为 evm.out, 转为 gff3 格式 # 并行 EVM 主要是为了让整合结果更快一点 分割原始数据，用于后续并行. EvmUtils&#x2F;partition_EVM_inputs.pl --genome genome.fa \\ --gene_predictions denovo.gff3 \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments transcripts.fasta.transdecoder.genome.gff3 \\ --segmentSize 100000 --overlapSize 10000 \\ --partition_listing partitions_list.out创建并行运算命令并执行 EvmUtils&#x2F;write_EVM_commands.pl --genome genome.fa --weights &#96;pwd&#96;&#x2F;weights.txt \\ --gene_predictions denovo.gff3 \\ --protein_alignments proteinprediction.gff \\ --transcript_alignments transcripts.fasta.transdecoder.genome.gff3 \\ --output_file_name evm.out \\ --partitions partitions_list.out &gt; commands.listparallel --jobs 10 &lt; commands.list合并运行结果 EvmUtils&#x2F;recombine_EVM_partial_outputs.pl --partitions partitions_list.out \\ --output_file_name evm.out结果转成 gff3 EvmUtils&#x2F;convert_EVM_outputs_to_GFF3.pl --partitions partitions_list.out --output evm.out --genome genome.fafind . -regex &quot;.*evm.out.gff3&quot; -exec cat &#123;&#125; \\; | bedtools sort -i - &gt; EVM.all.gff# 基因过滤与命名 注释过滤：对于初步预测得到的基因，还可以稍微优化一下，例如剔除编码少于 50 个 AA 的预测结果，将转座子单独放到一个文件中 gffread EVM.all.gff -g input&#x2F;genome.fa -y tr_cds.fabioawk -c fastx &#39;$seq &lt; 50 &#123;print $comment&#125;&#39; tr_cds.fa | cut -d &#39;&#x3D;&#39; -f 2 &gt; short_aa_gene_list.txtgrep -v -w -f short_aa_gene_list.txt EvM.all.gff &gt; filter.gff 可以看到这个顺序还是不对，需要再排序，gene-&gt;mRNA-&gt;exon-&gt;CDS vi sort_EVM.pyimport sysimport refout &#x3D; open(sys.argv[3],&#39;w&#39;)ref_dict&#x3D;&#123;&#125;with open(sys.argv[1]) as gene_a: for line in gene_a: line_s &#x3D; line.strip().split(&#39;\\t&#39;) info &#x3D; re.split(&#39;&#x3D;|;&#39;,line_s[8]) ID &#x3D; info[1] ref_set &#x3D; [] for n in range(0,8): ref_set.append(line_s[n]) ref_dict.setdefault(ID,[]).append(ref_set) ref_dict.setdefault(ID,[]).append(info[3])with open(sys.argv[2]) as mrna: for eachline in mrna: i &#x3D; eachline.strip().split(&#39;\\t&#39;) info1 &#x3D; re.split(&#39;&#x3D;|;&#39;,i[8]) parent &#x3D; info1[3] mrna_n &#x3D; info1[1] ref_set1 &#x3D; [] for a in range(0,8): ref_set1.append(i[a]) mrna_h &#x3D; &#39;\\t&#39;.join(ref_set1) if parent in ref_dict: vs &#x3D; ref_dict[parent] head &#x3D; &#39;\\t&#39;.join(vs[0]) fout.write(&#39;%s\\tID&#x3D;%s;Name&#x3D;%s\\n&#39;%(head,parent,vs[1])) fout.write(&#39;%s\\tID&#x3D;%s;Parent&#x3D;%s;Name&#x3D;%s\\n&#39;%(mrna_h,mrna_n,parent,vs[1]))fout.close()phthon3 sort_EVM.py filter.gff filter.gff EVM_sort.gff接下来进行重命名 对每个基因实现编号，形如 ABCD000010 的效果，方便后续分析。如下代码是基于 EVM_sort.gff vi rename.py#!&#x2F;usr&#x2F;bin&#x2F;env python3import reimport sysif len(sys.argv) &lt; 3: sys.exit()gff &#x3D; open(sys.argv[1])prf &#x3D; sys.argv[2]count &#x3D; 0mRNA &#x3D; 0cds &#x3D; 0exon &#x3D; 0print(&quot;##gff-version 3.2.1&quot;)for line in gff: if not line.startswith(&quot;\\n&quot;): records &#x3D; line.split(&quot;\\t&quot;) records[1] &#x3D; &quot;.&quot; if re.search(r&quot;\\tgene\\t&quot;, line): count &#x3D; count + 10 mRNA &#x3D; 0 gene_id &#x3D; prf + str(count).zfill(6) records[8] &#x3D; &quot;ID&#x3D;&#123;&#125;&quot;.format(gene_id) elif re.search(r&quot;\\tmRNA\\t&quot;, line): cds &#x3D; 0 exon &#x3D; 0 mRNA &#x3D; mRNA + 1 mRNA_id &#x3D; gene_id + &quot;.&quot; + str(mRNA) records[8] &#x3D; &quot;ID&#x3D;&#123;&#125;;Parent&#x3D;&#123;&#125;&quot;.format(mRNA_id, gene_id) elif re.search(r&quot;\\texon\\t&quot;, line): exon &#x3D; exon + 1 exon_id &#x3D; mRNA_id + &quot;_exon_&quot; + str(exon) records[8] &#x3D; &quot;ID&#x3D;&#123;&#125;;Parent&#x3D;&#123;&#125;&quot;.format(exon_id, mRNA_id) elif re.search(r&quot;\\tCDS\\t&quot;, line): cds &#x3D; cds + 1 cds_id &#x3D; mRNA_id + &quot;_cds_&quot; + str(cds) records[8] &#x3D; &quot;ID&#x3D;&#123;&#125;;Parent&#x3D;&#123;&#125;&quot;.format(cds_id, mRNA_id) else: continue print(&quot;\\t&quot;.join(records))gff.close()gffrename.py EVM_sort.gff LH &gt; renamed.gff 完美成功 # 结语 接下来我将进行功能注释，目前想到的是用 Nr 库、Swiss-Prot（也可以用 TrEMBL，但 sp 要更可靠）、interproscan（包含了 Pfam 以及 GO）、KEGG 这四个基本的注释，对于真菌基因组，可能会再加上 COG、CAZyme、病毒相关因子 (PHI 数据库)、次生代谢基因 (AntiSMASH)。","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（3）：转录组注释","url":"/2020/11/24/2020-11-24-annotion(3)/","text":"对于 RNA-seq 数据，有两种使用策略，一种是使用 HISAT2 + StringTie 先比对再组装，一种是从头组装，然后使用 PASA 将转录本比对到基因组上。在本篇教程中，只使用有参组装 参考链接：如何对基因组注释 首先，使用 HISAT2 将 RNA-seq 数据比对到参考基因组，这一步和之前相似，但是要增加一个参数 --dta ，使得 StingTie 能更好的利用双端信息 hisat2-build LH.mask.fa index&#x2F;chi_masked ## 这个是屏蔽重复序列后的一个待发表基因组，与上两篇推文的基因组不一样hisat2 --dta -p 20 -x index&#x2F;chi_masked -1 1-1_R1.fastq -2 1-1_R2.fastq | samtools sort -@ 10 &gt; results&#x2F;1-1.bam &amp;hisat2 --dta -p 20 -x index&#x2F;chi_masked -1 1-2_R1.fastq -2 1-2_R2.fastq | samtools sort -@ 10 &gt; results&#x2F;1-2.bam &amp;hisat2 --dta -p 20 -x index&#x2F;chi_masked -1 1-3_R1.fastq -2 1-3_R2.fastq | samtools sort -@ 10 &gt; results&#x2F;1-3.bam &amp;samtools merge -@ 10 results&#x2F;merged.bam results&#x2F;1-1.bam results&#x2F;1-2.bam results&#x2F;1-3.bam然后用 StringTie 进行转录本预测 stringtie -p 10 -o results&#x2F;merged.gtf results&#x2F;merged.bam对于后续的 EvidenceModeler 而言，它不需要 UTR 信息，只需要编码区 CDS，需要用 TransDecoder 进行编码区预测 TransDecoder-TransDecoder-v5.5.0&#x2F;util&#x2F;gtf_genome_to_cdna_fasta.pl merged.gtf input&#x2F;chi_masked.fa &gt; transcripts.fastaTransDecoder-TransDecoder-v5.5.0&#x2F;util&#x2F;gtf_to_alignment_gff3.pl merged.gtf &gt; transcripts.gff3TransDecoder.LongOrfs -t transcripts.fastaTransDecoder.Predict -t transcripts.fastaTransDecoder-TransDecoder-v5.5.0&#x2F;util&#x2F;cdna_alignment_orf_to_genome_orf.pl \\ transcripts.fasta.transdecoder.gff3 \\ transcripts.gff3 \\ transcripts.fasta &gt; transcripts.fasta.transdecoder.genome.gff3最后结果 transcripts.fasta.transdecoder.genome.gff3 用于提供给 EvidenceModeler","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（2）：同源注释","url":"/2020/11/21/2020-11-21-annotion(2)/","text":"同源预测 (homology prediction) 利用近缘物种已知基因进行序列比对，找到同源序列。然后在同源序列的基础上，根据基因信号如剪切信号、基因起始和终止密码子对基因结构进行预测. 在同源预测上，目前看到的大部分基因组文章都是基于 TBLASTN + GeneWise, 但是目前 GeneWise 已经不在维护，在本次推文中将使用 GenomeThreader 进行同源注释。 参考链接：如何对基因组注释 # 确定同源物种蛋白序列 首先选择同源物种，在本次分析中，我使用 Saccharomyces_cerevisiae、Laccaria_bicolor、Amanita_thiersii、Pleurotus_pulmonarius、Pterula_gracilis 进行同源注释 cat Saccharomyces_cerevisiae.fa\\ Laccaria_bicolor.fa \\ Amanita_thiersii \\ Pleurotus_pulmonarius \\ Pterula_gracilis &gt;all.pep.fa然后使用 TBLASTN 确定匹配到基因组的蛋白序列 makeblastdb -in pudorinus.fa -parse_seqids -dbtype nucl -out index&#x2F;pu&amp;## tblastn 比对nohup tblastn -query all.pep.fa -out pu.blast -db index&#x2F;pu -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 &amp;## 提取匹配到基因组的蛋白序列awk &#39;&#123;print $1&#125;&#39; pu.blast &gt;pu.listsort pu.list| unique &gt;pi.ho.listseqkit seq all.pep.fa -w 0 &gt; all.favi sh.sh cat list.ru | while read line do grep &quot;$line&quot; -A 1 all.fa &gt;$line.1 done cat *.1 &gt; pudorinus.homo.fa rm -rf *.1使用 gth 进行同源注释 gth -genomic pudorinus.fa -protein pudorinus.homo.fa -intermediate -gff3out &gt; pudorinus.gff 删除一些无用的信息可以看到基本已经注释完成，但是 exon 之类的没有 ID，在后续识别会有问题 grep -v &quot;^#&quot; pudorinus.gth.gff | grep -v &quot;prime_cis_splice_site&quot; | awk -F &quot;;&quot; &#39;&#123;print$1&#125;&#39;&gt;pudorinus.homo.gffless pudorinus.homo.gff 使用脚本处理下 (谢谢课题组师姐帮忙写的脚本 (#.#)) #!&#x2F;lustre&#x2F;home&#x2F;guohan_lab&#x2F;local&#x2F;python-3.6&#x2F;bin&#x2F;python3#liyumei#.&#x2F;change-name_lym.py proteinprediction.gff proteinprediction.gff proteinprediction_r.gffimport sysimport refout &#x3D; open(sys.argv[3],&#39;w&#39;)ref_dict&#x3D;&#123;&#125;with open(sys.argv[1]) as gff: for line in gff: line_s &#x3D; line.strip().split(&#39;\\t&#39;) if &#39;gene&#39; &#x3D;&#x3D; line_s[2]: ref_g &#x3D; re.split(&#39;&#x3D;&#39;,line_s[8]) ref_gene &#x3D; ref_g[1] ref_dict[ref_gene]&#x3D;[] else: pos &#x3D; line_s[3] ref_dict[ref_gene].append(pos)with open(sys.argv[2]) as gff_r: for eachline in gff_r: i &#x3D; eachline.strip().split(&#39;\\t&#39;) info &#x3D; re.split(&#39;&#x3D;&#39;,i[8]) name &#x3D; info[1] ref_set &#x3D; [] for n in range(0,8): ref_set.append(i[n]) ref_list &#x3D; &#39;\\t&#39;.join(ref_set) ref_set1 &#x3D; [&#39;CDS&#39; if x &#x3D;&#x3D; &#39;exon&#39; else x for x in ref_set] ref_list1 &#x3D; &#39;\\t&#39;.join(ref_set1) if &#39;gene&#39; &#x3D;&#x3D; i[2]: fout.write(eachline) elif &#39;exon&#39; &#x3D;&#x3D; i[2]: if name in ref_dict: vs &#x3D; ref_dict[name] len_vs &#x3D; len(vs) for a in range(0,len_vs): if vs[a] &#x3D;&#x3D; i[3]: b &#x3D; vs.index(vs[a]) fout.write(&#39;%s\\tID&#x3D;%s.t%d;Parent&#x3D;%s\\n&#39;%(ref_list,name,b+1,name)) fout.write(&#39;%s\\tID&#x3D;%s.c%d;Parent&#x3D;%s\\n&#39;%(ref_list1,name,b+1,name))fout.close()python3 ..&#x2F;annotion&#x2F;change-gff_lym.py pudorinus.homo.gff pudorinus.homo.gff prediction.pudorinus.gff 至此同源注释已经结束","tags":"bioinformatics gene_annotion"},{"title":"基因结构注释（1）：从头注释","url":"/2020/11/19/2020-11-19-annotion(1)/","text":"# 前言 最近的推文将是一个大系列，目录就不放了，可能会有点多，主要涉及了基因注释，比较基因组学分析，基因家族分析等，大家看我博客的顺序就行。 基因注释参考链接 (不得不说州更大神真的是植物生信方面的专家了) 基因注释主要有三种策略 从头注释 (de novo prediction)：通过已有的概率模型来预测基因结构，在预测剪切位点和 UTR 区准确性较低 同源预测 (homology-based prediction)：有一些基因蛋白在相近物种间的保守型搞，所以可以使用已有的高质量近缘物种注释信息通过序列联配的方式确定外显子边界和剪切位点 基于转录组预测 (transcriptome-based prediction)：通过物种的 RNA-seq 数据辅助注释，能够较为准确的确定剪切位点和外显子区域。 每一种方法都有自己的优缺点，所以最后需要用 EvidenceModeler (EVM) 和 GLEAN 工具进行整合，合并成完整的基因结构。基于可靠的基因结构，后续可才是功能注释，蛋白功能域注释，基因本体论注释，通路注释等。 在注释之前需要对重复序列进行屏蔽，可以参考我之前的推文：repeatmasker 的安装与使用 # 从头注释 可以看到在该文献中从头注释使用的是 augustus 和 GlimmerHMM # augustus 根据已有模型训练 AUGUSTUS 的无 root 安装比较麻烦，我折腾了好几天最后卒，不过辛亏有 bioconda， conda create -n annotation augustus=3.3 我这次预测的基因是一种担子菌，可以使用 augustus --species=help 查看已有的物种，在本次分析中，我使用 laccaria_bicolor 作为已有的模型 (pudorinus.mask.fa 是去除重复序列的基因组序列) augustus --species&#x3D;laccaria_bicolor pudorinus.mask.fa &gt; pudorinus.gff如果嫌慢，可以试一下并行策略 seqkit split pudorinus.mask.fafind pudorinus.mask.fa.split&#x2F;-type f -name &quot;*.fa&quot; | parallel -j 30 augustus --species&#x3D;arabidopsis --gff3&#x3D;on &gt;&gt; temp.gff #并行处理join_aug_pred.pl &lt;temp.gff | grep -v &#39;^#&#39;&gt; temp.joined.gffbedtools sort -i temp.joined.gff &gt; pudorinus.augustus.gff# 无监督训练模型 GeneMark-ES/ET 则是唯一一款支持无监督训练模型，之后再识别真核基因组蛋白编码区的工具。 wget http:&#x2F;&#x2F;topaz.gatech.edu&#x2F;GeneMark&#x2F;tmp&#x2F;GMtool_Qg87n&#x2F;gm_et_linux_64.tar.gztar xf gm_et_linux_64.tar.gzmv gm_et_linux_64&#x2F;gmes_petap&#x2F; &#x2F;datadisk02&#x2F;softwget http:&#x2F;&#x2F;topaz.gatech.edu&#x2F;GeneMark&#x2F;tmp&#x2F;GMtool_Qg87n&#x2F;gm_key_64.gzgzip -dc gm_key_64.gz &gt; ~&#x2F;.gm_keycpan YAML Hash::Merge Logger::Simple Parallel::ForkManagerecho &quot;export PATH&#x3D;$PATH:&#x2F;datadisk02&#x2F;soft&#x2F;gmes_petap&#x2F;&quot; &gt;&gt; ~&#x2F;.bashrc安装之后进行预测 gmes_petap.pl --ES --sequence pudorinus.mask.fa --cores 50最后得到的是 genemark.gtf，是标准的 GTF 格式，可以使用 gffread 转换 gffread genemark.gtf -o- &gt; pudorinus.genemarkes.gff3从头注释已经完成，接下来的是同源与转录组。","tags":"bioinformatics gene_annotion"},{"title":"RNAseq教程(1.1)","url":"/2020/11/17/2020-11-17-RNAseq(1)/","text":"# 前言 本教程来自与我保存在 github 上的 RNAseq 教程 这是一个 RNA-seq 分析的教学教程和工作演示流程，包括介绍云计算 (不介绍了，直接从第二章开始)、下一代序列文件格式、参考基因组、基因注释、表达分析、差异表达分析、选择性剪接分析、数据可视化和解释。 # 目录 1.Module 1 - Introduction to RNA sequencing Installation Reference Genomes Annotations Indexing RNA-seq Data Pre-Alignment QC 2.Module 2 - RNA-seq Alignment and Visualization Adapter Trim Alignment IGV Alignment Visualization Alignment QC 3.Module 3 - Expression and Differential Expression Expression Differential Expression DE Visualization Kallisto for Reference-Free Abundance Estimation 4.Module 4 - Isoform Discovery and Alternative Expression Reference Guided Transcript Assembly de novo Transcript Assembly Transcript Assembly Merge Differential Splicing Splicing Visualization 5.Module 5 - De novo transcript reconstruction De novo RNA-Seq Assembly and Analysis Using Trinity 6.Module 6 - Functional Annotation of Transcripts Functional Annotation of Assembled Transcripts Using Trinotate # 软件安装（module 1： Installation） 分析所需的软件有:samtools, bamo -readcount, HISAT2, stringtie, gffcompare, htseq-count, flexbar, R, ballgown，fastqc 和 picard-tools。 设置软件安装位置: mkdir student_toolscd student_tools# SAMtools wget https:&#x2F;&#x2F;github.com&#x2F;samtools&#x2F;samtools&#x2F;releases&#x2F;download&#x2F;1.9&#x2F;samtools-1.9.tar.bz2bunzip2 samtools-1.9.tar.bz2tar -xvf samtools-1.9.tarcd samtools-1.9make.&#x2F;samtools# bam-readcount export SAMTOOLS_ROOT&#x3D;$RNA_HOME&#x2F;student_tools&#x2F;samtools-1.9git clone https:&#x2F;&#x2F;github.com&#x2F;genome&#x2F;bam-readcount.gitcd bam-readcountcmake -Wno-dev $RNA_HOME&#x2F;student_tools&#x2F;bam-readcountmake.&#x2F;bin&#x2F;bam-readcount# HISAT2 wget ftp:&#x2F;&#x2F;ftp.ccb.jhu.edu&#x2F;pub&#x2F;infphilo&#x2F;hisat2&#x2F;downloads&#x2F;hisat2-2.1.0-Linux_x86_64.zipunzip hisat2-2.1.0-Linux_x86_64.zipcd hisat2-2.1.0.&#x2F;hisat2# StringTie wget http:&#x2F;&#x2F;ccb.jhu.edu&#x2F;software&#x2F;stringtie&#x2F;dl&#x2F;stringtie-1.3.4d.Linux_x86_64.tar.gztar -xzvf stringtie-1.3.4d.Linux_x86_64.tar.gzcd stringtie-1.3.4d.Linux_x86_64.&#x2F;stringtie# gffcompare wget http:&#x2F;&#x2F;ccb.jhu.edu&#x2F;software&#x2F;stringtie&#x2F;dl&#x2F;gffcompare-0.10.6.Linux_x86_64.tar.gztar -xzvf gffcompare-0.10.6.Linux_x86_64.tar.gzcd gffcompare-0.10.6.Linux_x86_64.&#x2F;gffcompare# htseq-count wget https:&#x2F;&#x2F;github.com&#x2F;simon-anders&#x2F;htseq&#x2F;archive&#x2F;release_0.11.0.tar.gztar -zxvf release_0.11.0.tar.gzcd htseq-release_0.11.0&#x2F;python setup.py install --userchmod +x scripts&#x2F;htseq-count.&#x2F;scripts&#x2F;htseq-count# TopHat wget https:&#x2F;&#x2F;ccb.jhu.edu&#x2F;software&#x2F;tophat&#x2F;downloads&#x2F;tophat-2.1.1.Linux_x86_64.tar.gztar -zxvf tophat-2.1.1.Linux_x86_64.tar.gzcd tophat-2.1.1.Linux_x86_64&#x2F;.&#x2F;gtf_to_fasta# kallisto wget https:&#x2F;&#x2F;github.com&#x2F;pachterlab&#x2F;kallisto&#x2F;releases&#x2F;download&#x2F;v0.44.0&#x2F;kallisto_linux-v0.44.0.tar.gztar -zxvf kallisto_linux-v0.44.0.tar.gzcd kallisto_linux-v0.44.0&#x2F;.&#x2F;kallisto# FastQC wget https:&#x2F;&#x2F;www.bioinformatics.babraham.ac.uk&#x2F;projects&#x2F;fastqc&#x2F;fastqc_v0.11.8.zip --no-check-certificateunzip fastqc_v0.11.8.zipcd FastQC&#x2F;chmod 755 fastqc.&#x2F;fastqc --help# MultiQC pip3 install multiqcmultiqc --help# Picard wget https:&#x2F;&#x2F;github.com&#x2F;broadinstitute&#x2F;picard&#x2F;releases&#x2F;download&#x2F;2.18.15&#x2F;picard.jar -O picard.jarjava -jar $RNA_HOME&#x2F;student_tools&#x2F;picard.jar# Flexbar wget https:&#x2F;&#x2F;github.com&#x2F;seqan&#x2F;flexbar&#x2F;releases&#x2F;download&#x2F;v3.4.0&#x2F;flexbar-3.4.0-linux.tar.gztar -xzvf flexbar-3.4.0-linux.tar.gzcd flexbar-3.4.0-linux&#x2F;export LD_LIBRARY_PATH&#x3D;$RNA_HOME&#x2F;student_tools&#x2F;flexbar-3.4.0-linux:$LD_LIBRARY_PATH.&#x2F;flexbar# Regtools git clone https:&#x2F;&#x2F;github.com&#x2F;griffithlab&#x2F;regtoolscd regtools&#x2F;mkdir buildcd build&#x2F;cmake ..make.&#x2F;regtools# RSeQC pip install RSeQCread_GC.py# R Libraries #install.packages(c(&quot;devtools&quot;,&quot;dplyr&quot;,&quot;gplots&quot;,&quot;ggplot2&quot;),repos&#x3D;&quot;http:&#x2F;&#x2F;cran.us.r-project.org&quot;)#quit(save&#x3D;&quot;no&quot;)# Bioconductor #source(&quot;http:&#x2F;&#x2F;bioconductor.org&#x2F;biocLite.R&quot;)#biocLite(c(&quot;genefilter&quot;,&quot;ballgown&quot;,&quot;edgeR&quot;,&quot;GenomicRanges&quot;,&quot;rhdf5&quot;,&quot;biomaRt&quot;))#quit(save&#x3D;&quot;no&quot;)# Sleuth #install.packages(&quot;devtools&quot;)#devtools::install_github(&quot;pachterlab&#x2F;sleuth&quot;)#quit(save&#x3D;&quot;no&quot;)# 练习 在 student_tools 下安装 bedtools，并编译和测试","tags":"bioinformatics rnaseq"},{"title":"RNA速率：使用Seurat的结果做RNA velocity","url":"/2020/11/14/2020-11-14-RNAvelocity(3)/","text":"参考链接: https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.cnblogs.com/raisok/p/12425258.html # 目录 RNA 速率：软件下载与 loom 文件准备 RNA 速率：数据读入 RNA 速率：使用 Seurat 的结果做 RNA velocity # 导入 Seurat 以及 loom 对象 &gt;library (Seurat)## remotes::install_github (&#39;satijalab&#x2F;seurat-wrappers&#39;)&gt;library (SeuratWrappers)## 导入 Seurat 对象，之前分析的结果&gt;load (&quot;wang.rds&quot;)&gt;load (&#39;wang-loom.rds&#39;)# 统一 loom 对象和 Seurat 的细胞名与基因名 &gt; wt$spliced[1:3,1:3]3 x 3 sparse Matrix of class &quot;dgCMatrix&quot; WANG:AAAGTAGAGATGTTAGx WANG:AAACCTGTCAGCATGTx WANG:AAAGCAACATTTGCTTxAT1G01020 . . .AT1G01030 . . .AT1G03993 . . .&gt; wang@meta.data[1:3,1:3] orig.ident nCount_RNA nFeature_RNAAAACCTGAGAATTCCC-1 zxz 3756 2158AAACCTGAGGGCACTA-1 zxz 2774 1669AAACCTGAGTAATCCC-1 zxz 2463 1290&gt; colnames(wt$spliced)&lt;-gsub(&quot;x&quot;,&quot;-1&quot;,colnames(wt$spliced))&gt; colnames(wt$spliced)&lt;-gsub(&quot;WANG:&quot;,&quot;&quot;,colnames(wt$spliced))&gt; colnames(wt$unspliced)&lt;-colnames(wt$spliced)&gt; colnames(wt$ambiguous)&lt;-colnames(wt$spliced)# 计算 velocity 提取 spliced 与 unspliced 文件，并提取原有的 Seurat 的 UAMP 图 ## 由于 Seurat 的对象筛选了数据，所以两个文件细胞并不相同，以 Seurat 对象为准&gt; wt$spliced&lt;-wt$spliced [,rownames (wang@meta.data)]&gt; wt$unspliced&lt;-wt$unspliced [,rownames (wang@meta.data)]&gt; wt$ambiguous&lt;-wt$ambiguous [,rownames (wang@meta.data)]&gt; sp &lt;- wt$spliced&gt; unsp &lt;- wt$unspliced&gt; WTumap &lt;- wang@reductions$umap@cell.embeddings## 估计细胞和细胞的距离&gt; cell.dist &lt;- as.dist (1-armaCor (t (wang@reductions$umap@cell.embeddings)))&gt; fit.quantile &lt;- 0.02&gt; rvel.cd &lt;- gene.relative.velocity.estimates (sp,unsp,deltaT&#x3D;2,kCells&#x3D;10, cell.dist&#x3D;cell.dist,fit.quantile&#x3D;fit.quantile,n.cores&#x3D;24)# 在 UMAP 聚类图上绘制 RNA velocity library(ggplot2)pdf(&quot;cell_velocity.pdf&quot;,height&#x3D;6,width&#x3D;8)gg &lt;- UMAPPlot(wang)ggplot_build(gg)$datacolors &lt;- as.list(ggplot_build(gg)$data[[1]]$colour)names(colors) &lt;- rownames(WTumap)p1 &lt;- show.velocity.on.embedding.cor(WTumap,rvel.cd,n&#x3D;30,scale&#x3D;&#39;sqrt&#39;,cell.colors&#x3D;ac(colors,alpha&#x3D;0.5),cex&#x3D;0.8,arrow.scale&#x3D;2,show.grid.flow&#x3D;T,min.grid.cell.mass&#x3D;1.0,grid.n&#x3D;50,arrow.lwd&#x3D;1,do.par&#x3D;F,cell.border.alpha &#x3D;0.1,USE_OPENMP&#x3D;1,n.cores&#x3D;24,main&#x3D;&quot;Cell Velocity&quot;)dev.off() 这结果根本看不出啥啊，我选 RC 试试 id&lt;-c (&#39;2&#39;,&#39;3&#39;,&#39;19&#39;,&#39;20&#39;)Cell.sub &lt;- subset (wang@meta.data,seurat_clusters&#x3D;&#x3D;id)scRNAsub &lt;- subset (wang, cells&#x3D;row.names (Cell.sub))## 后续的操作相同 倒是有个轨迹，但是并不明显 换成 cluster12.14.19 试试 这一次就有一个明显的轨迹了 总体来讲，感觉植物做 RNA velocity 的结果并没有动物的那么好，是自己分析的问题还是其他原因有待商榷。","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"RNA速率：数据读入","url":"/2020/11/12/2020-11-12-RNAvelocity(2)/","text":"参考链接: https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.cnblogs.com/raisok/p/12425258.html # 目录 RNA 速率：软件下载与 loom 文件准备 RNA 速率：数据读入 RNA 速率：使用 Seurat 的结果做 RNA velocity # velocyto.R 的安装 loom 文件生成后，接下来将使用 velocyto.R 对 loom 文件进行分析 library(devtools)install_github(&quot;velocyto-team&#x2F;velocyto.R&quot;)# 数据读入 &gt;library (velocyto.R)&gt;setwd (&quot;&#x2F;datadisk02&#x2F;Jiawei_Wang_2019&quot;)&gt;wt&lt;-read.loom.matrices (&quot;WANG&#x2F;velocyto&#x2F;WANG.loom&quot;)reading loom file via hdf5r...&gt;str (wt1)List of 3 $ spliced :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots $ unspliced:Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots $ ambiguous:Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots&gt;save (wt,file&#x3D;&quot;WT-loom.rds&quot;)&gt;emat&lt;-WT$spliced# 做直方图查看数据分步&gt;hist (log10 (colSums (emat)),col&#x3D;&#39;wheat&#39;,xlab&#x3D;&#39;cell size&#39;) 后续过程我想用 Seurat 的聚类进行分析，所以 velocyto.R 的聚类就不运行了","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"RNA速率：软件下载与loom文件准备","url":"/2020/11/10/2020-11-10-RNAvelocity(1)/","text":"参考链接: https://github.com/velocyto-team/velocyto.R http://velocyto.org/velocyto.py/index.html http://pklab.med.harvard.edu/velocyto/notebooks/R/chromaffin2.nb.html https://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/velocity.html https://github.com/velocyto-team/velocyto.R/issues/16 https://www.jianshu.com/p/bce19672879e # 目录 RNA 速率：软件下载与 loom 文件准备 RNA 速率：数据读入 RNA 速率：使用 Seurat 的结果做 RNA velocity # velocyto 下载 首先是下载 velocyto 生成 loom 文件 ## 1. 创建 python&gt;3.6 的环境conda create -n velocyto python&#x3D;3.6## 2. 安装前置软件conda install numpy scipy cython numba matplotlib scikit-learn h5py clickpip install pysam## 3. 安装 velocytopip install velocyto## 4. 测试velocyto --helpUsage: velocyto [OPTIONS] COMMAND [ARGS]...Options: --version Show the version and exit. --help Show this message and exit.Commands: run Runs the velocity analysis outputting a loom file run10x Runs the velocity analysis for a Chromium Sample run-dropest Runs the velocity analysis on DropEst preprocessed data run-smartseq2 Runs the velocity analysis on SmartSeq2 data (independent bam file per cell) tools helper tools for velocyto# repeat_masker.gtf 生成 运行 velocyto 需要准备三个文件，单细胞数据分析的结果文件，基因组注释文件，重复序列注释文件，其中前两个在单细胞分析时就会得到，关键是这个 repeat_masker.gtf 本人是做植物的，所以本次教程主要关注植物类 repeat_masker.gtf 的获得，人和小鼠的重复序列文件比较好得到，植物类首先可以看一下 Phtozome 数据库上想要研究的物种的注释文件夹下有没有 reapeat.gtf，没有就要我们自己生成了 重复序列的注释文件我们一直没怎么关注过，对于做过基因组注释的童鞋来说，大家都忽略了一步，其实 repeatmasker 就可以生成重复序列的注释文件。 RepeatMasker -e ncbi -species arabidopsis -pa 40 -gff TAIR10.fa生成 gff 文件后，可以看到重复序列的点位以及属性，velocyto 主要使用的就是位点 # loom 文件生成 接下来是生成 loom 文件，运行 velocyto 需要准备三个文件，基因组注释文件 (gtf)，repeat_masker.gtf (重复序列注释文件)，cellranger 的结果文件夹 (以样本名 WT_1 为例，里面包含 cell matrix 和 bam 文件) velocyto -m TAIR10_masked.gtf WANG&#x2F; TAIR10.gtf运行结束后会在 WANG 文件夹下生成 velocyto 文件夹，里面有 velocyto.loom 的文件，可以用于下一步的分析","tags":"bioinformatics scrnaseq rna_velocity"},{"title":"生信技能树单细胞数据挖掘笔记(7)","url":"/2020/11/07/2020-11-07-ScRNAseq(13)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # 3、根据 count 矩阵转换 fpkm 并完成差异分析 # 3.1 导入 count 矩阵 nm_COUNT &lt;- read.csv(&quot;GSE81861_CRC_NM_epithelial_cells_COUNT.csv&#x2F;GSE81861_CRC_NM_epithelial_cells_COUNT.csv&quot;)nm_COUNT &lt;- data_input(nm_COUNT)nm_COUNT[1:4,1:4]dim(nm_COUNT)tumor_COUNT &lt;- read.csv(&quot;GSE81861_CRC_tumor_epithelial_cells_COUNT.csv&#x2F;GSE81861_CRC_tumor_epithelial_cells_COUNT.csv&quot;)tumor_COUNT &lt;- data_input(tumor_COUNT)tumor_COUNT[1:4,1:4]dim(tumor_COUNT) RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0 428 66 141ENSG00000000005 0 0 0 0ENSG00000000419 0 179 0 1ENSG00000000457 465 0 0 0[1] 56380 160 RHC4075 RHC5563 RHC5552 RHC4874ENSG00000000003 0 0 0 0ENSG00000000005 0 0 0 0ENSG00000000419 0 0 0 0ENSG00000000457 0 133 0 0[1] 56380 272# 3.2 计算 fpkm 矩阵 my_FPKM &lt;- function (counts,g_l)&#123; #### 根据有基因长度的基因，筛选矩阵子集 #counts&#x3D;nm_COUNT ng&#x3D;intersect (rownames (counts),g_l$ensembl_id) length (ng) lengths&#x3D;g_l [match (ng,g_l$ensembl_id),2] names (lengths) &lt;- g_l [match (ng,g_l$ensembl_id),1] head (lengths) #### 计算样本文库大小，以及最后的 fpkm 计算 counts &lt;- counts [names (lengths),] counts [1:4,1:4] total_count &lt;- colSums (counts) head (total_count) #根据 counts、length、total_count 计算 fpkm FPKM &lt;- t (do.call ( rbind, lapply (1:length (total_count), function (i)&#123; 10^9*counts [,i]&#x2F;lengths&#x2F;total_count [i] #lengths 向量自动遍历 &#125;) )) FPKM [1:4,1:4] return (FPKM)&#125;nm_my_FPKM &lt;- my_FPKM (counts &#x3D; nm_COUNT, g_l &#x3D; g_l)colnames (nm_my_FPKM) &lt;- colnames (nm_COUNT)nm_my_FPKM [1:4,1:4]dim (nm_my_FPKM)tumor_my_FPKM &lt;- my_FPKM (counts &#x3D; tumor_COUNT, g_l &#x3D; g_l)dim (tumor_FPKM)colnames (tumor_my_FPKM) &lt;- colnames (tumor_COUNT)nm_my_FPKM [1:4,1:4] RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000[1] 50813 160[1] 56380 272 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000# 3.3 差异分析 exp_my_FPKM &lt;- cbind (nm_my_FPKM,tumor_my_FPKM)dim (exp_my_FPKM) #转换 id 前exp_my_FPKM [1:4,1:4] #转换 id 前exp_my_FPKM &lt;- id_change (exp_my_FPKM)dim (exp_my_FPKM) #转换 id 后exp_my_FPKM [1:4,1:4] #转换 id 后my_FPKM_diff &lt;- scRNA_deg (exp&#x3D;exp_my_FPKM, group&#x3D;group_dat)head (my_FPKM_diff)dim (my_FPKM_diff)my_FPKM_diff &lt;- my_FPKM_diff [my_FPKM_diff$p_val&lt;0.01 &amp; abs (my_FPKM_diff$avg_logFC)&gt;0.8,]dim (my_FPKM_diff)exp_my_FPKM_diff &lt;- exp_my_FPKM [match (rownames (my_FPKM_diff),rownames (exp_my_FPKM)),][1] 50813 432 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.0000 160.5715 168.6839 22.7021034ENSG00000000005 0.0000 0.0000 0.0000 0.0000000ENSG00000000419 0.0000 219.5694 0.0000 0.5264304ENSG00000000457 124.2016 0.0000 0.0000 0.0000000[1] 50813 432[1] 24931 432[1] 24931 432 RHC4104 RHC6087 RHL2880 RHC5949TSPAN6 0.0000 160.5715 168.6839 22.7021034TNMD 0.0000 0.0000 0.0000 0.0000000DPM1 0.0000 219.5694 0.0000 0.5264304SCYL3 124.2016 0.0000 0.0000 0.0000000[1] &quot;创建 seurat 对象...&quot;[1] &quot;质控...&quot;[1] &quot;归一化...&quot;Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|[1] &quot;差异分析...&quot; |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed&#x3D;04s [1] 1231 5[1] 112 5# 3.4 可视化 热图 my_heatmap(exp_my_FPKM_diff) 箱图","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(6)","url":"/2020/11/05/2020-11-05-ScRNAseq(12)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) 前言：使用 GSE81861 提供的数据，比较 CRC 肿瘤上皮细胞与正常上皮细胞的差异。GEO 提供了 count 与 fpkm 两种数据。笔记内容先用官方的 fpkm 数据做差异分析，再利用 counts 数据手动计算 fpkm 矩阵，完成差异分析。最后比较两种方法的结果是否存在差异。 https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE81861 注：因为有不少重复的步骤，故设置较多的函数。 # 1、概述 # 1.1 单细胞差异分析 pipeline 简单来说分为三步：首先导入、制备规范的表达矩阵以及分组信息；然后利用 Seurat 包构建 seurat 对象，归一化；最后进行差异分析，以及结果的可视化。 # 1.2 count 标准化 主要受测序文库 (样本总 read 数) 与基因长度的影响，测序的 counts 数据不能直接进行差异分析，需要进行标准化处理。常见的几种标准化方法简单介绍如下 -- rpkm：counts 先对测序文库标准化，再对基因长度标准化； fpkm：FPKM 同 RPKM 是一样的，只是 RPKM 用于单末端测序，而 FPKM 用于双末端测序； tpm：counts 先对基因长度标准化，再对测序文库标准化； cpm：counts 只对测序文库标准化。 测序文库相对容易计算，直接使用 colSums() 函数即可；而基因长度则比较难求，首先要了解基因长度有不同的定义标准，其次要知道哪些 R 包提供相关生物数据。目前有以下三种方法，以及根据与官方 fpkm 验证，最终选择第三种方法用于后续的分析。 # 计算基因长度 # (1) TxDb.Hsapiens.UCSC.hg19.knownGene 包 if (!require(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;, quietly &#x3D; TRUE)) BiocManager::install(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;)library(TxDb.Hsapiens.UCSC.hg19.knownGene)txdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGeneexon_txdb&#x3D;exons(txdb)genes_txdb&#x3D;genes(txdb)# g_l.1-- 根据非冗余外显子之和定义 g_l_1 &lt;- function ()&#123; o &lt;- findOverlaps (exon_txdb,genes_txdb) t1&#x3D;exon_txdb [queryHits (o)] t2&#x3D;genes_txdb [subjectHits (o)] t1&#x3D;as.data.frame (t1) t1$geneid&#x3D;mcols (t2)[,1] # 得到 exon_id 与 geneid 的对应关系 g_l.1 &lt;- lapply (split (t1,t1$geneid),function (x)&#123; #按 gene id 拆分表格 head (x) tmp&#x3D;apply (x,1,function (y)&#123; y [2]:y [3] &#125;) #根据每一个 gene 所有 exon 的区间，生成区间内的整数，返回的为 list。 length (unique (unlist (tmp))) #计算共有多少种整数，即为最终的非冗余 exon 长度之和 &#125;) head (g_l.1) #为一个 list g_l.1&#x3D;data.frame (gene_id&#x3D;names (g_l.1),length&#x3D;as.numeric (g_l.1)) dim (g_l.1) head (g_l.1) #为基因 ID 增添 ENSEMBLE ID if (!require (&quot;org.Hs.eg.db&quot;, quietly &#x3D; TRUE)) BiocManager::install (&quot;org.Hs.eg.db&quot;) library (org.Hs.eg.db) s2g&#x3D;toTable (org.Hs.egENSEMBL) head (s2g) g_l.1&#x3D;merge (g_l.1,s2g,by&#x3D;&#39;gene_id&#39;) #把 g_l,s2g 两个数据框以 &#39;gene_id&#39; 为连接进行拼接 head (g_l.1) return (g_l.1)&#125;g_l.1 &lt;- g_l_1 ()head (g_l.1)# g_l.2---- 根据最长转录本定义 g_l_2 &lt;- function ()&#123; t_l&#x3D;transcriptLengths (txdb) head (t_l) t_l&#x3D;na.omit (t_l) #先按基因 ID，再按转录本长度从大到小排序 t_l&#x3D;t_l [order (t_l$gene_id,t_l$tx_len,decreasing &#x3D; T),] head (t_l);dim (t_l) #根据 gene_id 去重，选择第一个，也就是最长的那个 t_l&#x3D;t_l [!duplicated (t_l$gene_id),] head (t_l);dim (t_l) g_l.2&#x3D;t_l [,c (3,5)] library (org.Hs.eg.db) s2g&#x3D;toTable (org.Hs.egENSEMBL) g_l.2&#x3D;merge (g_l.2,s2g,by&#x3D;&#39;gene_id&#39;) head (g_l.2) return (g_l.2)&#125;g_l.2 &lt;- g_l_2 ()head (g_l.2)# (2) biomaRt 包 # g_l.3-- 根据最长转录本定义 g_l_3 &lt;- function ()&#123; if (!require (&quot;biomaRt&quot;, quietly &#x3D; TRUE)) BiocManager::install (&quot;biomaRt&quot;) library (biomaRt) ensembl &lt;- useMart (&quot;ensembl&quot;) #connect to a specified BioMart database ensembl &#x3D; useDataset (&quot;hsapiens_gene_ensembl&quot;,mart&#x3D;ensembl) #use the hsapiens (人类) dataset. 或者直接如下设置 #ensembl &#x3D; useMart (&quot;ensembl&quot;,dataset&#x3D;&quot;hsapiens_gene_ensembl&quot;) #BiocManager::install (&#39;grimbough&#x2F;biomaRt&#39;) #library (biomaRt) #packageVersion (&#39;biomaRt&#39;) test &lt;- getBM (attributes&#x3D;c (&#39;ensembl_gene_id&#39;, &#39;start_position&#39;, &#39;end_position&#39;,&#39;ensembl_transcript_id&#39;, &#39;transcript_length&#39;), mart &#x3D; ensembl) test &lt;- test [order (test$ensembl_gene_id,test$transcript_length, decreasing &#x3D; T),] g_l.3 &lt;- test [!duplicated (test$ensembl_gene_id),] g_l.3 &lt;- g_l.3 [,c (1,5)] head (g_l.3) return (g_l.3)&#125;g_l.3 &lt;- g_l_3 ()# 比较三种结果的差异 dim (g_l.1);dim (g_l.2);dim (g_l.3)g_l.1 &lt;- g_l.1 [,-1]colnames (g_l.1) &lt;- c (&quot;g_l.1&quot;,&quot;ensembl_id&quot;)g_l.2 &lt;- g_l.2 [,-1]colnames (g_l.2) &lt;- c (&quot;g_l.2&quot;,&quot;ensembl_id&quot;)colnames (g_l.3) &lt;- c (&quot;ensembl_id&quot;,&quot;g_l.3&quot;)g_l_all &lt;- merge (g_l.1, g_l.2, by&#x3D;&quot;ensembl_id&quot;)g_l_all &lt;- merge (g_l_all, g_l.3, by&#x3D;&quot;ensembl_id&quot;)head (g_l_all,10)summary (g_l_all)# 最终选择第三种结果，即 biomaR 包g_l &lt;- g_l.3# 2. 官方 fpkm 数据差异分析 # 2.1 表达矩阵与分组信息 #表达矩阵nm_FPKM &lt;- read.csv (&quot;GSE81861_CRC_NM_epithelial_cells_FPKM.csv&#x2F;GSE81861_CRC_NM_epithelial_cells_FPKM.csv&quot;)data_input &lt;- function (data)&#123; #data &lt;- nm_FPKM row.names (data) &lt;- data [,1] data &lt;- data [,-1] data &lt;- as.matrix (data) rownames (data) &lt;- sapply (strsplit (rownames (data),&quot;_&quot;),&quot;[&quot;,3) rownames (data) &lt;- sapply (strsplit (rownames (data),&quot;[.]&quot;),&quot;[&quot;,1) colnames (data) &lt;- sapply (strsplit (colnames (data),&quot;_&quot;),&quot;[&quot;,1) data &lt;- data [grep (&quot;ENSG&quot;,rownames (data)),] return (data)&#125;nm_FPKM &lt;- data_input (nm_FPKM)dim (nm_FPKM) #56380 个基因 #160 个样本nm_FPKM [1:4,1:4]tumor_FPKM &lt;- read.csv (&quot;GSE81861_CRC_tumor_epithelial_cells_FPKM.csv&#x2F;GSE81861_CRC_tumor_epithelial_cells_FPKM.csv&quot;)tumor_FPKM &lt;- data_input (tumor_FPKM)tumor_FPKM [1:4,1:4]dim (tumor_FPKM)#56380 个基因 #272 个样本exp_FPKM &lt;- cbind (nm_FPKM,tumor_FPKM)dim (exp_FPKM) # 56380 个基因 432 个样本# 分组信息group_dat &lt;- data.frame (group&#x3D;c (rep (&#39;normal&#39;,160), rep (&#39;tumor&#39;,272)), row.names &#x3D; colnames (exp_FPKM))[1] 56380 160 RHC4104 RHC6087 RHL2880 RHC5949ENSG00000000003 0.000 185.315 323.203 22.311700ENSG00000000005 0.000 0.000 0.000 0.000000ENSG00000000419 0.000 231.756 0.000 0.851514ENSG00000000457 100.135 0.000 0.000 0.000000 RHC4075 RHC5563 RHC5552 RHC4874ENSG00000000003 0 0.000 0 0ENSG00000000005 0 0.000 0 0ENSG00000000419 0 0.000 0 0ENSG00000000457 0 193.167 0 0[1] 56380 272[1] 56380 432# 2.2 ID 转换 因为 seurat 质控需要过滤线粒体基因，所以需要把 ensembl ID 转换为 symbol ID exp_FPKM [1:4,1:4]id_change &lt;- function (data)&#123; print (dim (data)) library (org.Hs.eg.db) ids1 &lt;- data.frame (ID&#x3D;c (1:nrow (data)), ensembl_id&#x3D;rownames (data)) ids2 &lt;- merge (toTable (org.Hs.egENSEMBL), toTable (org.Hs.egSYMBOL),by&#x3D;&quot;gene_id&quot;) ids &lt;- merge (ids1, ids2, by&#x3D;&quot;ensembl_id&quot;) data &lt;- data [ids$ID,] rownames (data) &lt;- ids$symbol print (dim (data)) return (data)&#125;exp_FPKM &lt;- id_change (exp_FPKM) #有 2w + 个 ensembl ID 没配对到 symbolexp_FPKM [1:4,1:4]# 2.3 创建 seurat，质控，差异分析一键操作 scRNA_deg &lt;- function (exp,group)&#123; library (Seurat) print (&quot;创建 seurat 对象...&quot;) scRNA &lt;- CreateSeuratObject (counts&#x3D;exp, meta.data&#x3D;group) print (&quot;质控...&quot;) scRNA [[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet (scRNA, pattern &#x3D; &quot;^MT-&quot;) minGene&#x3D;500;maxGene&#x3D;4000;pctMT&#x3D;15 scRNA &lt;- subset (scRNA, subset &#x3D; nFeature_RNA &gt; minGene &amp; nFeature_RNA &lt; maxGene &amp; percent.mt &lt; pctMT) print (&quot;归一化...&quot;) scRNA &lt;- NormalizeData (scRNA, normalization.method &#x3D; &quot;LogNormalize&quot;, scale.factor &#x3D; 10000) print (&quot;差异分析...&quot;) diff_dat &lt;- FindMarkers (scRNA,ident.1&#x3D;&quot;normal&quot;,ident.2&#x3D;&quot;tumor&quot;, group.by&#x3D;&#39;group&#39;)&#125;FPKM_diff &lt;- scRNA_deg (exp&#x3D;exp_FPKM, group&#x3D;group_dat)head (FPKM_diff)dim (FPKM_diff)FPKM_diff &lt;- FPKM_diff [FPKM_diff$p_val&lt;0.01 &amp; abs (FPKM_diff$avg_logFC)&gt;0.8,]dim (FPKM_diff)exp_FPKM_diff &lt;- exp_FPKM [match (rownames (FPKM_diff),rownames (exp_FPKM)),][1] &quot;创建 seurat 对象...&quot;[1] &quot;质控...&quot;[1] &quot;归一化...&quot;Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|[1] &quot;差异分析...&quot; |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed&#x3D;04s [1] 1455 5[1] 119 5# 2.4 差异结果可视化 热图 my_heatmap &lt;- function(exp_dat)&#123; n &lt;- t(scale(t(exp_dat))) n[n&gt;2]&#x3D;2;n[n&lt; -2]&#x3D; -2 library(pheatmap) pheatmap(n, show_rownames &#x3D; F, show_colnames &#x3D; F, annotation_col &#x3D; group_dat)&#125;p.exp_FPKM_diff &lt;- my_heatmap(exp_FPKM_diff)p.exp_FPKM_diff 箱图","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(5)","url":"/2020/11/03/2020-11-03-ScRNAseq(11)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # 轨迹分析 通过构建细胞间的变化轨迹来重塑细胞随时间的变化过程。 ##4、拟时轨迹分析 ----library (monocle)data &lt;- as (as.matrix (scRNA@assays$RNA@counts), &#39;sparseMatrix&#39;)# count 矩阵pd &lt;- new (&#39;AnnotatedDataFrame&#39;, data &#x3D; scRNA@meta.data)# meta 表转成特定格式fData &lt;- data.frame (gene_short_name &#x3D; row.names (data), row.names &#x3D; row.names (data))fd &lt;- new (&#39;AnnotatedDataFrame&#39;, data &#x3D; fData)# 基因名表转成特定格式mycds &lt;- newCellDataSet (data, phenoData &#x3D; pd, featureData &#x3D; fd, expressionFamily &#x3D; negbinomial.size ())#expressionFamily 参数用于指定表达矩阵的数据类型，有几个选项可以选择：# 稀疏矩阵用 negbinomial.size ()，FPKM 值用 tobit ()，logFPKM 值用 gaussianff ()##save (mycds, file &#x3D; &quot;..&#x2F;..&#x2F;tmp&#x2F;mycds_raw.Rdata&quot;)##rm (list &#x3D; ls ())##load (&quot;..&#x2F;..&#x2F;tmp&#x2F;mycds_raw.Rdata&quot;)#library (&quot;monocle&quot;)mycds &lt;- estimateSizeFactors (mycds)mycds &lt;- estimateDispersions (mycds, cores&#x3D;4, relative_expr &#x3D; TRUE) #!# 完成数据导入和预处理后，就可以考虑选择特定基因代表细胞的发育特征# 读入 maker 基因 mycds &lt;- estimateSizeFactors (mycds)mycds &lt;- estimateDispersions (mycds, cores&#x3D;4, relative_expr &#x3D; TRUE) #!# 完成数据导入和预处理后，就可以考虑选择特定基因代表细胞的发育特征# 这里可以选取我们之前挑选的 marker geneload (&quot;..&#x2F;markergene.Rdata&quot;)markers.gene &lt;- all.markers$genemycds &lt;- setOrderingFilter (mycds, markers.gene)# 降维mycds &lt;- reduceDimension (mycds, max_components &#x3D; 2, method &#x3D; &#39;DDRTree&#39;) #!# 耗时，耗内存# 细胞排序 #降维mycds &lt;- reduceDimension (mycds, max_components &#x3D; 2, method &#x3D; &#39;DDRTree&#39;) #!# 耗时，耗内存# 排序mycds &lt;- orderCells (mycds)#save (mycds,file &#x3D; &quot;..&#x2F;..&#x2F;tmp&#x2F;mycds_reduced.Rdata&quot;)load (&quot;..&#x2F;..&#x2F;tmp&#x2F;mycds_reduced.Rdata&quot;)p1 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;seurat_clusters&quot;)ggsave (&quot;..&#x2F;..&#x2F;out&#x2F;3.4trajectory_1.pdf&quot;, plot &#x3D; p1)p2 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;State&quot;)ggsave (&quot;..&#x2F;..&#x2F;out&#x2F;3.4trajectory_2.pdf&quot;, plot &#x3D; p2) &lt;center&gt; by_cluster &lt;/center&gt; &lt;center&gt; by_state &lt;/center&gt;","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(4)","url":"/2020/10/31/2020-10-31-ScRNAseq(10)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # QC 之 double droplet 和周期判断 load (&quot;..&#x2F;scRNA.Rdata&quot;)library (Seurat)##1、detect special cells----#empty droplet##BiocManager::install (&quot;DropletUtils&quot;)library (DropletUtils)e.out &lt;- emptyDrops (GetAssayData (scRNA,slot&#x3D;&quot;counts&quot;,assay&#x3D;&quot;RNA&quot;))#Error in testEmptyDrops (m, lower &#x3D; lower, ...) :#no counts available to estimate the ambient profile##https:&#x2F;&#x2F;support.bioconductor.org&#x2F;p&#x2F;123554&#x2F;#123562# 如上回答所说，empty droplet 往往在第一步就已经过滤掉了，而一般上传到 GEO 的也都是过滤掉空液滴的。#double droplet#https:&#x2F;&#x2F;osca.bioconductor.org&#x2F;doublet-detection.html#BiocManager::install (&quot;scran&quot;)head (scRNA@meta.data)library (scran)#GetAssayData (scRNA,slot&#x3D;&quot;counts&quot;,assay&#x3D;&quot;RNA&quot;)[1:8,1:4]?doubletCluster #检查有无 double droplet 聚在一起的类db.test &lt;- doubletCluster (GetAssayData (scRNA,slot&#x3D;&quot;counts&quot;,assay&#x3D;&quot;RNA&quot;), clusters&#x3D;scRNA@meta.data$seurat_clusters)head (db.test)table (scRNA@meta.data$seurat_clusters)library (scater)chosen.doublet &lt;- rownames (db.test)[isOutlier (db.test$N, type&#x3D;&quot;lower&quot;, log&#x3D;TRUE)]chosen.doublet #结果显示没有# 还有其它多种方法# 周期诊断 ##2、周期判断 ----# 在挑选 hvg gene 那一步因，可能会找到一些细胞周期相关基因；# 它们会导致细胞聚类发生一定的偏移，即相同类型的细胞在聚类时会因为细胞周期的不同而分开。# 因此有必要查看是否有细胞周期相关基因的存在；若有，则剔除# 细胞周期有关基因?cc.geneshead (c (cc.genes$s.genes,cc.genes$g2m.genes))length (c (cc.genes$s.genes,cc.genes$g2m.genes))# [1] &quot;MCM5&quot; &quot;PCNA&quot; &quot;TYMS&quot; &quot;FEN1&quot; &quot;MCM2&quot; &quot;MCM4&quot;# 查看我们选择的高变基因中有哪些细胞周期相关基因，及打分CaseMatch (c (cc.genes$s.genes,cc.genes$g2m.genes),VariableFeatures (scRNA))# 在 scRNA@meta.data 中添加 S.Score、G2M.Score 和 Phase 三列有关细胞周期的信息。g2m_genes &#x3D; cc.genes$g2m.genesg2m_genes &#x3D; CaseMatch (search &#x3D; g2m_genes, match &#x3D; rownames (scRNA))s_genes &#x3D; cc.genes$s.geness_genes &#x3D; CaseMatch (search &#x3D; s_genes, match &#x3D; rownames (scRNA))scRNA &lt;- CellCycleScoring (object&#x3D;scRNA, g2m.features&#x3D;g2m_genes, s.features&#x3D;s_genes)head (scRNA@meta.data)# 观察细胞周期相关基因是否影响聚类scRNA &lt;- RunPCA (scRNA, features &#x3D; c (s_genes, g2m_genes))p1 &lt;- DimPlot (scRNA, reduction &#x3D; &quot;pca&quot;, group.by &#x3D; &quot;Phase&quot;)ggsave (&quot;..&#x2F;..&#x2F;out&#x2F;3.2cell-cycle.pdf&quot;, plot &#x3D; p1)# 影响不大，基本重合在一起了 &lt;center&gt; 周期的影响并不大 &lt;/center&gt; # 单细胞类型注释 ##3、cell annotation-----# 对肿瘤细胞来说，分群后的细胞亚群注释是不可行的# 这里仅仅是演示 SingleR 做 cell annotation 的流程library (SingleR)refdata &lt;- get (load (&quot;..&#x2F;..&#x2F;rawdata&#x2F;HumanPrimaryCellAtlasData.Rdata&quot;))assay (refdata)[1:4,1:4]head (refdata@colData)head (refdata)ref &lt;- HumanPrimaryCellAtlasData ()# 参考数据库，等待时间较长。建议下载成功后，储存为 Rdata，以后方便使用。testdata &lt;- GetAssayData (scRNA, slot&#x3D;&quot;data&quot;)# 参考数据库，等待时间较长。建议下载成功后，储存为 Rdata，以后方便使用。testdata &lt;- GetAssayData (scRNA, slot&#x3D;&quot;data&quot;)clusters &lt;- scRNA@meta.data$seurat_clusterscellpred &lt;- SingleR (test &#x3D; testdata, ref &#x3D; refdata, labels &#x3D; refdata$label.fine, # label.fine 耗时比较长一点 method &#x3D; &quot;cluster&quot;, clusters &#x3D; clusters, assay.type.test &#x3D; &quot;logcounts&quot;, assay.type.ref &#x3D; &quot;logcounts&quot;)save (cellpred,file &#x3D; &quot;..&#x2F;..&#x2F;tmp&#x2F;cellpred.Rdata&quot;)load (&quot;..&#x2F;..&#x2F;tmp&#x2F;cellpred.Rdata&quot;)rm (refdata, HumanPrimaryCellAtlasData, testdata) #珍惜内存table (cellpred$labels)celltype &#x3D; data.frame (ClusterID&#x3D;rownames (cellpred), celltype&#x3D;cellpred$labels, stringsAsFactors &#x3D; F)table (celltype$ClusterID,celltype$celltype) #如下为 singleR 的细胞 cluster 鉴定结果。# 结合上述结果，给 scRNA 增添 celltype 注释信息scRNA@meta.data$celltype &#x3D; &quot;NA&quot;# 先新增列 celltype，值均为 NA，然后利用下一行代码循环填充for (i in 1:nrow (celltype))&#123; scRNA@meta.data [which (scRNA@meta.data$seurat_clusters &#x3D;&#x3D; celltype$ClusterID [i]),&#39;celltype&#39;] &lt;- celltype$celltype [i]&#125;p1 &lt;- DimPlot (scRNA, group.by&#x3D;&quot;celltype&quot;, label&#x3D;F , reduction&#x3D;&#39;tsne&#39;)ggsave (&quot;..&#x2F;..&#x2F;out&#x2F;3.3celltype_anno.pdf&quot;, plot &#x3D; p1, width &#x3D; 18, height &#x3D; 12) &lt;center&gt; 细胞类型注释 &lt;/center&gt;","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(3)","url":"/2020/10/29/2020-10-29-ScRNAseq(9)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # 降维，PCA 分析 load (&quot;..&#x2F;2.3.Rdata&quot;)### 4、降维，PCA 分析，可视化 ----# 先进行归一化（正态分布）scRNA &lt;- ScaleData (scRNA, features &#x3D; (rownames (scRNA)))# 储存到 &quot;scale.data&quot; 的 slot 里GetAssayData (scRNA,slot&#x3D;&quot;scale.data&quot;,assay&#x3D;&quot;RNA&quot;)[1:8,1:4]# 对比下原来的 count 矩阵GetAssayData (scRNA,slot&#x3D;&quot;counts&quot;,assay&#x3D;&quot;RNA&quot;)[1:8,1:4]#scRNA@assays$RNA@#PCA 降维，利用之前挑选的 hvg，可提高效率scRNA &lt;- RunPCA (scRNA, features &#x3D; VariableFeatures (scRNA))# 挑选第一，第二主成分对 cell 可视化DimPlot (scRNA, reduction &#x3D; &quot;pca&quot;, group.by&#x3D;&quot;Patient_ID&quot;)# 发现与原文献中颠倒了#seed.use :Set a random seed. By default, sets the seed to 42.#Setting NULL will not set a seed.scRNA &lt;- RunPCA (scRNA, features &#x3D; VariableFeatures (scRNA),seed.use&#x3D;3)# 尝试了 seed.use 的不同取值发现图形只有四种变化（四个拐角），其中以 seed.use&#x3D;3 为代表的一类与原文文献一致DimPlot (scRNA, reduction &#x3D; &quot;pca&quot;, group.by&#x3D;&quot;Patient_ID&quot;)# 与文献一致了。个人觉得颠倒与否如果只是随机种子的差别的话，对后续分析应该没影响p2_1 &lt;- DimPlot (scRNA, reduction &#x3D; &quot;pca&quot;, group.by&#x3D;&quot;Patient_ID&quot;)+ labs (tag &#x3D; &quot;D&quot;)p2_1 &lt;center&gt; 原图 &lt;/center&gt; &lt;center&gt; seed.use=3 后的 PCA 图 &lt;/center&gt; #挑选主成分，RunPCA 默认保留了前 50 个scRNA &lt;- JackStraw (scRNA,reduction &#x3D; &quot;pca&quot;, dims&#x3D;20)scRNA &lt;- ScoreJackStraw (scRNA,dims &#x3D; 1:20)p2_2 &lt;- JackStrawPlot (scRNA,dims &#x3D; 1:20, reduction &#x3D; &quot;pca&quot;) + theme (legend.position&#x3D;&quot;bottom&quot;) + labs (tag &#x3D; &quot;E&quot;)p2_2p2_3 &lt;- ElbowPlot (scRNA, ndims&#x3D;20, reduction&#x3D;&quot;pca&quot;)p2_2 | p2_3 &lt;center&gt; E 图 &lt;/center&gt; &lt;center&gt; D 图与 E 图 &lt;/center&gt; # 聚类、筛选 maker 基因并可视化 # 聚类 pc.num&#x3D;1:20# 基于 PCA 数据scRNA &lt;- FindNeighbors (scRNA, dims &#x3D; pc.num)# dims 参数，需要指定哪些 pc 轴用于分析；这里利用上面的分析，选择 20scRNA &lt;- FindClusters (scRNA, resolution &#x3D; 0.5)table (scRNA@meta.data$seurat_clusters)scRNA &#x3D; RunTSNE (scRNA, dims &#x3D; pc.num)DimPlot (scRNA, reduction &#x3D; &quot;tsne&quot;,label&#x3D;T)p3_1 &lt;- DimPlot (scRNA, reduction &#x3D; &quot;tsne&quot;,label&#x3D;T) + labs (tag &#x3D; &quot;E&quot;)p3_1 &lt;center&gt; F 图 &lt;/center&gt; # 筛选 maker 基因 #5.2 marker gene# 进行差异分析，一般使用标准化数据scRNA &lt;- NormalizeData (scRNA, normalization.method &#x3D; &quot;LogNormalize&quot;)# 结果储存在 &quot;data&quot;slot 里GetAssayData (scRNA,slot&#x3D;&quot;data&quot;,assay&#x3D;&quot;RNA&quot;)[1:8,1:4]#if test.use is &quot;negbinom&quot;, &quot;poisson&quot;, or &quot;DESeq2&quot;, slot will be set to &quot;countsdiff.wilcox &#x3D; FindAllMarkers (scRNA)## 默认使用 wilcox 方法挑选差异基因，大概 4-5minload (&quot;..&#x2F;diff.wilcox.Rdata&quot;)head (diff.wilcox)dim (diff.wilcox)library (tidyverse)all.markers &#x3D; diff.wilcox %&gt;% select (gene, everything ()) %&gt;% subset (p_val&lt;0.05 &amp; abs (diff.wilcox$avg_logFC) &gt; 0.5)#An adjusted P value &lt; 0.05and | log 2 [fold change (FC)] | &gt; 0.5#were considered the 2 cutoff criteria for identifying marker genes.dim (all.markers)summary (all.markers)save (all.markers,file &#x3D; &quot;..&#x2F;markergene.Rdata&quot;)top10 &#x3D; all.markers %&gt;% group_by (cluster) %&gt;% top_n (n &#x3D; 10, wt &#x3D; avg_logFC)top10top10 &#x3D; CaseMatch (search &#x3D; as.vector (top10$gene), match &#x3D; rownames (scRNA))top10length (top10)length (unique (sort (top10)))p3_2 &lt;- DoHeatmap (scRNA, features &#x3D; top10, group.by &#x3D; &quot;seurat_clusters&quot;)p3_2p3_1 | p3_2 #下图 &lt;center&gt; G 图 &lt;/center&gt; &lt;center&gt; 图片合并 &lt;/center&gt; 目前，图一的图片已经全部完成，接下来将进行拼图 # 拼图 ### 6、拼图，比较 ----p &lt;- (p1_1 | p1_2 | p1_3) &#x2F; ((p2_1| p2_2 | p2_3) &#x2F; (p3_1 | p3_2))ggsave (&quot;..&#x2F;.my_try.pdf&quot;, plot &#x3D; p, width &#x3D; 15, height &#x3D; 18)save (scRNA,file &#x3D; &quot;scRNA.Rdata&quot;)","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(2)","url":"/2020/10/27/2020-10-27-ScRNAseq(8)/","text":"生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # 创建 Seurat 对象并质控 创建 Seurat 对象，然后过滤掉表达量过低的基因、表达基因过少的细胞以及线粒体基因过多的细胞 ### 2、构建 seurat 对象，质控绘图 ----# 2.1 构建 seurat 对象，质控#In total, 2,343 cells from tumor cores were included in this analysis.#quality controlstandards:#1) genes detected in &lt; 3 cells were excluded; 筛选基因#2) cells with &lt; 50 total detected genes were excluded; 筛选细胞#3) cells with ≥ 5% of mitochondria-expressed genes were excluded. 筛选细胞library (&quot;Seurat&quot;)sce.meta &lt;- data.frame (Patient_ID&#x3D;group$Patient_ID, row.names &#x3D; group$sample)head (sce.meta)table (sce.meta$Patient_ID)# 这个函数 CreateSeuratObject 有多种多样的执行方式scRNA &#x3D; CreateSeuratObject (counts&#x3D;a.filt, meta.data &#x3D; sce.meta, min.cells &#x3D; 3, min.features &#x3D; 50)#counts:a matrix-like object with unnormalized data with cells as columns and features as rows#meta.data:Additional cell-level metadata to add to the Seurat object#min.cells: features detected in at least this many cells.#min.features:cells where at least this many features are detected.head (scRNA@meta.data)#nCount_RNA：the number of cell total counts#nFeature_RNA：the number of cell&#39;s detected genesummary (scRNA@meta.data)scRNA@assays$RNA@counts [1:4,1:4]# 可以看到，之前的 counts 矩阵存储格式发生了变化：4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;dim (scRNA)# 20047 2342 仅过滤掉一个细胞# 接下来根据线粒体基因表达筛选低质量细胞#Calculate the proportion of transcripts mapping to mitochondrial genestable (grepl (&quot;^MT-&quot;,rownames (scRNA)))#FALSE#20050 没有染色体基因scRNA [[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet (scRNA, pattern &#x3D; &quot;^MT-&quot;)head (scRNA@meta.data)summary (scRNA@meta.data)# 结果显示没有线粒体基因，因此这里过滤也就没有意义，但是代码留在这里# 万一大家的数据里面有线粒体基因，就可以如此这般进行过滤啦。pctMT&#x3D;5 #≥ 5% of mitochondria-expressed genesscRNA &lt;- subset (scRNA, subset &#x3D; percent.mt &lt; pctMT)dim (scRNA)table (grepl (&quot;^ERCC-&quot;,rownames (scRNA)))#FALSE TRUE#19961 86 发现是有 ERCC 基因#External RNA Control Consortium，是常见的已知浓度的外源 RNA 分子 spike-in 的一种# 指标含义类似线粒体含量，ERCC 含量大，则说明 total sum 变小scRNA [[&quot;percent.ERCC&quot;]] &lt;- PercentageFeatureSet (scRNA, pattern &#x3D; &quot;^ERCC-&quot;)head (scRNA@meta.data)summary (scRNA@meta.data)rownames (scRNA)[grep (&quot;^ERCC-&quot;,rownames (scRNA))][1] &quot;ERCC-00002&quot; &quot;ERCC-00003&quot; &quot;ERCC-00004&quot; &quot;ERCC-00009&quot; &quot;ERCC-00012&quot; &quot;ERCC-00013&quot; &quot;ERCC-00014&quot; &quot;ERCC-00017&quot; &quot;ERCC-00019&quot; &quot;ERCC-00022&quot; &quot;ERCC-00024&quot; &quot;ERCC-00025&quot;[13] &quot;ERCC-00028&quot; &quot;ERCC-00031&quot; &quot;ERCC-00033&quot; &quot;ERCC-00034&quot; &quot;ERCC-00035&quot; &quot;ERCC-00039&quot; &quot;ERCC-00040&quot; &quot;ERCC-00041&quot; &quot;ERCC-00042&quot; &quot;ERCC-00043&quot; &quot;ERCC-00044&quot; &quot;ERCC-00046&quot;[25] &quot;ERCC-00051&quot; &quot;ERCC-00053&quot; &quot;ERCC-00054&quot; &quot;ERCC-00058&quot; &quot;ERCC-00059&quot; &quot;ERCC-00060&quot; &quot;ERCC-00062&quot; &quot;ERCC-00067&quot; &quot;ERCC-00069&quot; &quot;ERCC-00071&quot; &quot;ERCC-00073&quot; &quot;ERCC-00074&quot;[37] &quot;ERCC-00076&quot; &quot;ERCC-00077&quot; &quot;ERCC-00078&quot; &quot;ERCC-00079&quot; &quot;ERCC-00081&quot; &quot;ERCC-00083&quot; &quot;ERCC-00084&quot; &quot;ERCC-00085&quot; &quot;ERCC-00086&quot; &quot;ERCC-00092&quot; &quot;ERCC-00095&quot; &quot;ERCC-00096&quot;[49] &quot;ERCC-00097&quot; &quot;ERCC-00098&quot; &quot;ERCC-00099&quot; &quot;ERCC-00104&quot; &quot;ERCC-00108&quot; &quot;ERCC-00109&quot; &quot;ERCC-00111&quot; &quot;ERCC-00112&quot; &quot;ERCC-00113&quot; &quot;ERCC-00116&quot; &quot;ERCC-00120&quot; &quot;ERCC-00123&quot;[61] &quot;ERCC-00126&quot; &quot;ERCC-00130&quot; &quot;ERCC-00131&quot; &quot;ERCC-00134&quot; &quot;ERCC-00136&quot; &quot;ERCC-00137&quot; &quot;ERCC-00138&quot; &quot;ERCC-00142&quot; &quot;ERCC-00143&quot; &quot;ERCC-00144&quot; &quot;ERCC-00145&quot; &quot;ERCC-00147&quot;[73] &quot;ERCC-00148&quot; &quot;ERCC-00150&quot; &quot;ERCC-00154&quot; &quot;ERCC-00156&quot; &quot;ERCC-00157&quot; &quot;ERCC-00158&quot; &quot;ERCC-00160&quot; &quot;ERCC-00162&quot; &quot;ERCC-00163&quot; &quot;ERCC-00164&quot; &quot;ERCC-00165&quot; &quot;ERCC-00168&quot;[85] &quot;ERCC-00170&quot; &quot;ERCC-00171&quot;# 可以看到有不少 ERCC 基因sum (scRNA$percent.ERCC&lt; 40)# 较接近原文过滤数量 2149，但感觉条件有点宽松了，先做下去看看# 网上看了相关教程，一般 ERCC 占比不高于 10%sum (scRNA$percent.ERCC&lt; 10) #就只剩下 460 个 cell，明显低于文献中的数量pctERCC&#x3D;40scRNA &lt;- subset (scRNA, subset &#x3D; percent.ERCC &lt; pctERCC)dim (scRNA)# 20047 2142 原文为 19752 2149dim (a.filt)#23460 2343 未过滤前# 质控绘图 # 2.2 可视化# 图 A：观察不同组 cell 的 counts、feature 分布col.num &lt;- length (unique (scRNA@meta.data$Patient_ID))library (ggplot2)p1_1.1 &lt;- VlnPlot (scRNA, features &#x3D; c (&quot;nFeature_RNA&quot;), group.by &#x3D; &quot;Patient_ID&quot;, cols &#x3D;rainbow (col.num)) + theme (legend.position &#x3D; &quot;none&quot;) + labs (tag &#x3D; &quot;A&quot;)p1_1.1p1_1.2 &lt;- VlnPlot (scRNA, features &#x3D; c (&quot;nCount_RNA&quot;), group.by &#x3D; &quot;Patient_ID&quot;, cols &#x3D;rainbow (col.num)) + theme (legend.position &#x3D; &quot;none&quot;)p1_1.2p1_1 &lt;- p1_1.1 | p1_1.2p1_1VlnPlot (scRNA, features &#x3D; c (&quot;nFeature_RNA&quot;,&quot;nCount_RNA&quot;,&quot;percent.ERCC&quot;))# 图 B：nCount_RNA 与对应的 nFeature_RNA 关系p1_2 &lt;- FeatureScatter (scRNA, feature1 &#x3D; &quot;nCount_RNA&quot;, feature2 &#x3D; &quot;nFeature_RNA&quot;, group.by &#x3D; &quot;Patient_ID&quot;,pt.size &#x3D; 1.3) + labs (tag &#x3D; &quot;B&quot;)p1_2FeatureScatter (scRNA, feature1 &#x3D; &quot;nCount_RNA&quot;, feature2 &#x3D; &quot;percent.ERCC&quot;) &lt;center&gt; p1_1 &lt;/center&gt; &lt;center&gt; p1_2 &lt;/center&gt; 目前已经完成了文献中的 fig1A、B # 挑选高变基因 ### 3、挑选 hvg 基因，可视化 ----#highly Variable gene: 简单理解 sd 大的scRNA &lt;- FindVariableFeatures (scRNA, selection.method &#x3D; &quot;vst&quot;, nfeatures &#x3D; 1500)# 根据文献原图，挑选变化最大的 1500 个 hvgtop10 &lt;- head (VariableFeatures (scRNA), 10)top10plot1 &lt;- VariableFeaturePlot (scRNA)# 标记 top10 hvgp1_3 &lt;- LabelPoints (plot &#x3D; plot1, points &#x3D; top10, repel &#x3D; TRUE, size&#x3D;2.5) + theme (legend.position &#x3D; c (0.1,0.8)) + labs (tag &#x3D; &quot;C&quot;)p1_3save (scRNA, file&#x3D;&quot;2.3.Rdata&quot;) &lt;center&gt; p1_3 &lt;/center&gt; 目前已复现文献中的图 1A 到 C。","tags":"bioinformatics scrnaseq"},{"title":"生信技能树单细胞数据挖掘笔记(1)","url":"/2020/10/24/2020-10-24-ScRNAseq(7)/","text":"# 前言 最近有幸加入生信技能树的单细胞数据挖掘尝鲜群，借此机会给大家分享一下 生信技能树单细胞数据挖掘笔记 (1)：数据读入 生信技能树单细胞数据挖掘笔记 (2)：创建 Seurat 对象并进行质控、筛选高变基因并可视化 生信技能树单细胞数据挖掘笔记 (3)：降维与聚类 生信技能树单细胞数据挖掘笔记 (4)：其他分析（周期判断、double 诊断、细胞类型注释） 生信技能树单细胞数据挖掘笔记 (5)：轨迹分析 生信技能树单细胞数据挖掘笔记 (6)：差异分析 (1) 生信技能树单细胞数据挖掘笔记 (7)：差异分析 (2) # 课程大纲 # 入门基础知识 所需 R 包 getOption (&quot;BioC_mirror&quot;)getOption (&quot;CRAN&quot;)#CRAN 基础包options (CRAN&#x3D;&quot;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;CRAN&#x2F;&quot;)## 设置镜像cran_packages &lt;- c (&#39;tidyverse&#39;, &#39;ggplot2&#39; )for (pkg in cran_packages)&#123; if (! require (pkg,character.only&#x3D;T) ) &#123; install.packages (pkg,ask &#x3D; F,update &#x3D; F) require (pkg,character.only&#x3D;T) &#125;&#125;if (!require (&quot;BiocManager&quot;)) install.packages (&quot;BiocManager&quot;,update &#x3D; F,ask &#x3D; F)#Bio 分析包Biocductor_packages &lt;- c (&quot;Seurat&quot;, &quot;scran&quot;, &quot;scater&quot;, &quot;monocle&quot;, &quot;DropletUtils&quot;, &quot;SingleR&quot; )options (BioC_mirror&#x3D;&quot;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;bioc&#x2F;&quot;)#options (BioC_mirror&#x3D;&quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;bioconductor&quot;)# use BiocManager to installfor (pkg in Biocductor_packages)&#123; if (! require (pkg,character.only&#x3D;T) ) &#123; BiocManager::install (pkg,ask &#x3D; F,update &#x3D; F) require (pkg,character.only&#x3D;T) &#125;&#125;# 最后检查下成功与否for (pkg in c (Biocductor_packages,cran_packages))&#123; require (pkg,character.only&#x3D;T)&#125;### GEO## GEO Platform (GPL)# GEO Sample (GSM)# GEO Series (GSE)# GEO Dataset (GDS)# 一篇文章可以有一个或者多个 GSE 数据集，一个 GSE 里面可以有一个或者多个 GSM 样本。# 多个研究的 GSM 样本可以根据研究目的整合为一个 GDS，不过 GDS 本身用的很少。# 而每个数据集都有着自己对应的芯片平台，就是 GPL。(芯片名与基因名 ID 转换)#https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43569478&#x2F;article&#x2F;details&#x2F;108079337# https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;geo&#x2F;query&#x2F;acc.cgi?acc&#x3D;BiocManager::install (&quot;GEOquery&quot;)library (GEOquery)gse1009 &lt;- getGEO (&#39;GSE1009&#39;, destdir&#x3D;&quot;.&quot;)class (gse1009)length (gse1009)a &lt;- gse1009 [[1]]class (gse1009 [1])ab &lt;- exprs (a)c &lt;- pData (a)a$platform_id# 下载、探索、数据整理 本次数据采用《Glioblastoma cell differentiation trajectory predicts the immunotherapy response and overall survival of patients》中的单细胞数据进行分析（GSE 号：84465） ### 1、下载、探索、整理数据 ----## 1.1 下载、探索数据#https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;geo&#x2F;query&#x2F;acc.cgi?acc&#x3D;GSE84465 ## 数据来源sessionInfo () # 读取数据 a &lt;- read.table (&quot;..&#x2F;rawdata&#x2F;GSE84465_GBM_All_data.csv.gz&quot;)a [1:4,1:4]# 行名为 symbol ID# 列名为 sample，看上去像是两个元素的组合。summary (a [,1:4])boxplot (a [,1:4])head (rownames (a))tail (rownames (a),10)# 可以看到原文的 counts 矩阵来源于 htseq 这个计数软件，所以有一些不是基因的行需要剔除：# &quot;no_feature&quot; &quot;ambiguous&quot; &quot;too_low_aQual&quot; &quot;not_aligned&quot; &quot;alignment_not_unique&quot;tail (a [,1:4],10)a&#x3D;a [1:(nrow (a)-5),]# 原始 counts 数据#3,589 cells of 4 human primary GBM samples, accession number GSE84465#2,343 cells from tumor cores and 1,246 cells from peripheral regionsb &lt;- read.table (&quot;..&#x2F;rawdata&#x2F;SraRunTable.txt&quot;, sep &#x3D; &quot;,&quot;, header &#x3D; T)b [1:4,1:4]table (b$Patient_ID) # 4 human primary GBM samplestable (b$TISSUE) # tumor cores and peripheral regionstable (b$TISSUE,b$Patient_ID)# 整理数据 可以发现两个数据不对应，a 矩阵行名（sample）并非为 GSM 编号，而主要是由相应的 plate_id 与 Well 组合而成 ## 1.2 整理数据# tumor and peripheral 分组信息head (colnames (a))[1] &quot;X1001000173.G8&quot; &quot;X1001000173.D4&quot; &quot;X1001000173.B4&quot; &quot;X1001000173.A2&quot; &quot;X1001000173.E2&quot; &quot;X1001000173.F6&quot;head (b$plate_id)[1] 1001000173 1001000173 1001000173 1001000173 1001000173 1001000173head (b$Well)#a 矩阵行名（sample）并非为 GSM 编号，而主要是由相应的 plate_id 与 Well 组合而成b.group &lt;- b [,c (&quot;plate_id&quot;,&quot;Well&quot;,&quot;TISSUE&quot;,&quot;Patient_ID&quot;)]b.group$sample &lt;- paste0 (&quot;X&quot;,b.group$plate_id,&quot;.&quot;,b.group$Well)head (b.group) plate_id Well TISSUE Patient_ID sample1 1001000173 G8 Tumor BT_S2 X1001000173.G82 1001000173 D4 Tumor BT_S2 X1001000173.D43 1001000173 B4 Tumor BT_S2 X1001000173.B44 1001000173 A2 Tumor BT_S2 X1001000173.A25 1001000173 E2 Tumor BT_S2 X1001000173.E26 1001000173 F6 Tumor BT_S2 X1001000173.F6identical (colnames (a),b.group$sample)# 筛选 tumor cellindex &lt;- which (b.group$TISSUE&#x3D;&#x3D;&quot;Tumor&quot;)length (index)group &lt;- b.group [index,] #筛选的是行head (group)a.filt &lt;- a [,index] #筛选的是列dim (a.filt)identical (colnames (a.filt),group$sample)经过筛选之后得到所有的肿瘤细胞的表达矩阵","tags":"bioinformatics scrnaseq"},{"title":"马士兵教育Python入门基础:4.流程控制（3）","url":"/2020/10/22/2020-10-22-python9/","text":"马士兵教育 Python 入门基础：4. 流程控制 (3) # 多分支结构 &#39;&#39;&#39;多分支结构，多选一执行从键盘录入一个整数 成绩90-100 A80-89 B70-79 C60-69 D0-59 E小于 0 或大于 100 为无效数据&#39;&#39;&#39;score&#x3D;int (input (&#39; 请输入一个成绩 &#39;))# 判断if score&gt;&#x3D;90 and score&lt;&#x3D;100: print (&#39;A 级 &#39;)elif score&gt;&#x3D;80 and score&lt;&#x3D;89: print (&#39;B 级 &#39;)elif 70&lt;&#x3D;score&lt;&#x3D;79: #只有 python 可以这么写 print (&#39;C 级 &#39;)elif 60&lt;&#x3D;score&lt;&#x3D;69: print (&#39;D 级 &#39;)elif 0&lt;&#x3D;score&lt;&#x3D;59: print (&#39;E 级 &#39;)else: print (&#39; 无效成绩 &#39;)请输入一个成绩 89B 级# 嵌套 if 的使用 &#39;&#39;&#39;会员购物金额 200 以上 8 折，100 以上 9 折，否则不打折非会员 200 以上 9.5 折&#39;&#39;&#39;answer&#x3D;input (&#39; 您是会员吗？y&#x2F;n&#39;)money&#x3D;float (input (&quot;请输入您的购物金额&quot;))if answer&#x3D;&#x3D;&#39;y&#39;: # 会员 if money&gt;&#x3D;200: print (&#39; 付款金额为：&#39;,money*0.8) elif money&gt;&#x3D;100: print (&#39; 付款金额为：&#39;,money*0.9) else: print (&#39; 付款金额为：&#39;,money)else: #非会员 if money&gt;&#x3D;200: print (&#39; 付款金额为：&#39;,money*0.95) else: print (&#39; 不打折，付款金额为 &#39;,money)您是会员吗？y&#x2F;ny请输入您的购物金额 300付款金额为： 240.0","tags":"python"},{"title":"马士兵教育Python入门基础:4.流程控制（2）","url":"/2020/10/20/2020-10-20-python8/","text":"马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # 分支结构 # 单分支结构 money&#x3D;1000 #余额s&#x3D;int (input (&#39; 请输入取款金额 &#39;)) #取款金额# 判断余额是否充足if money&gt;&#x3D;s: money&#x3D;money-s print (&#39; 取款成功，余额为：&#39;,money)请输入取款金额 120取款成功，余额为： 880# 双分支结构 ## 双分支结构二选一&#39;&#39;&#39; 从键盘录入一个整数，判断是奇数还是偶数 &#39;&#39;&#39;num&#x3D;int (input (&#39; 请输入一个整数 &#39;))# 条件判断if num%2&#x3D;&#x3D;0: print (num,&#39; 是偶数 &#39;)else: print (num,&#39; 是奇数 &#39;)请输入一个整数 88 是偶数","tags":"python"},{"title":"马士兵教育Python入门基础:4.流程控制（1）","url":"/2020/10/17/2020-10-17-python7/","text":"马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # 本章内容 程序的组织结构 顺序结构 对象的布尔值 分支结构（if 语句） pass 空语句 # 组织结构 # 顺序结构 &#39;&#39;&#39;&#39; 把大象装进冰箱总共分几步？&#39;&#39;&#39;print (&#39;1. 打开冰箱门 &#39;)print (&#39;2. 把大象放冰箱里 &#39;)print (&#39;3. 把冰箱门关上 &#39;)# 对象的布尔值 print (bool (False))print (bool (0))print (bool (0.0))print (bool (None))print (bool (&quot;&quot;))print (bool ([]))print (bool (&#123;&#125;))print (bool (()))## 除此以外全为 True","tags":"python"},{"title":"马士兵教育Python入门基础:3.运算（2）","url":"/2020/10/15/2020-10-15-python6/","text":"马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # 比较运算符 a,b&#x3D;10,20print (&#39;a&gt;b 吗？&#39;,a&gt;b)print (&#39;a&lt;b 吗？&#39;,a&lt;b)print (&#39;a&lt;&#x3D;b 吗？&#39;,a&lt;&#x3D;b)print (&#39;a&gt;&#x3D;b 吗？&#39;,a&gt;&#x3D;b)print (&#39;a&#x3D;&#x3D;b 吗？&#39;,a&#x3D;&#x3D;b)print (&#39;a!&#x3D;b 吗？&#39;,a!&#x3D;b)a&gt;b 吗？ Falsea&lt;b 吗？Truea&lt;&#x3D;b 吗？Truea&gt;&#x3D;b 吗？ Falsea&#x3D;&#x3D;b 吗？ Falsea!&#x3D;b 吗？ True一个 “=” 为赋值运算，两个 “=” 为比较运算 变量由三部分组成，标识，类型，值 == 比较的是值 比较对象标识使用 is a&#x3D;10b&#x3D;10print (&quot;a 标识&quot;,id (a))print (&quot;b 标识&quot;,id (b))print (a&#x3D;&#x3D;b)print (a is not b)print (a is b)a 标识 140712227968960b 标识 140712227968960TrueFalseTrue相同数字的数组标识不会相同，所以结果为 false # 布尔运算符 a,b&#x3D;1,2print(a&#x3D;&#x3D;1 and b&#x3D;&#x3D;2)print(a&#x3D;&#x3D;1 and b&lt;2)print(a!&#x3D;1 and b&#x3D;&#x3D;2)print(a!&#x3D;1 and b!&#x3D;2)TrueFalseFalseFalseprint(a&#x3D;&#x3D;1 or b&#x3D;&#x3D;2)print(a&#x3D;&#x3D;1 or b&lt;2)print(a!&#x3D;1 or b&#x3D;&#x3D;2)print(a!&#x3D;1 or b!&#x3D;2)TrueTrueTrueFalsef&#x3D;Truef2&#x3D;Falseprint(not f)print(not f2)FalseTrues&#x3D;&#39;helloworld&#39;print(&#39;w&#39; in s)print(&#39;k&#39; in s)print(&#39;w&#39; not in s)print(&#39;k&#39; not in s)TrueFalseFalseTrue# 位运算符 print(4&amp;8)print(4|8)012 print(4&lt;&lt;1)print(4&lt;&lt;2)print(4&gt;&gt;1)print(4&gt;&gt;2)81621# 运算符的优先级 算数运算符（先乘除后加减，幂优先）&gt; 位运算符 &gt; 比较运算 &gt; 布尔运算 &gt; 赋值运算，括号最优先 # 总结","tags":"python"},{"title":"单细胞实战(5)：复现文章中的聚类图（2）","url":"/2020/10/13/2020-10-13-ScRNAseq(6)/","text":"# 前言 之前对拟南芥单细胞测序的文献数据进行复现，数据结果有点微妙，接下来进行拟时间分析 # 分生组织伪时间分析 作者首先查看了分生组织相关基因（WOX5,PIN1,RGF3,PLT1）在聚类中的表达情况，WOX5 和 PIN1 主要在 cluster12 中表达，RGF3 以及 PLT1 主要在 cluster19 中表达，对应到自己的数据中查看效果 pdf(&quot;cell_identify&#x2F;meristematic.pdf&quot;,height &#x3D; 14,width &#x3D; 14)FeaturePlot(wang,features&#x3D;c(&#39;AT3G11260&#39;,&#39;AT1G73590&#39;,&#39;AT2G04025&#39;,&#39;AT3G20840&#39;),cols&#x3D;c(&quot;grey&quot;,&quot;yellow&quot;,&quot;red&quot;,&quot;brown&quot;) ,reduction &#x3D; &#39;umap&#39;,pt.size &#x3D; 1,label.size &#x3D; 4)dev.off() 可以看到对应效果还是不错的，接下来选择 cluster12.14.19 进行伪时间分析 id&lt;-c (&quot;12&quot;,&quot;14&quot;,&quot;19&quot;)cell.sub &lt;- subset (wang@meta.data,seurat_clusters&#x3D;&#x3D;id)scRNAsub &lt;- subset (wang, cells&#x3D;row.names (cell.sub))dim (scRNAsub)library (monocle)dir.create (&quot;pseudotime121419&quot;)data &lt;- as (as.matrix (scRNAsub@assays$RNA@counts), &#39;sparseMatrix&#39;)pd &lt;- new (&#39;AnnotatedDataFrame&#39;, data &#x3D; scRNAsub@meta.data)fData &lt;- data.frame (gene_short_name &#x3D; row.names (data), row.names &#x3D; row.names (data))fd &lt;- new (&#39;AnnotatedDataFrame&#39;, data &#x3D; fData)mycds &lt;- newCellDataSet (data, phenoData &#x3D; pd, featureData &#x3D; fd, expressionFamily &#x3D; negbinomial.size ())mycds &lt;- estimateSizeFactors (mycds)mycds &lt;- estimateDispersions (mycds, cores&#x3D;4, relative_expr &#x3D; TRUE)## 选择代表性基因## 使用 monocle 选择的高变基因disp_table &lt;- dispersionTable (mycds)disp.genes &lt;- subset (disp_table, mean_expression &gt;&#x3D; 0.1 &amp; dispersion_empirical &gt;&#x3D; 1 * dispersion_fit)$gene_idmycds &lt;- setOrderingFilter (mycds, disp.genes)## 降维以及细胞排序# 降维mycds &lt;- reduceDimension (mycds, max_components &#x3D; 2, method &#x3D; &#39;DDRTree&#39;)# 排序mycds &lt;- orderCells (mycds)#State 轨迹分布图plot1 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;State&quot;)ggsave (&quot;pseudotime121419&#x2F;State.pdf&quot;, plot &#x3D; plot1, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;State.png&quot;, plot &#x3D; plot1, width &#x3D; 6, height &#x3D; 5)##Cluster 轨迹分布图plot2 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;seurat_clusters&quot;)ggsave (&quot;pseudotime121419&#x2F;Cluster.pdf&quot;, plot &#x3D; plot2, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;Cluster.png&quot;, plot &#x3D; plot2, width &#x3D; 6, height &#x3D; 5)##Pseudotime 轨迹图plot3 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;Pseudotime&quot;)ggsave (&quot;pseudotime121419&#x2F;Pseudotime.pdf&quot;, plot &#x3D; plot3, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;Pseudotime.png&quot;, plot &#x3D; plot3, width &#x3D; 6, height &#x3D; 5)## 合并作图plotc &lt;- plot1|plot2|plot3ggsave (&quot;pseudotime121419&#x2F;Combination.pdf&quot;, plot &#x3D; plotc, width &#x3D; 10, height &#x3D; 3.5)ggsave (&quot;pseudotime121419&#x2F;Combination.png&quot;, plot &#x3D; plotc, width &#x3D; 10, height &#x3D; 3.5)## 保存结果write.csv (pData (mycds), &quot;pseudotime121419&#x2F;pseudotime.csv&quot;)p1 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;State&quot;) + facet_wrap (~State, nrow &#x3D; 1)p2 &lt;- plot_cell_trajectory (mycds, color_by &#x3D; &quot;seurat_clusters&quot;) + facet_wrap (~seurat_clusters, nrow &#x3D; 1)plotc &lt;- p1&#x2F;p2ggsave (&quot;pseudotime121419&#x2F;trajectory_facet.png&quot;, plot &#x3D; plotc, width &#x3D; 6, height &#x3D; 5) 结果也与文献中的有点出入，接下来查看一下 BEAM 热图和一些基因在轨迹中的表达情况 ##BEAM 分析disp_table &lt;- dispersionTable (mycds)disp.genes &lt;- subset (disp_table, mean_expression &gt;&#x3D; 0.5&amp;dispersion_empirical &gt;&#x3D; 1*dispersion_fit)disp.genes &lt;- as.character (disp.genes$gene_id)mycds_sub &lt;- mycds [disp.genes,]#State 轨迹分布图plot1 &lt;- plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;State&quot;)ggsave (&quot;pseudotime121419&#x2F;BEAM_State.pdf&quot;, plot &#x3D; plot1, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;BEAM_State.png&quot;, plot &#x3D; plot1, width &#x3D; 6, height &#x3D; 5)##Cluster 轨迹分布图plot2 &lt;- plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;seurat_clusters&quot;)ggsave (&quot;pseudotime121419&#x2F;BEAM_Cluster.pdf&quot;, plot &#x3D; plot2, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;BEAM_Cluster.png&quot;, plot &#x3D; plot2, width &#x3D; 6, height &#x3D; 5)##Pseudotime 轨迹图plot3 &lt;- plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;Pseudotime&quot;)ggsave (&quot;pseudotime121419&#x2F;BEAM_Pseudotime.pdf&quot;, plot &#x3D; plot3, width &#x3D; 6, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;BEAM_Pseudotime.png&quot;, plot &#x3D; plot3, width &#x3D; 6, height &#x3D; 5)## 合并作图plotc &lt;- plot1|plot2|plot3ggsave (&quot;pseudotime121419&#x2F;BEAM_Combination.pdf&quot;, plot &#x3D; plotc, width &#x3D; 10, height &#x3D; 3.5)ggsave (&quot;pseudotime121419&#x2F;BEAM_Combination.png&quot;, plot &#x3D; plotc, width &#x3D; 10, height &#x3D; 3.5)## 保存结果beam_res &lt;- BEAM (mycds_sub, branch_point &#x3D; 1, cores &#x3D; 8)beam_res &lt;- beam_res [order (beam_res$qval),]beam_res &lt;- beam_res [,c (&quot;gene_short_name&quot;, &quot;pval&quot;, &quot;qval&quot;)]mycds_sub_beam &lt;- mycds_sub [row.names (subset (beam_res, qval &lt; 1e-4)),]pdf (&quot;pseudotime121419&#x2F;BEAM_pseudotime_heatmap2.pdf&quot;,width &#x3D; 10, height &#x3D; 10)plot_genes_branched_heatmap (mycds_sub_beam, branch_point &#x3D; 1, num_clusters &#x3D; 5, show_rownames &#x3D; F)dev.off ()## 寻找相应的基因绘制轨迹图matrix_dir&#x3D;&quot;filtered_gene_bc_matrices&#x2F;ref&#x2F;&quot;barcode.path &lt;- paste0 (matrix_dir,&quot;barcodes.tsv&quot;)features.path &lt;- paste0 (matrix_dir,&quot;genes.tsv&quot;)matrix.path &lt;- paste0 (matrix_dir, &quot;matrix.mtx&quot;)mat1 &lt;- readMM (file &#x3D; matrix.path)feature.names &#x3D; read.delim (features.path, header &#x3D; FALSE, stringsAsFactors &#x3D; FALSE)barcode.names &#x3D; read.delim (barcode.path, header &#x3D; FALSE, stringsAsFactors &#x3D; FALSE)colnames (mat1) &#x3D; barcode.names$V1rownames (mat1) &#x3D; feature.names$V1mat1&lt;-as.matrix (mat1)gene&lt;-t (as.matrix (mat1 [c (&#39;AT3G11260&#39;,&#39;AT1G73590&#39;, &#39;AT2G04025&#39;,&#39;AT3G20840&#39;,&#39;AT1G50490&#39;), colnames (scRNAsub@assays$RNA@counts)]))colnames (gene)&lt;-c (&quot;WOX5&quot;,&quot;PIN1&quot;,&quot;RGF3&quot;,&quot;PLT1&quot;,&quot;UBC20&quot;)mycds_sub@phenoData@data&lt;-cbind (mycds_sub@phenoData@data,gene)mycds_sub@phenoData@data [mycds_sub@phenoData@data &#x3D;&#x3D; 0] &lt;- NAp1&lt;-plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;WOX5&quot;)+scale_color_gradient (na.value &#x3D; &quot;grey&quot;,low&#x3D;&quot;yellow&quot;,high&#x3D;&quot;red&quot;)p2&lt;-plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;PIN1&quot;)+scale_color_gradient (na.value &#x3D; &quot;grey&quot;,low&#x3D;&quot;yellow&quot;,high&#x3D;&quot;red&quot;)p3&lt;-plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;RGF3&quot;)+scale_color_gradient (na.value &#x3D; &quot;grey&quot;,low&#x3D;&quot;yellow&quot;,high&#x3D;&quot;red&quot;)p4&lt;-plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;PLT1&quot;)+scale_color_gradient (na.value &#x3D; &quot;grey&quot;,low&#x3D;&quot;yellow&quot;,high&#x3D;&quot;red&quot;)p5&lt;-plot_cell_trajectory (mycds_sub, color_by &#x3D; &quot;UBC20&quot;)+scale_color_gradient (na.value &#x3D; &quot;grey&quot;,low&#x3D;&quot;yellow&quot;,high&#x3D;&quot;red&quot;)plotc &lt;- p1|p2|p3|p4|p5ggsave (&quot;pseudotime121419&#x2F;meristematic.pdf&quot;, plot &#x3D; plotc, width &#x3D; 18, height &#x3D; 5)ggsave (&quot;pseudotime121419&#x2F;meristematic.png&quot;, plot &#x3D; plotc, width &#x3D; 18, height &#x3D; 5) 文献中没有给出相应的参数，结果还是与文献的结果有点差距 # root cap 伪时间分析 按照相同的方式对 root cap 组织进行伪时间分析 # 结语 对于此次的数据复现，前面的聚类步骤还是能与文献对应，但是后续的伪时间分析差距就有点大了，主要是因为拟时间分析我才刚刚入门学习，对一些分析过程中的参数不太了解，目前的数据与代码我已上传 github ，欢迎大家批评指正","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(5)：复现文章中的聚类图（1）","url":"/2020/10/10/2020-10-10-ScRNAseq(5)/","text":"# 前言 目前我的课题是植物方面的单细胞测序，所以打算选择植物类的单细胞测序数据进行复现，目前选择了王佳伟老师的《A Single-Cell RNA Sequencing Profiles the Developmental Landscape of Arabidopsis Root》，希望能够得到好的结果 # 原始数据的下载 首先下载测序数据 prefetch SRR8485805 -O wang&#x2F;fastq-dump --split-files SRR8485805mv SRR8485805_1.fastq data&#x2F;WT_S1_L001_I1_001.fastqmv SRR8485805_2.fastq data&#x2F;WT_S1_L001_R1_001.fastqmv SRR8485805_3.fastq data&#x2F;WT_S1_L001_R2_001.fastq下载基因组与注释文件，需要注意文献中基因组使用的是 TAIR10，注释文件是 Araport11。 将 gff 转为 gtf 文件 gffread Araport11.gff3 -T -o Araport11.gtf# cellranger 进行比对 下载 cellranger2.2 版本 curl -o cellranger-2.2.0.tar.gz &quot;https:&#x2F;&#x2F;cf.10xgenomics.com&#x2F;releases&#x2F;cell-exp&#x2F;cellranger-2.2.0.tar.gz?Expires&#x3D;1603141363&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci0yLjIuMC50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDMxNDEzNjN9fX1dfQ__&amp;Signature&#x3D;en6P4Wedmwc2aSEitfKsQp2PITVYKgRPZdzR-fEmjBl4R9yQY5QBQY05--1v8AzRD9WqfoCnddSzFvngrlwxzeCJtFyfHLa2a7ONnUT6NtrzU6RkIj1jwXpaN4NpixnCbEF-Ubj9UZX63W1rEreM0AMNdWiVneGx4bcTajl1KRWaoTNS970DSJ1wrw0g70JFQ0BAltou-qPAeZpD9Xe9EM35EdWRT6eFq~zOaCMRLTxlBjZaMItyDRH~Qecz-B5tLWcAjCKfy4o2hAWTopRRpy93LVV-x1ykxCiHpej5AuAODvUx0V73rZOkRlijcpA5d1rHV~eEdPiM1uoCOJMiSw__&amp;Key-Pair-Id&#x3D;APKAI7S6A5RYOXBWRPDA&quot;tar -zxvf cellranger-2.2.0.tar.gz建立索引并比对 &#x2F;datadisk02&#x2F;ScRNAseq_data&#x2F;cellranger-2.2.0&#x2F;cellranger mkref --genome&#x3D;ref --fasta&#x3D;TAIR10.fa --genes&#x3D;Araport11.gtf&#x2F;datadisk02&#x2F;ScRNAseq_data&#x2F;cellranger-2.2.0&#x2F;cellranger count --id&#x3D;WANG --transcriptome&#x3D;ref --fastqs&#x3D;data&#x2F; --sample&#x3D;WT --force-cells&#x3D;8000比对结果还是可以的，与原文献中差距很小 # 使用 Seurat 对数据进行分析 文献中使用到的 Seurat 为 V3 版本，要注意 cellrangeV2 在 filtered_gene_bc_matrices 生成的文件是 genes、barcodes 以及 matrix，但 Seurat 识别的是 features，我们需要自行对 genes 文件改名 cd WANG&#x2F;outs&#x2F;filtered_gene_bc_matrices&#x2F;refgzip genes.tsvgzip matrix.mtxgzip barcodes.tsvmv genes.tsv.gz features.tsv.gz# 创建 Seurat 对象 library (Seurat)library (dplyr)library (ggplot2)library (magrittr)library (gtools)library (stringr)library (Matrix)library (tidyverse)library (patchwork)setwd (&quot;D:&#x2F;&#x2F;data&#x2F;ScRNAcode&#x2F;wang&#x2F;&quot;)##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1. 创建 Seurat 对象 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;dir &lt;- &#39;filtered_gene_bc_matrices&#x2F;ref&#x2F;&#39;counts &lt;- Read10X (dir)wang &#x3D; CreateSeuratObject (counts, project &#x3D; &quot;zxz&quot;, min.cells&#x3D;3, min.features &#x3D; 200)dim (wang)[1] 23228 8000# 数据质控与标准化 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2. 数据质控与标准化 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;##dir.create (&#39;QC&#39;)## 提取线粒体基因wang [[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet (wang, pattern&#x3D;&#39;^ATMG&#39;)violin &lt;- VlnPlot (wang, features &#x3D; c (&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), pt.size &#x3D; 0.1, #不需要显示点，可以设置 pt.size &#x3D; 0 ncol &#x3D; 3)ggsave (&quot;QC&#x2F;vlnplot-before-qc.pdf&quot;, plot &#x3D; violin, width &#x3D; 15, height &#x3D; 6)ggsave (&quot;QC&#x2F;vlnplot-before-qc.png&quot;, plot &#x3D; violin, width &#x3D; 15, height &#x3D; 6)plot1 &lt;- FeatureScatter (wang, feature1 &#x3D; &quot;nCount_RNA&quot;, feature2 &#x3D; &quot;percent.mt&quot;)plot2 &lt;- FeatureScatter (wang, feature1 &#x3D; &quot;nCount_RNA&quot;, feature2 &#x3D; &quot;nFeature_RNA&quot;)pearplot &lt;- CombinePlots (plots &#x3D; list (plot1, plot2), nrow&#x3D;1, legend&#x3D;&quot;none&quot;)ggsave (&quot;QC&#x2F;pearplot-before-qc.pdf&quot;, plot &#x3D; pearplot, width &#x3D; 12, height &#x3D; 5)ggsave (&quot;QC&#x2F;pearplot-before-qc.png&quot;, plot &#x3D; pearplot, width &#x3D; 12, height &#x3D; 5)## 设置质控标准wang&lt;-subset (wang,subset&#x3D;nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;5000 &amp;percent.mt&lt;0.5)dim (wang)[1] 23228 7626## 绘制质量控制后的图violin &lt;-VlnPlot (wang, features &#x3D; c (&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), pt.size &#x3D; 0.1, ncol &#x3D; 3)ggsave (&quot;QC&#x2F;vlnplot-after-qc.pdf&quot;, plot &#x3D; violin, width &#x3D; 15, height &#x3D; 6)ggsave (&quot;QC&#x2F;vlnplot-after-qc.png&quot;, plot &#x3D; violin, width &#x3D; 15, height &#x3D; 6)## 基因表达量标准化## 它的作用是让测序数据量不同的细胞的基因表达量具有可比性。计算公式如下：## 标准化后基因表达量 &#x3D; log1p（10000 * 基因 counts &#x2F; 细胞总 counts）wang &lt;- NormalizeData (wang, normalization.method &#x3D; &quot;LogNormalize&quot;, scale.factor &#x3D; 10000)质控后细胞数目为 7626，基因数为 23228，原文献中两者的数据分别是 7695 与 23161 # 数据降维与聚类 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3. 数据降维与聚类 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;## 寻找高变基因## dir.create (&quot;cluster&quot;)wang &lt;- FindVariableFeatures (wang,mean.cutoff&#x3D;c (0.0125,3),dispersion.cutoff &#x3D;c (1.5,Inf) )top10 &lt;- head (VariableFeatures (wang), 10)plot1 &lt;- VariableFeaturePlot (wang)plot2 &lt;- LabelPoints (plot &#x3D; plot1, points &#x3D; top10, repel &#x3D; TRUE, size&#x3D;2.5)plot &lt;- CombinePlots (plots &#x3D; list (plot1, plot2),legend&#x3D;&quot;bottom&quot;)## 横坐标是某基因在所有细胞中的平均表达值，纵坐标是此基因的方差。## 红色的点是被选中的高变基因，黑色的点是未被选中的基因，变异程度最高的 10 个基因在如图中标注了基因名称。ggsave (&quot;cluster&#x2F;VariableFeatures.pdf&quot;, plot &#x3D; plot, width &#x3D; 8, height &#x3D; 6)ggsave (&quot;cluster&#x2F;VariableFeatures.png&quot;, plot &#x3D; plot, width &#x3D; 8, height &#x3D; 6)## 数据缩放scale.genes &lt;- rownames (wang)wang &lt;- ScaleData (wang, features &#x3D; scale.genes)## PCA 降维并提取主成分wang &lt;- RunPCA (wang, features &#x3D; VariableFeatures (wang),npcs &#x3D; 100)plot1 &lt;- DimPlot (wang, reduction &#x3D; &quot;pca&quot;)plot2 &lt;- ElbowPlot (wang, ndims&#x3D;40, reduction&#x3D;&quot;pca&quot;)plotc &lt;- plot1+plot2ggsave (&quot;cluster&#x2F;pca.pdf&quot;, plot &#x3D; plotc, width &#x3D; 8, height &#x3D; 4)ggsave (&quot;cluster&#x2F;pca.png&quot;, plot &#x3D; plotc, width &#x3D; 8, height &#x3D; 4)## 细胞聚类## 此步利用 细胞 - PC 值 矩阵计算细胞之间的距离，## 然后利用距离矩阵来聚类。其中有两个参数需要人工选择，## 第一个是 FindNeighbors () 函数中的 dims 参数，需要指定哪些 pc 轴用于分析，选择依据是之前介绍的 cluster&#x2F;pca.png 文件中的右图。## 第二个是 FindClusters () 函数中的 resolution 参数，需要指定 0.1-1.0 之间的一个数值，用于决定 clusters 的相对数量，数值越大 cluters 越多。wang &lt;- FindNeighbors (object &#x3D; wang, dims &#x3D; 1:100)wang &lt;- FindClusters (object &#x3D; wang, resolution &#x3D; 1.0)table (wang@meta.data$seurat_clusters)## 非线性降维## tsnewang &lt;- RunTSNE (wang, dims &#x3D;1:40)embed_tsne &lt;- Embeddings (wang, &#39;tsne&#39;)write.csv (embed_tsne,&#39;cluster&#x2F;embed_tsne_new.csv&#39;)plot1 &#x3D; DimPlot (wang, reduction &#x3D; &quot;tsne&quot; ,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)ggsave (&quot;cluster&#x2F;tSNE_cluster.pdf&quot;, plot &#x3D; plot1, width &#x3D; 8, height &#x3D; 7)ggsave (&quot;cluster&#x2F;tSNE_cluster.png&quot;, plot &#x3D; plot1, width &#x3D; 8, height &#x3D; 7)## UMAP&#39;wang &lt;- RunUMAP (wang,n.neighbors &#x3D; 30,metric &#x3D; &#39;correlation&#39;,min.dist &#x3D; 0.3,dims &#x3D; 1:40)embed_umap &lt;- Embeddings (wang, &#39;umap&#39;)write.csv (embed_umap,&#39;cluster&#x2F;embed_umap_new.csv&#39;)plot2 &#x3D; DimPlot (wang, reduction &#x3D; &quot;umap&quot;,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)ggsave (&quot;cluster&#x2F;UMAP_cluster_new.pdf&quot;, plot &#x3D; plot2, width &#x3D; 8, height &#x3D; 7)ggsave (&quot;cluster&#x2F;UMAP_cluster_new.png&quot;, plot &#x3D; plot2, width &#x3D; 8, height &#x3D; 7)结果是有区别的，我的聚类比原文献中要多一个，而且数字不对应，所以我要用文献中列出的某些基因的小提琴图确定我的聚类 # 根据文献对应自己数据聚类 原文献中有所有聚类的特异基因，所以我根据列出的基因去匹配我的聚类结果 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5. 修改聚类标号 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;## 修改聚类号重新做图new.cluster.ids&lt;-c (&quot;2&quot;,&#39;1&#39;,&#39;4&#39;,&#39;5&#39;,&#39;13&#39;,&#39;3&#39;,&#39;12&#39;,&#39;21&#39;,&#39;8&#39;,&#39;6&#39;,&#39;11&#39;, &#39;9&#39;,&#39;7&#39;,&#39;10&#39;,&#39;6&#39;,&#39;15&#39;,&#39;22&#39;,&#39;14&#39;,&#39;17&#39;,&#39;19&#39;,&#39;16&#39;, &#39;20&#39;,&#39;18&#39;,&#39;23&#39;,&#39;24&#39;)names (new.cluster.ids) &lt;- levels (wang)wang &lt;- RenameIdents (wang, new.cluster.ids)Idents (wang)&lt;-factor (Idents (wang),levels&#x3D;mixedsort (levels (Idents (wang))))wang &lt;- RunTSNE (wang, dims &#x3D;1:40)embed_tsne &lt;- Embeddings (wang, &#39;tsne&#39;)write.csv (embed_tsne,&#39;cluster&#x2F;embed_tsne-new.csv&#39;)plot1 &#x3D; DimPlot (wang, reduction &#x3D; &quot;tsne&quot; ,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)ggsave (&quot;cluster&#x2F;tSNE_cluster-new.pdf&quot;, plot &#x3D; plot1, width &#x3D; 8, height &#x3D; 7)ggsave (&quot;cluster&#x2F;tSNE_cluster-new.png&quot;, plot &#x3D; plot1, width &#x3D; 8, height &#x3D; 7)## UMAPwang &lt;- RunUMAP (wang,n.neighbors &#x3D; 30,metric &#x3D; &#39;correlation&#39;,min.dist &#x3D; 0.3,dims &#x3D; 1:40)embed_umap &lt;- Embeddings (wang, &#39;umap&#39;)write.csv (embed_umap,&#39;cluster&#x2F;embed_umap-new.csv&#39;)plot2 &#x3D; DimPlot (wang, reduction &#x3D; &quot;umap&quot;,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)ggsave (&quot;cluster&#x2F;UMAP_cluster.pdf&quot;, plot &#x3D; plot2, width &#x3D; 8, height &#x3D; 7)ggsave (&quot;cluster&#x2F;UMAP_cluster.png&quot;, plot &#x3D; plot2, width &#x3D; 8, height &#x3D; 7) 修改之后的聚类结果 一些基因的小提琴图对应效果 # 结语 对于这次的数据重复，基本符合预期结果，和文章的结果有点差距，需要自己进一步研究问题出在哪里，下一次将继续这篇文献的数据复现，主要是伪时间分析，目前的数据与代码我已上传 github","tags":"bioinformatics scrnaseq"},{"title":"文献导读：CLAVATA在小立碗藓3D生长中的作用","url":"/2020/10/08/2020-10-08-2Dto3D/","text":"# 前言 小立碗藓登陆后从二维到三维生长决定了陆地植物的生长状态，在这个过程中涉及很多基因的调控，这篇 2018 年发表在《Current Biology》的文献中具体讲述了 CLAVATA 在小立碗藓 3D 生长中的作用。 # introduction 土地的征服是通过一系列的创新来实现的，这些创新允许植物形态在环境中辐射并占据新的空间。其中，将器官径向定位在直立茎周围的创新是大幅提高植物生产力和多样性的一个前提。这种三维的生长形式首先是陆生植物获得的一种新的干细胞功能的结果，即干细胞分裂可通过多个平面方向旋转。藻类谱系不能通过多个平面旋转干细胞分裂，因此通常局限于较小的丝状生长形式。在现代苔藓发育过程中，当分枝的丝状（原丝体）前体组织产生配子体的叶状芽（配子体）时，出现了从 2D 到 3D 生长的进化过程。以前的研究表明，配子体起始是一种半球形扩展，并且它们的 2D 或 3D 的发散命运是由 APETALA2 型（APB）转录因子活性随机决定的。在生长发育的单细胞阶段，持续的 APB 活性和细胞扩展标志着向配子体命运（3D）的转变，而 APB 活性的丧失标志着丝状生长的命运（2D）。强烈斜向细胞分裂是配子体发育的第一个可靠的形态学标记。接下来是第二个斜向的顶端细胞分裂，它大约垂直于第一个，之后分裂平面在两个连续的分裂过程中旋转以建立四面体的顶端干细胞。 四面体顶端细胞在螺旋面上分裂以取代自身并产生子细胞，形成 3D 配子体轴和叶。在进化和发育向 3D 生长的转变过程中，调控这种旋转干细胞分裂平面方向的机制尚不清楚。 &lt;center&gt; (F): 蓝点显示了不规则分裂的起始点 (G): 芽细胞（配丝体初始，左侧）和顶端细胞（轴丝体末端，右侧） (H-K): 顶端芽最初分裂四次，形成四面体形状。黄色箭头表示芽组织的最近的分裂，分裂形式为顶端 - 基部形式（a-b）和中 - 外侧形式（m-l），数字表示分裂次数 (L): 图（H-K）中所示的浓密枝条的分区的表示法。阴影区域表示（G）（K）中用蓝点标记的初始单元格，数字表示（I）（K）中所示的域。 &lt;/center&gt; 在拟南芥中，CLAVATA（CLV）和 WUSCHEL（WUS）通路在反馈回路中起作用，调节干细胞功能的许多方面，包括细胞命运、增殖和生长。CLV3 编码一种小的分泌肽，在中央区的上层细胞中表达，可以在分生组织中移动。CLV1 在中央区的底层细胞层中表达，编码一种激酶，它与 CLV2、CORYNE（CRN）、RECEPTOR-LIKE PROTEIN KINASE 2（RPK2）和 BARELY ANY MERISTEM（BAM）一起作为 CLV3 的受体。WusA 活性促进分生组织细胞增殖，而 CLV 信号则限制 WUS 表达域的大小。WUS 的作用是非细胞自主的，从组织中心移动到最上层的分生组织细胞层，在那里它促进 CLV3 的表达，从而关闭维持分生组织大小的反馈回路。 # results # CLAVATA 路径起源于陆地植物的最后一个共同祖先 为了确定 CLV 途径是如何进化的，并确定 CLV 在小立碗藓干细胞功能中的潜在作用，首先从大量绿藻和陆地植物中查询了 CLV3-like（CLE）、CLV1/BAM、RPK2、CLV2 和 CRN 同源物。绿藻或轮藻中未发现 CLV 途径同源物，但在每个早期苔藓植物谱系和所有其他陆地植物中至少发现一个 CLE 同源物和一个 CLV1/BAM 同源物，这表明 CLV 的核心信号模块至少包含一个 CLE 肽和一个 CLV/BAM 受体样激酶。RPK2 同源基因存在于所有的陆生植物中，除了角苔中的 Anthoceros agrestis。在小立碗藓中，鉴定出 7 个基因具有保守的 CLE 结构域，编码一个类似于 CLV3 的 12 个氨基酸肽基序，但是保守的 CLE 结构域之外的序列是不同的。基因组编码四种 CLV3-like 肽段：PpCLE1、2 和 3 编码肽段基序 RMVPTGPNPLHN；PpCLE4 编码基序 RMVPSGPNPLHN；PpCEL5 和 6 编码基序 RLVPTGPNPLHN；PpCLE7 编码基序 RVVPTGPNPLHN。利用保守激酶结构域中的氨基酸进行最大似然分析重建激酶系统发育树。对包含每个陆生植物谱系的 CLV1/BAM-like 序列或包含每个谱系的 RPK2-like 序列的分支进行了解析，CLV1/BAM 和 RPK2 的系统发育与目前陆地植物进化的假设基本一致。在 CLV1/BAM 分支中有两个小立碗藓的基因，CLAVATA1a 和 1b（PpCLV1a 和 PpCLV1b）。发现一个 RPK2 同源物，命名为 PpRPK2，但未发现 CLV2 或 CRN 同源物。这些序列数据表明，CLV 途径的核心成分首先出现在陆地植物的最后一个共同祖先，伴随着 3D 生长的进化而创新。 &lt;center&gt; CLV 通路起源于陆生植物的最后一个共同祖先，与三维生长 (A) 的谱系同时发生，绿藻类和轮藻类的细胞分裂是单向的，而陆生植物的细胞分裂是多向的，从而产生复杂的三位生长，通过 BLAST 比对基因组或草图基因组 (G) 和转录组 (T) 数据库确定 CLV 通路同源物的数量。chl：绿藻，cha：轮藻，H：角苔类，M：藓类，L：苔类，VP：维管植物 &lt;/center&gt; # CLAVATA 通路成分在 3D 生长阶段表达 为了研究小立碗藓 CLV 的活性，首先分析了与 2D 丝状体和 3D 配子体转换期相关的基因表达模式，通过 RT-PCR，检测到 PpCLE1、2 和 7 肽编码基因在配子体中的表达，PpCLE3、4、5 的基因检测不到表达，PpCLE6 在原丝体中表达。受体编码基因 PpRPK2、PpCLV1a 和 PpCLV1b 在配子体中共表达，尽管在第 10 天丝状组织中 PpRPK2 的表达明显早于 PpCLV1a 和 PpCLV1b，这些结果与来自转录组数据的报告大体一致。接下来，为 PpCLE1、2、7、PpCLV1a、PpCLV1b 和 PpRPK2 构建了启动子。在 3 周左右时，PpCLE1、PpCLE2、PpCLE7 和 PpCLV1a 株在芽周围的各种原丝体细胞类型中积累了局部信号，PpCLV1b 和 PpRPK2 在芽中积累信号，且信号向顶端最强。虽然所有的基因在配子体轴和叶中积累了信号，但不同基因之间信号积累的模式、时间和强度存在差异。而且 PpCLE1、PpCLE2、PpCLE7 和 PpCLV1a 在配子体中的信号积累与 PpCLV1b 和 PpRPK2 不相同。GUS 结果表明，在小立碗藓中，PpCLE1、PpCLE2、PpCLE7、PpCLV1a、PpCLV1b 和 PpRPK2 表达具有高度动态性。来自顶端细胞的第二轮细胞分裂也有不同的分裂平面，这些平面通常与第一分裂平面平行而不是垂直。 &lt;center&gt; (A-D') 中的所有组织在含有 0.5mMFeCN 的溶液中染色，染色时间在 (A-F) 中规定，(E-J') 中的配子体在含有 2 mMFeCN 的溶液中染色时间延长了 3 倍。 &lt;/center&gt; # CLAVATA 的突变体影响小立碗藓从二维到三维的转变 为了确定 CLV 途径成分的功能，构建了上述基因的敲除突变体，PpcleAmiR1-3、PpcleAmiR4-7、Ppclv1a1b 和 Pprpk2 株系能够形成致密的原丝体组织，因此具有相对正常的 2D 生长期，然而，在 3D 生长阶段，所有四个突变体都有发育缺陷，成熟配子体总数减少，配子体发育缺陷。一步的研究发现，在 ppclemir1-3、ppclemir4-7 和 Pprpk2 突变体中，与野生型（WT）相比，具有 1 片或更少叶的配子体芽更多，并且 Ppclv1a1b 突变体在发育后期有许多小配子体停滞。这些数据表明配子体发育早期存在缺陷，可能反馈到配子体起始过程。为了确定 WT 和突变表型在发育过程中是如何分化的，我们对 2 细胞阶段、4 细胞阶段和芽发育后期的配子体芽进行了成像，虽然野生型配子体启动正常，并表现出典型的斜向细胞分裂平面方向，但在 PpcleAmiR1-3 和 PpcleAmiR4-7 突变体中，第一次分裂平面被严重破坏，并且相对于生长主轴的角度较小，在顶端细胞四面体形状正常形成的发育阶段，突变体也有缺陷，表明生长和细胞命运规范存在问题，似乎重复了第一个配子体最初的正常分裂特征。Ppclv1a1b 突变体表型在 2 细胞阶段期之后与 WT 不同，随后显示出与 ppclemir1-3 和 ppclemir4-7 突变体相似的分裂模式，并且一些细胞恢复为原丝体特性。Pprpk2 突变体缺陷在发育初期不如 Ppcle 和 Ppclv1a1b 缺陷严重，在发育后期，细胞形态肿胀表明了生长缺陷和分裂面缺陷。上述突变表型表明，Physocmitrella CLV 通路在调节细胞分裂平面、细胞命运、生长和增殖过程中的关键作用。第一次分裂中平面定向缺陷的表现表明，WT 和突变配子体的发育在细胞命运确定后的单细胞阶段发生分化。 # 在小立碗藓和拟南芥中，CLAVATA 在调节细胞分裂平面方向中的作用是保守的 由于 CLV 在细胞分裂平面定位中的作用以前未被报道，作者又试图在拟南芥中鉴定其功能的保守性。为此，检测了拟南芥 clv1/bam1/bam2/bam3 四重突变体分生组织，其中 CLV/BAM 基因的整个分支功能缺失。尽管分裂平面方向在根分生组织中通常是定型的，但在 clv1/bam1/bam2/bam3 突变体根的干细胞生态位和基础组织层中发现了严重的无序平面。 # CLAVATA 的突变体的配子体发育有缺陷 在拟南芥和其他开花植物中，CLV 途径主要作用是维持分生组织干细胞池大小，在 clv1 和 clv3 (cle) 突变体中，干细胞数量的增加导致分生组织面积相应增加。但是小立碗藓不适合拟南芥分生组织功能的范式，因为茎尖由一个单一的顶端干细胞组成。顶端细胞以螺旋状分裂生产生子细胞，然后分裂产生叶母细胞和茎组织。为了研究 CLV 在调节干细胞功能中的作用在小立碗藓和拟南芥之间是否是保守的，对 1 个月大的 WT 和突变体的最大配子体进行成像，发现突变体配子体高度降低，并有发育缺陷。PpcleAmiR1-3、PpcleAmiR4-7、Ppclv1a1b 和 Pprpk2 突变体叶片发育缺陷，而 Ppclv1b、Ppclv1a1b 和 Pprpk2 突变体也存在强烈的细胞增殖缺陷，在配子体基部形成愈伤组织样块（粉色箭头）。进一步的检查显示，这些团块是由配子体基部许多异位顶端细胞的活性引起的。这些功能缺失数据表明，CLV 在调节干细胞功能方面发挥了作用，而这一功能在小立碗藓和拟南芥中保存下来。 &lt;center&gt; (A-E) 突变体配子体形态的光显微图显示，配子体 (B) 停止生长，(C 和 E) 发育多个轴 (粉色箭头)，(C E) 相对于 (A) 野生型植株有显著的横向扩张。(H) 小立碗藓配子体顶端组织，顶端细胞 (淡黄色) 和旋转分裂平面方向的示意图。(I-K) PpcleAmiR1-3 突变配子体形态，(I) 配子体基部过度增殖 (J 和 K) 顶端分生组织紊乱生长。(L- N) PpcleAmiR4-7 突变体配子体形态具有 (L) 叶片分裂表型和 (M 和 N) 分生组织过度增殖和终止。（O-Q）Ppclv1a1b 突变体配子体形态（O），在配子体基部有多个生长轴和多个分生组织（P 和 Q）。（R-T）Pprpk2 突变体配子体形态，在配子体基部（S 和 T）具有多个生长轴（R）和多个分生组织。黄色箭头表示过度增殖或异位分生组织区域。 &lt;/center&gt; # CLE 能抑制小立碗藓配子体细胞的增殖 为了进一步分析 CLV 功能的保守性，用人工合成的 CLE 肽段处理。在生长 4 周后，发现用 1-mM 浓度的 CLE 处理对植株的扩散或配子体启动的数量没有明显的影响，表明原丝体发育正常。尽管所有的肽段对配子体发育没有明显的影响，但拟南芥的 CLV3 和所有的 PpCLE 均会导致配子体矮化和叶片大小的显著变小，并与叶片细胞数量减少相关。虽然这种表型在表面上类似于 PpcleAmiR1-3 和 PpcleAmiR4-7 突变体发育不良的配子体表型，但我们没有发现 CLE 处理后发育阻滞或分生组织过度增殖的迹象，而且在 CLE 处理后也没有检测到配子体起始数量的差异 (数据未显示)。这些数据表明，CLE 通过一个保守的信号模块调控小立碗藓的 3D 生长阶段的细胞增殖。 # CLE 肽可通过在小立碗藓和拟南芥中保存的受体成分发挥作用 以前对拟南芥的研究表明，在根上施用 CLEs 可以阻止分生组织的功能。为了检测肽功能的保存，将拟南芥种子在含有 1uM 浓度溶质或肽的 MS 培养基上。尽管溶质对照、随机肽和 TDIF 没有导致根发育停滞，但 CLV3 和所有 PpCLEs 导致拟南芥的长度显著变短，这是由于根分生组织的塌陷造成的。虽然用 CLE 肽段处理野生拟南芥植株强烈抑制根系生长，但当用拟南芥和小立碗藓肽段处理时，rpk2 突变体的表型变化不如野生型显著。这些数据与先前发表的结果一致，这些结果表明 RPK2 在其他受体中起作用以促进拟南芥中的 CLV 信号，并且表明 PpCLEs 也可以通过 RPK2 在拟南芥中起作用。 为了确定 PpCLEs 是否通过 PpRPK2 起作用，在 WT、Ppcle 和 PpRPK2 突变背景下进行了类似的实验。Ppcle 突变配子体大小与 Pprpk2 突变配子体大小大致相同，如果 Ppcle 通过 Pprpk2 起作用，应该在 Ppcle 突变体中检测到反应，而不是 Pprpk2 突变体。与之前的实验一样，野生植物配子体发育受到强烈的抑制。可能由于缺乏位置信息，用 CLE 肽处理 Ppcle 突变体并不能挽救发育缺陷，但仍然诱导配子体矮化反应，与完整的受体机制一致。相比之下，Pprpk2 突变体对 CLE 应用没有形态反应，这表明 PPCLE 通过 Pprpk2 调节 3D 生长。 # 讨论 # CLV 模式细胞分裂平面方向如何 CLV 通路通过定向配子体细胞分裂平面、调控生长和命运来调控小立碗藓的 2D 到 3D 发育转变。配体和受体如何共同作用来完成这一过程还不清楚。一种可能是 CLE 配体的扩散产生了一个浓度梯度，使分裂面形成图案。拟南芥中 CLE 模式的形成层分生组织也有类似的机制，CLE41 在韧皮部合成并扩散与邻近原形成层细胞中的 PXY 受体结合，而为斜周分裂提供空间信息。CLE41 的结构性或异位表达扰乱了这种位置信息，导致形成层分裂面紊乱。在小立碗藓中，相似的模式化可以通过受体的亚细胞定位来实现，在芽的初始阶段，也可以通过在芽的不同部分表达受体来实现。 也有可能 CLV 信号不直接影响晚期细胞分裂平面，但 CLV 通过激素信号、细胞几何学和 / 或细胞力学来影响细胞分裂平面。生长素信号和微管相互作用蛋白的活性，如 CLIP-associated proteins（claps），已知在拟南芥胚胎中指定细胞分裂平面，并且生长素信号调节先前确定的在小立碗藓芽中正确的分裂平面定向所必需的因子的活性，包括 DEK1 和 NOG1。在小立碗藓中，生长素和细胞分裂素之间似乎存在着复杂的相互作用，一些表型表明这种相互作用在 Ppcle、Ppclv 和 Pprpk2 突变体中被破坏。例如，在用 CLEs 处理的植物中，配子体基部的细胞命运和增殖受到干扰，叶细胞的增殖受到干扰，这些发育方面受到生长素和细胞分裂素的调控。将 CLV 信号与调节生长和命运的激素途径联系起来，对于揭示 3D 生长过程中细胞分裂平面规范的机制具有重要意义。 # CLV 调控的干细胞功能是陆地植物的祖先特征 CLV 途径起源于陆生植物，CLV 调节干细胞的增殖和功能可能是陆生植物的祖先特征。陆生植物获得了干细胞在多个平面分裂的定向能力，这使得植物能够发展出器官在多个方向排列的直立轴，从而实现了细胞的多样化，这是茎部进化的关键一步。Ppcle 突变体的干细胞分裂平面缺陷特异性地影响了 3D 生长阶段的过渡。因此，在一个古老的陆地植物群中，CLV 调节了反映进化过渡的发育过渡。结果表明，CLV 是陆生植物重要形态创新的一个遗传新颖性。 # CLV 调控的分生组织功能早于 WOX 和 KNOX 调控的分生组织功能 第一批陆地植物分生组织由一个配子体干细胞组成，而维管植物的多细胞孢子体分生组织结合了干细胞和更普遍的增殖能力。Ⅰ 类 KNOX 基因调控维管植物分生组织增殖，但这些作用在苔藓植物和维管植物之间并不相同。Moss-KNOX（MKN）基因主要在孢子体组织中表达，虽然功能缺失的 mkn2 突变体在孢子体中存在伸长缺陷，但它们具有正常的配子体。WOX 基因是拟南芥干细胞增殖的关键调控因子。然而，这一功能是由新近衍生的 WUSgene 分支获得的，并且由于 Ppwox13L 突变配子体发育正常，在 Physocmitrela 中 CLV 调控的下游通路可能与拟南芥中的不同。因此，Ⅰ 类 KNOX 和 WOX 调控的分生组织功能都是在苔藓维管植物分化后获得的。CLV 在陆生植物生命周期配子体阶段分生组织功能的起源中起重要作用，我们推测 CLV 在 KNOX 和 WOX 调节分生组织功能起源之前被招募来调节生活周期孢子体阶段的干细胞功能。","tags":"literature_reading"},{"title":"单细胞实战(4)：STAR与cellranger结果比较","url":"/2020/10/06/2020-10-06-ScRNAseq(4)/","text":"# 前言 本次主要使用 Seurat 比较 STAR 与 Cellranger 的输出结果，只会进行简单的聚类工作。 # 数据读入 &gt; library (Seurat)&gt; library (dplyr)&gt; library (magrittr)&gt; library (gtools)&gt; library (stringr)&gt; library (Matrix)&gt; setwd (&quot;D:&#x2F;&#x2F;data&#x2F;ScRNAcode&quot;)## 读入 STAR 数据&gt; matrix.dir&#x3D;&quot;STAR&#x2F;&quot;&gt; barcode.path &lt;- paste0 (matrix.dir,&quot;barcodes.tsv&quot;)&gt; features.path &lt;- paste0 (matrix.dir,&quot;features.tsv&quot;)&gt; matrix.path &lt;- paste0 (matrix.dir, &quot;matrix.mtx&quot;)&gt; STARmatrix &lt;- readMM (file &#x3D; matrix.path)&gt; feature.names &#x3D; read.delim (features.path,+ header &#x3D; FALSE,+ stringsAsFactors &#x3D; FALSE)&gt; barcode.names &#x3D; read.delim (barcode.path,+ header &#x3D; FALSE,+ stringsAsFactors &#x3D; FALSE)&gt; colnames (STARmatrix) &#x3D; barcode.names$V1&gt; rownames (STARmatrix) &#x3D; feature.names$V2&gt; STARmatrix&lt;-as.matrix (STARmatrix)&gt; STARmatrix [1:6,1:6]## 创建 seurat 对象## 创建 STAR 的 Seurat 对象&gt; STAR &lt;- CreateSeuratObject (STARmatrix,project &#x3D; &quot;zsz&quot;, min.cells &#x3D; 3, min.features &#x3D; 200)## 创建 Cellranger 的 Seurat 对象&gt; dir&#x3D;&quot;cellranger&#x2F;&quot;&gt; counts &lt;- Read10X (data.dir &#x3D; dir)&gt; RANGER &lt;- CreateSeuratObject (counts, project &#x3D; &quot;zsz&quot;, min.cells&#x3D;3, min.features &#x3D; 200)# 数据比较 &gt; ## 数据比较&gt; dim (STARmatrix)[1] 33538 2048&gt; dim (counts)[1] 33538 2112&gt; dim (STAR)[1] 13350 2046&gt; dim (RANGER)[1] 13314 2105&gt; fivenum (apply (STARmatrix,1,function (x) sum (x&gt;0)))MIR1302-2HG IGFBPL1 AL008723.2 FXYD7 MT-CO1 0 0 0 29 2047&gt; fivenum (apply (counts,1,function (x) sum (x&gt;0)))MIR1302-2HG FAM221B LINC01638 DGKE MT-CO1 0 0 0 29 2108&gt; pdf (&quot;box.pdf&quot;,height &#x3D; 9,width &#x3D; 9)&gt; boxplot (apply (STARmatrix,1,function (x) sum (x&gt;0) ),main &#x3D; &quot;STAR&quot;,col &#x3D; &quot;lightgray&quot;)&gt; boxplot (apply (counts,1,function (x) sum (x&gt;0) ),main &#x3D; &quot;Cellranger&quot;,col &#x3D; &quot;lightgray&quot;)&gt; dev.off ()RStudioGD 2&gt; pdf (&quot;hist.pdf&quot;,height &#x3D; 9,width &#x3D; 9)&gt; hist (apply (STARmatrix,2,function (x) sum (x&gt;0) ),col &#x3D; &quot;lightgray&quot;,+ breaks&#x3D;20,xlim&#x3D;c (0,4000),ylim&#x3D;c (0,800),+ labels&#x3D;F,main&#x3D;&quot;STAR&quot;,+ xlab&#x3D;&quot;genes&quot;,ylab&#x3D;&quot;cells&quot;)&gt; abline (v&#x3D;median (apply (STARmatrix,2,function (x) sum (x&gt;0))),col&#x3D;&#39;red&#39;)&gt; hist (apply (counts,2,function (x) sum (x&gt;0) ),col &#x3D; &quot;lightgray&quot;,+ breaks&#x3D;20,xlim&#x3D;c (0,4000),ylim&#x3D;c (0,800),+ labels&#x3D;F,main&#x3D;&quot;Cellranger&quot;,+ xlab&#x3D;&quot;genes&quot;,ylab&#x3D;&quot;cells&quot;)&gt; abline (v&#x3D;median (apply (counts,2,function (x) sum (x&gt;0))),col&#x3D;&#39;red&#39;)&gt; dev.off () 根据箱线图，直方图和矩阵的基本信息，可以看到 STAR 与 cellranger 的结果差距很小 # 质量控制与聚类比较 &gt; pdf(&quot;qc.pdf&quot;,height &#x3D; 9,width &#x3D; 9)&gt; VlnPlot(STAR,+ features &#x3D; c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;),+ pt.size &#x3D; 0.1,+ ncol &#x3D; 2)&gt; VlnPlot(RANGER,+ features &#x3D; c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;),+ pt.size &#x3D; 0.1,+ ncol &#x3D; 2)&gt; dev.off()RStudioGD 2 &gt; STAR&lt;-subset(STAR,subset&#x3D;nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;2000)&gt; STAR &lt;- NormalizeData(STAR, normalization.method &#x3D; &quot;LogNormalize&quot;, scale.factor &#x3D; 10000)Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; table(STAR@meta.data$orig.ident) zsz1896&gt; STAR &lt;- FindVariableFeatures(STAR, selection.method &#x3D; &quot;vst&quot;, nfeatures &#x3D; 2000)Calculating gene variances0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|Calculating feature variances of standardized and clipped values0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; top10 &lt;- head(VariableFeatures(STAR), 10)&gt; top10 [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;IGLC2&quot; &quot;IGKC&quot; &quot;LYZ&quot; &quot;IGLC3&quot; &quot;CCL3&quot; &quot;NFKBIA&quot; &quot;PTGDS&quot; &quot;S100A12&quot; &gt; RANGER&lt;-subset(RANGER,subset&#x3D;nFeature_RNA&gt;500 &amp; nFeature_RNA&lt;2000)&gt; RANGER&lt;- NormalizeData(RANGER, normalization.method &#x3D; &quot;LogNormalize&quot;, scale.factor &#x3D; 10000)Performing log-normalization0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; table(RANGER@meta.data$orig.ident) zsz1895&gt; RANGER &lt;- FindVariableFeatures(RANGER, selection.method &#x3D; &quot;vst&quot;, nfeatures &#x3D; 2000)Calculating gene variances0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|Calculating feature variances of standardized and clipped values0% 10 20 30 40 50 60 70 80 90 100%[----|----|----|----|----|----|----|----|----|----|**************************************************|&gt; top10 &lt;- head(VariableFeatures(RANGER), 10)&gt; top10 [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;IGLC2&quot; &quot;IGKC&quot; &quot;LYZ&quot; &quot;CCL3&quot; &quot;NFKBIA&quot; &quot;IGLC3&quot; &quot;PTGDS&quot; &quot;S100A12&quot;&gt; scale.genes &lt;- rownames(STAR)&gt; STAR &lt;- ScaleData(STAR, features &#x3D; scale.genes)&gt; STAR &lt;- RunPCA(STAR, features &#x3D; VariableFeatures(STAR))&gt; plot1 &lt;- ElbowPlot(STAR, ndims&#x3D;30, reduction&#x3D;&quot;pca&quot;)&gt; scale.genes &lt;- rownames(RANGER)&gt; RANGER &lt;- ScaleData(RANGER, features &#x3D; scale.genes)&gt; RANGER &lt;- RunPCA(RANGER, features &#x3D; VariableFeatures(RANGER))&gt; plot2 &lt;- ElbowPlot(RANGER, ndims&#x3D;30, reduction&#x3D;&quot;pca&quot;)&gt; plotc &lt;- plot1+plot2&gt; ggsave(&quot;pca.pdf&quot;, plot &#x3D; plotc, width &#x3D; 8, height &#x3D; 4) &gt; STAR &lt;- FindNeighbors(STAR, dims &#x3D; 1:10)&gt; STAR &lt;- FindClusters(STAR, resolution &#x3D; 0.8)&gt; table(STAR@meta.data$seurat_clusters) 0 1 2 3 4 5 6 7 8 9368 310 290 217 184 129 119 112 92 75&gt; metadata &lt;- STAR@meta.data&gt; cell_cluster &lt;-data.frame(cell_ID&#x3D;rownames(metadata),cluster_ID&#x3D;metadata$seurat_clusters)&gt; STAR &lt;- RunUMAP(STAR, dims &#x3D; 1:20)&gt; embed_tsne &lt;- Embeddings(STAR, &#39;umap&#39;)&gt; plot1 &#x3D; DimPlot(STAR, reduction &#x3D; &quot;umap&quot; ,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)&gt; RANGER &lt;- FindNeighbors(RANGER, dims &#x3D; 1:10)&gt; RANGER &lt;- FindClusters(RANGER, resolution &#x3D; 0.8)&gt; table(RANGER@meta.data$seurat_clusters) 0 1 2 3 4 5 6 7 8 9375 300 290 212 195 128 122 108 91 74&gt; metadata &lt;- RANGER@meta.data&gt; cell_cluster &lt;- data.frame(cell_ID&#x3D;rownames(metadata), cluster_ID&#x3D;metadata$seurat_clusters)&gt; RANGER &lt;- RunUMAP(RANGER,n.neighbors &#x3D; 30,dims &#x3D; 1:20)&gt; embed_umap &lt;- Embeddings(RANGER, &#39;umap&#39;)&gt; plot2 &#x3D; DimPlot(RANGER, reduction &#x3D; &quot;umap&quot; ,label &#x3D; &quot;T&quot;, pt.size &#x3D; 1,label.size &#x3D; 4)&gt; plotc &lt;- plot1+plot2&gt; ggsave(&quot;umap.pdf&quot;, plot &#x3D; plotc, width &#x3D; 8, height &#x3D; 4) 可以看到两种分析方法 umap 与 tsne 聚类效果不太相同，但是基本的聚类与分群是一致的 # 结语 就结果而言，两种分析方法的结果不完全相同，但也基本一致，本次笔记中用到的数据和代码已上传 github，在 ScRNAseq_code/compare 文件夹下，大家需要的可以下载试试","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(3)：STAR分析单细胞数据","url":"/2020/10/03/2020-10-03-ScRNAseq(3)/","text":"# 前言 在利用 cellranger 比对单细胞 reads 时，可以发现有 STAR 的进程夹杂在里面，那么 STAR 可以用来比对单细胞数据吗？在 STAR 的 2.7 版本中 (2.7.6a) 出现了 STARsolo，可以进行单细胞数据的比对，由此可见 STAR 的强大 # Cellranger 输出结果 在使用 STAR 之前，先看一下 cellranger 的输出结果 .├── analysis│ ├── clustering│ ├── diffexp│ ├── pca│ ├── tsne│ └── umap├── cloupe.cloupe├── filtered_feature_bc_matrix│ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz├── filtered_feature_bc_matrix.h5├── metrics_summary.csv├── molecule_info.h5├── possorted_genome_bam.bam├── possorted_genome_bam.bam.bai├── raw_feature_bc_matrix│ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz├── raw_feature_bc_matrix.h5└── web_summary.html为方便查看，cellranger 提供了一个网页端的结果，我们主要观察细胞和基因数目的评估即可，后续的聚类工作由 seurat 完成 在结果目录，可以看到如下两个目录 raw_feature_bc_matrix filtered_gene_bc_matrices raw 目录下是所有的 barcode 信息，包含了细胞相关的 barcoed 和背景 barcode, 而 filter 目录下只包含细胞相关的 barcode 信息，内容如下 │ ├── barcodes.tsv.gz│ ├── features.tsv.gz│ └── matrix.mtx.gz后缀为 mtx 的文件记录的就是基因的表达量信息，可以导入 R 或者 python 中查看，barcodes 相当于一个细胞，features 代表不同的基因，barcodes 文件在 STARsolo 中会用到，这就是为什么我要先说明一下 cellranger 的输出结果 # 利用 STAR 分析 10X 数据 STARsolo 被设计为替代 10X CellRanger 基因定量比对软件。而且 STARsolo 的速度是 cellranger 的十倍（具体怎么样我也不知道） 建立索引： STAR --runMode genomeGenerate --genomeDir ghg38&#x2F; --genomeFastaFiles Homo_sapiens.GRCh38.dna.primary_assembly.fa --sjdbGTFfile Homo_sapiens.GRCh38.93.filtered.gtf其实利用 cellranger 构建的索引原则上也能用，在 GRCh38/star/ 下，但是由于 STAR 版本问题可能会导致无法识别，因为 cellranger 用的 STAR 构建的索引和我们自己用的 STAR 版本是不一致的。 STARsolo 与普通的转录组比对区别在于你需要在比对时加上 whitelist，whitelist 文件格式在 10X 官网有写，我们可以利用 cellranger 的 barcodes.tsv.gz 文件获得 zcat barcodes.tsv.gz&gt;whitelistsed -i &quot;s\\-1\\\\g&quot; whitelist需要注意 ReadFilesIn 先读入测序数据，再读入 barcode+UMI 文件，即先读入 R2 再读入 R1 STAR --genomeDir ghg38&#x2F; --readFilesCommand zcat --readFilesIn SRR7722939&#x2F;SRR7722939_S1_L001_R2_001.fastq.gz SRR7722939&#x2F;SRR7722939_S1_L001_R1_001.fastq.gz --soloType CB_UMI_Simple --soloCBwhitelist whitelist --runThreadN 8结果默认保存在 Solo.out 文件中，8 线程只用了 10min 左右，确实要快一点 ├── Barcodes.stats└── Gene ├── Features.stats ├── filtered │ ├── barcodes.tsv │ ├── features.tsv │ └── matrix.mtx ├── raw │ ├── barcodes.tsv │ ├── features.tsv │ └── matrix.mtx ├── Summary.csv └── UMIperCellSorted.txt看一下 Summary 里是啥 Number of Reads,23095815Reads With Valid Barcodes,0.979732Sequencing Saturation,0.529367Q30 Bases in CB+UMI,0.991351Q30 Bases in RNA read,0.842989Reads Mapped to Genome: Unique+Multiple,0.959769Reads Mapped to Genome: Unique,0.874368Reads Mapped to Transcriptome: Unique+Multipe Genes,0.63797Reads Mapped to Transcriptome: Unique Genes,0.613655Estimated Number of Cells,2048Reads in Cells Mapped to Unique Genes,12815372Fraction of Reads in Cells,0.904219Mean Reads per Cell,6257Median Reads per Cell,5544UMIs in Cells,5978718Mean UMI per Cell,2919Median UMI per Cell,2577Mean Genes per Cell,915Median Genes per Cell,873Total Genes Detected,16265可以看到比起 cellranger，STAR 捕获到的细胞数少一点，而且每个细胞的 reads 要低一点，其他差不多，后续将使用 Seurat 包对两组数据进行比较 # STARsolo 其他命令 --soloType default: None string(s): type of single-cell RNA-seq CB_UMI_Simple (a.k.a. Droplet) one UMI and one Cell Barcode of xed length in read2, e.g. Drop-seq and 10X Chromium. CB_UMI_Complex one UMI of xed length, but multiple Cell Barcodes of varying length, as well as adapters sequences are allowed in read2 only, e.g. inDrop. CB_samTagOut output Cell Barcode as CR and/or CB SAm tag. No UMI counting. {readFilesIn cDNA read1 [cDNA read2 if paired-end] CellBarcode read . Requires {outSAMtype BAM Unsorted [and/or SortedByCoordinate] SmartSeq Smart-seq: each cell in a separate FASTQ (paired- or single-end), barcodes are corresponding read-groups, no UMI sequences, alignments deduplicated according to alignment start and end (after extending soft-clipped bases) --soloCBwhitelist default: - string(s): le(s) with whitelist(s) of cell barcodes. Only {soloType CB UMI Complex allows more than one whitelist le. None no whitelist: all cell barcodes are allowed --soloCBstart default: 1 int&gt;0: cell barcode start base --soloCBlen default: 16 int&gt;0: cell barcode length --soloUMIstart default: 17 int&gt;0: UMI start base --soloUMIlen default: 10 int&gt;0: UMI length --soloBarcodeReadLength default: 1 int: length of the barcode read 1 equal to sum of soloCBlen+soloUMIlen 0 not de ned, do not check --soloCBposition default: - strings(s) position of Cell Barcode(s) on the barcode read. Presently only works with {soloType CB UMI Complex, and barcodes are assumed to be on Read2. Format for each barcode: startAnchor startPosition endAnchor endPosition start(end)Anchor de nes the Anchor Base for the CB: 0: read start; 1: read end; 2: adapter start; 3: adapter end start(end)Position is the 0-based position with of the CB start(end) with respect to the Anchor Base String for di erent barcodes are separated by space. Example: inDrop (Zilionis et al, Nat. Protocols, 2017): {soloCBposition 0 0 2 -1 3 1 3 8 --soloUMIposition default: - string position of the UMI on the barcode read, same as soloCBposition --soloAdapterSequence default: - string: adapter sequence to anchor barcodes. --soloAdapterMismatchesNmax default: 1 int&gt;0: maximum number of mismatches allowed in adapter sequence. --soloCBmatchWLtype default: 1MM multi string: matching the Cell Barcodes to the WhiteList Exact only exact matches allowed 1MM only one match in whitelist with 1 mismatched base allowed. Allowed CBs have to have at least one read with exact match. 1MM_multi multiple matches in whitelist with 1 mismatched base allowed, posterior probability calculation is used choose one of the matches. Allowed CBs have to have at least one read with exact match. Similar to CellRanger 2.2.0 1MM_multi_pseudocounts same as 1MM Multi, but pseudocounts of 1 are added to all whitelist barcodes. Similar to CellRanger 3.x.x --soloStrand default: Forward string: strandedness of the solo libraries: Unstranded no strand information Forward read strand same as the original RNA molecule Reverse read strand opposite to the original RNA molecule --soloFeatures default: Gene string(s): genomic features for which the UMI counts per Cell Barcode are collected Gene genes: reads match the gene transcript SJ splice junctions: reported in SJ.out.tab GeneFull full genes: count all reads overlapping genes' exons and introns --soloUMIdedup default: 1MM_All string(s): type of UMI deduplication (collapsing) algorithm 1MM_All all UMIs with 1 mismatch distance to each other are collapsed (i.e. counted once) 1MM_Directional follows the &quot;directional&quot; method from the UMI-tools by Smith, Heger and Sudbery (Genome Research 2017). Exact only exactly matching UMIs are collapsed NoDedup no deduplication of UMIs, count all reads. Allowed for --soloType SmartSeq --soloUMIfiltering default: - string(s) type of UMI ltering - basic ltering: remove UMIs with N and homopolymers (similar to CellRanger 2.2.0) MultiGeneUMI remove lower-count UMIs that map to more than one gene (introduced in CellRanger 3.x.x) --soloOutFileNames default: Solo.out/ features.tsv barcodes.tsv matrix.mtx string(s) le names for STARsolo output: le name pre x gene names barcode sequences cell feature count matrix --soloCellFilter default: CellRanger2.2 3000 0.99 10 string(s): cell ltering type and parameters CellRanger2.2 simple ltering of CellRanger 2.2, followed by three numbers: number of expected cells, robust maximum percentile for UMI count, maximum to minimum ratio for UMI count TopCells only report top cells by UMI count, followed by the exact number of cells None do not output ltered cells --soloOutFormatFeaturesGeneField3 default: &quot;Gene Expression&quot; string(s): eld 3 in the Gene features.tsv le. If &quot;-&quot;, then no 3rd ld is output.","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(2)：cellranger使用","url":"/2020/10/01/2020-10-01-ScRNAseq(2)/","text":"# 将 SRA 转为 fastq 数据下载好之后，我们得到的是 SRR 文件，需要将其转换为 fastq 格式才能使用 wkd&#x3D;&#x2F;home&#x2F;project&#x2F;single-cell&#x2F;MCCcat SRR_Acc_List-2586-4.txt |while read idofastq-dump --gzip --split-files $&#123;i&#125;.sradone结束之后每个 SRR 文件会变成解压出三个文件 为什么会有三个文件，这个需要去查一下 10X 的官方说明 可以看到 Read1 是 26bp，主要是 16bp 的 barcode 和 10bp 的 UMI，Read2 的长度不固定，所以不一定是 98bp，视情况而定，还有一个 I7 index 长度是 8bp 接下来就按照 10X 的标准去对文件进行改名 cat SRR_Acc_List-9245-3.txt | while read idomv $&#123;i&#125;_1*.gz$&#123;i&#125;_S1_L001_I1_001.fastq.gzmv $&#123;i&#125;_2*.gz $&#123;i&#125;_S1_L001_R1_001.fastq.gzmv $&#123;i&#125;_3*.gz $&#123;i&#125;_S1_L001_R2_001.fastq.gzdone之后我创建了文件夹将每个 SRR 数据的三个 fastq 文件放到一个文件夹下 SRR7722937├── SRR7722937_S1_L001_I1_001.fastq.gz├── SRR7722937_S1_L001_R1_001.fastq.gz└── SRR7722937_S1_L001_R2_001.fastq.gz# cellranger 使用 下载 cellranger3.1 版本（目前 cellranger 已经支持 4.0 版本）并添加至环境变量 curl -o cellranger-3.1.0.tar.gz &quot;https:&#x2F;&#x2F;cf.10xgenomics.com&#x2F;releases&#x2F;cell-exp&#x2F;cellranger-3.1.0.tar.gz?Expires&#x3D;1601922176&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci0zLjEuMC50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDE5MjIxNzZ9fX1dfQ__&amp;Signature&#x3D;mCC-emSQTqWg3i6Rm23lkuccNRI4z7xf-8bJ-O5gHqsYFJHDPZN9MeUZW5vhRZvmZhiGK7EDL4y~3xPtQbS6JtfUL9EFsoUxMywyF7tGN2ZlU2pbb2EVpmhKjmDWPVmvurDb~ZlHVYZCYcOc6gEHVtFRre-ICa7-nccVtnUJA-HvxNrZMs5mlQaUG9E-ngtbLi86gvIYlMHYnFRieZYpMA-kmUKrHGG8MhiuBGR96AWOrsVdTyMjD-BJOurGYvZGddWAF5uVXNPJs47FqF4fNCSQw71WOSRx4bQGdfb-jrOFp-NDSYFhkY1-gigku8VCx9phFCtyTAVM9yHeGN1oMQ__&amp;Key-Pair-Id&#x3D;APKAI7S6A5RYOXBWRPDA&quot;tar -zxvf cellranger-3.1.0.tar.gzexport PATH&#x3D;&#x2F;datadisk02&#x2F;ScRNAseq&#x2F;cellranger-3.1.0:$PATH构建注释 wget ftp:&#x2F;&#x2F;ftp.ensembl.org&#x2F;pub&#x2F;release-93&#x2F;fasta&#x2F;homo_sapiens&#x2F;dna&#x2F;Homo_sapiens.GRCh38.dna.primary_assembly.fa.gzgunzip Homo_sapiens.GRCh38.dna.primary_assembly.fa.gzwget ftp:&#x2F;&#x2F;ftp.ensembl.org&#x2F;pub&#x2F;release-93&#x2F;gtf&#x2F;homo_sapiens&#x2F;Homo_sapiens.GRCh38.93.gtf.gzgunzip Homo_sapiens.GRCh38.93.gtf.gzcellranger mkgtf Homo_sapiens.GRCh38.93.gtf Homo_sapiens.GRCh38.93.filtered.gtf \\ --attribute&#x3D;gene_biotype:protein_coding \\ --attribute&#x3D;gene_biotype:lincRNA \\ --attribute&#x3D;gene_biotype:antisense \\ --attribute&#x3D;gene_biotype:IG_LV_gene \\ --attribute&#x3D;gene_biotype:IG_V_gene \\ --attribute&#x3D;gene_biotype:IG_V_pseudogene \\ --attribute&#x3D;gene_biotype:IG_D_gene \\ --attribute&#x3D;gene_biotype:IG_J_gene \\ --attribute&#x3D;gene_biotype:IG_J_pseudogene \\ --attribute&#x3D;gene_biotype:IG_C_gene \\ --attribute&#x3D;gene_biotype:IG_C_pseudogene \\ --attribute&#x3D;gene_biotype:TR_V_gene \\ --attribute&#x3D;gene_biotype:TR_V_pseudogene \\ --attribute&#x3D;gene_biotype:TR_D_gene \\ --attribute&#x3D;gene_biotype:TR_J_gene \\ --attribute&#x3D;gene_biotype:TR_J_pseudogene \\ --attribute&#x3D;gene_biotype:TR_C_genecellranger mkref --genome&#x3D;GRCh38 \\ --fasta&#x3D;Homo_sapiens.GRCh38.dna.primary_assembly.fa \\ --genes&#x3D;Homo_sapiens.GRCh38.93.filtered.gtf \\ --ref-version&#x3D;3.0.0也可以下载构建好的注释 curl -O https:&#x2F;&#x2F;cf.10xgenomics.com&#x2F;supp&#x2F;cell-exp&#x2F;refdata-cellranger-GRCh38-3.0.0.tar.gz然后进行比对即可 cellranger count --id&#x3D;SRR937 --transcriptome&#x3D;GRCh38 --fastqs&#x3D;SRR7722937&#x2F; --sample&#x3D;SRR7722937在分析过程中可以发现有些命令比较眼熟，不难发现 cellranger 的比对还是构建索引其实都有 STAR 的影子，后续的话我将 STARsolo（利用 STAR 分析单细胞数据）的流程再整理一下。 Generating STAR genome index (may take over 8 core hours for a 3Gb genome)...15:12:38 ..... Started STAR run15:12:38 ... Starting to generate Genome files15:14:31 ... starting to sort Suffix Array. This may take a long time...15:14:41 ... sorting Suffix Array chunks and saving them to disk...# 参考链接 https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/build#grch38_3.0.0 10x_Technical_Note_Base_Composition_SC3_v2_RevB.pdf 【生信技能树】使用 10X 单细胞转录组数据探索免疫治疗 单细胞实战 (三) Cell Ranger 使用初探 单细胞实战 (二) cell ranger 使用前注意事项","tags":"bioinformatics scrnaseq"},{"title":"单细胞实战(1)：原始测序数据下载","url":"/2020/09/29/2020-09-29-ScRNAseq(1)/","text":"# 前言 目前的课题是 10X 单细胞测序 (植物方面)，之前已经把所有的流程基本走过一遍，现在就将自己的学习过程整理成笔记给大家分享一下，我在学习单细胞分析的时候主要跟着单细胞天地的公众号和 jimmy 老师在 B 站上上传的单细胞分析视频进行学习的，在前期的数据下载过程中也参考了刘小泽的文章，希望对大家能有所帮助。 数据来源：《Acquired cancer resistance to combination immunotherapy from transcriptional loss of class I HLA》文章中的部分数据 ID Description SRR_ID GSM3330559 Tumor Disc Pre SRR7722937 GSM3330560 Tumor Disc AR SRR7722938 GSM3330561 PBMC Pre SRR7722939 GSM3330562 PBMC Disc Early SRR7722940 GSM3330563 PBMC Disc Resp SRR7722941 GSM3330564 PBMC Disc AR SRR7722942 # 数据下载 两种方法 1. 使用 sratools conda install -c daler sratoolkit##sra 数据下载加速wget https:&#x2F;&#x2F;download.asperasoft.com&#x2F;download&#x2F;sw&#x2F;connect&#x2F;3.8.1&#x2F;ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.tar.gz# 小心版本号有变动，不要直接复制上面的命令tar zxvf ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.tar.gzbash ibm-aspera-connect-3.8.1.161274-linux-g2.12-64.sh# 默认安装路径 &#x2F;home&#x2F;user&#x2F;.asperacat &gt;SRR_Acc_List-2586-4.txtSRR7722937SRR7722938SRR7722939SRR7722940SRR7722941SRR7722942cat SRR_Acc_List-2586-4.txt |while read ido prefetch $i -O &#96;pwd&#96; &amp;&amp; echo &quot;** $&#123;i&#125;.sra done **&quot;done2. 利用 ascp 由 ftp.ncbi 下载测序数据 第一种情况下有的数据可能无法下载，也可以直接利用 ascp 下载，速度也很快 在 EBI 上搜索想要的 SRR 号，复制连接地址 ftp://ftp.sra.ebi.ac.uk/vol1/srr/SRR772/007/SRR7722937 然后将地址按照如下格式修改 ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;007&#x2F;SRR7722937 .&#x2F;ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;008&#x2F;SRR7722938 .&#x2F;ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;009&#x2F;SRR7722939 .&#x2F;ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;000&#x2F;SRR7722940 .&#x2F;ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;001&#x2F;SRR7722941 .&#x2F;ascp -QT -l 300m -i ~&#x2F;.aspera&#x2F;connect&#x2F;etc&#x2F;asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1&#x2F;srr&#x2F;SRR772&#x2F;002&#x2F;SRR7722942 .&#x2F;# 参考链接 单细胞实战 (一)：数据下载 【生信技能树】使用 10X 单细胞转录组数据探索免疫治疗","tags":"bioinformatics scrnaseq"},{"title":"马士兵教育Python入门基础:3.运算（1）","url":"/2020/09/26/2020-09-26-python5/","text":"马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) 本章主要学习： Python 的输入函数 input Python 中的运算符（算数、赋值、比较、布尔、位） 运算符的优先级 # 输入函数 input ## 输入函数 inputpresent&#x3D;input (&#39; 大圣想要什么礼物呢？&#39;)print (present,type (present))大圣想要什么礼物呢？金箍棒 #输入某个字符产生相应结果金箍棒 &lt;class&#39;str&#39;&gt; #从键盘录入两个整数求和a&#x3D;int (input (&#39; 请输入一个加数 &#39;))#input 默认读入的值为字符型b&#x3D;int (input (&#39; 请输入另一个加数 &#39;))print (type (a),type (b))print (a+b)请输入一个加数 10请输入另一个加数 20&lt;class &#39;int&#39;&gt; &lt;class &#39;int&#39;&gt;30# Python 中的运算符 # 算术运算符 #标准算术运算符print (1+1)print (1-1)print (1*2)print (1&#x2F;2)print (11&#x2F;&#x2F;2)# 整除运算2020.55# 取余运算符print (11%2)1# 幂运算print (2**3)8# 一正一负print (9&#x2F;&#x2F;4)print (-9&#x2F;&#x2F;-4)print (9&#x2F;&#x2F;-4)## 向下取整print (-9&#x2F;&#x2F;4)## 向下取整22-3-3# 余数 &#x3D; 被除数 - 除数 * 商print (9%-4)print (-9%4)-33# 赋值运算符 #赋值运算符 从右到左运算 a=3+4 print(a) 7 #链式赋值 a=b=c=20 print(a,id(a),b,id(b),c,id(c)) 20 140713313966336 20 140713313966336 20 140713313966336 #参数赋值 a=20 a+=30 # a=a+30 print(a) 50 a-=10 print(a) 40 #系列解包赋值 a,b,c=20,30,40 print(a,b,c) 20,30,40 #交换两个变量的值 a,b=10,20 print('交换之前：',a,b) a,b=b,a print('交换之后：',a,b) 交换之前： 10 20 交换之后： 20 10","tags":"python"},{"title":"马士兵教育Python入门基础:2.七十二变（2）","url":"/2020/09/24/2020-09-24-python4/","text":"马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # 数据类型转换 name&#x3D;&quot;张三&quot;age&#x3D;20print (type (name),type (age))&lt;class&#39;str&#39;&gt; &lt;class &#39;int&#39;&gt;print (&#39; 我叫 &#39;+name+&#39; 今年 &#39;+age+&quot;岁&quot;)TypeError: can only concatenate str (not &quot;int&quot;) to str# 需要类型转换才能不会报错print (&#39; 我叫 &#39;+name+&#39; 今年 &#39;+str (age)+&quot;岁&quot;)我叫张三今年 20 岁print (&#39;---------------- 将其他类型转换为 str 类型 ---------&#39;)a&#x3D;10b&#x3D;198.8c&#x3D;Falseprint (type (a),type (b),type (c))print (str (a),str (b),str (c),type (str (a)),type (str (b)),type (str (c)))---------------- 将其他类型转换为 str 类型 ---------&lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt;10 198.8 False &lt;class&#39;str&#39;&gt; &lt;class&#39;str&#39;&gt; &lt;class&#39;str&#39;&gt;print (&#39;----------------- 将其他类型转换为 int 类型 ---------&#39;)sl&#x3D;&#39;128&#39;f1&#x3D;98.7s2&#x3D;&#39;76.77&#39;ff&#x3D;Trues3&#x3D;&quot;hello&quot;print (type (s1),type (f1),type (s2),type (ff),type (s3))print (int (s1),type (int (s1)))# 将 str 转成 int 型，字符串为数字串print (int (f1),type (int (f1)))# 直截取整数部分，舍弃小数点之后#print (int (s2),type (int (s2)))# 字符串为小数串报错print (int (ff),type (int (ff)))#print (int (s3),type (int (s3)))# 将字符串转换为 int 时，必须为整数串----------------- 将其他类型转换为 int 类型 ---------&lt;class&#39;str&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class&#39;str&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class&#39;str&#39;&gt;128 &lt;class &#39;int&#39;&gt;98 &lt;class &#39;int&#39;&gt;1 &lt;class &#39;int&#39;&gt;print (&#39;-------------- 将其他类型转换为浮点数 -----------------&#39;)s1&#x3D;&#39;128.98&#39;s2&#x3D;&#39;76&#39;ff&#x3D;Trues3&#x3D;&quot;hello&quot;i&#x3D;98print (type (s1),type (f1),type (s2),type (ff),type (s3),type (i))print (float (s1),type (float (s1)))print (float (s2),type (float (s2)))print (float (ff),type (float (ff)))#print (int (s3),type (float (s3)))# 字符串为非数字字符串报错print (float (i),type (float (i)))-------------- 将其他类型转换为浮点数 -----------------&lt;class&#39;str&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class&#39;str&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class&#39;str&#39;&gt; &lt;class &#39;int&#39;&gt;128.98 &lt;class &#39;float&#39;&gt;76.0 &lt;class &#39;float&#39;&gt;1.0 &lt;class &#39;float&#39;&gt;98.0 &lt;class &#39;float&#39;&gt;# Python 中的注释 #coding：gbk 修改编码格式# 输入功能：单行注释print (&#39;hello&#39;)&#39;&#39;&#39;嘿嘿，我是多行注释&#39;&#39;&#39;# 第二章总结","tags":"python"},{"title":"炫酷你的Github主页","url":"/2020/09/22/2020-09-22-Cool_your_github/","text":"# 1. 在 github 上新建一个仓库并 clone 到本地 注意： 新仓库的名字要与你的登录账号名保持一致（我这里已经创建过所以有重名警告） 我比较喜欢使用 atom 来进行 clone，所以我选择了添加 README 文件，如果喜欢用 git 可以不添加 README 文件，按照如下命令执行 进入一个文件夹git clone git@github.com: 你的用户名 &#x2F; 你的用户名.gitecho &quot;# 主页展示的内容&quot; &gt;&gt;README.mdgit initgit add .git commit -m &quot;first commit&quot;git remote add origin git@github.com: 你的用户名 &#x2F; 你的用户名.gitgit push -u origin master使用 atom 进行 clone，ctrl+shift+p 输入 github clone，将主页网址 clone 到本地 此时你的主页也出现了一个界面，个性化设置主要是修改这个 README 来使的主页显示相应的内容 # 修改 README 文件 其实接下来的步骤就因人而异了，修改自己的 README 文件，变成自己想要的模式吧，分享一下自己的界面 https://github.com/Bioinformatics-rookie 再给大家推荐一个 Github 的主页，我个人感觉挺好看的，原文件在我的项目里 example.md","tags":"github"},{"title":"文献导读：小立碗藓三维发育的细胞特异性转录组分析","url":"/2020/09/19/2020-09-19-three-dimensional_shoot_development/","text":"在上一篇导读中提到，目前在做小立碗藓的单细胞测序，相关的 maker gene 已经能发掘到很多，还缺少转型期相关的 maker gene，看到了 2015 年发表在《The Plant Journal》的文章，使用了激光切割法取特定组织进行转录组分析，区分了 tip-cell（最终发育绿丝体）和 bud-cell（最终发育为配子体），希望能对我寻找转型期相关基因有所帮助。 # Summary 单倍体苔藓配子体具有不同的干细胞类型，包括叶尖细胞分裂成单平面产生丝状原丝体，芽（bud）细胞分裂成三个平面产生轴向配子体芽。这种从丝状生长到三维生长的转变是在苔藓生命周期中逐渐发生的，被认为是从轮藻绿藻祖先进化而来的第一批陆生植物。形态复杂的植物体计划的创新促进了垂直景观的定殖，使复杂的营养和生殖植物形态得以发展。尽管它有着深刻的进化意义，但参与从原丝体组织向三平面分生组织转变的分子程序却鲜为人知。在这项研究中，利用单细胞型转录组学鉴定了 4000 多个差异表达的基因，这些差异表达基因区分了单面原丝体顶端细胞和多平面配子体芽细胞。虽然叶尖细胞和芽细胞的转录体都显示增殖细胞的分子特征，但是芽细胞转录组表现出更广泛的基因种类，转录丰度显著增加。我们的数据表明，在苔藓植物中，与芽模式和不对称细胞分裂有关的基因的联合表达伴随着从平面到三维分生组织生长的转变。 # introduction 陆地植物（胚胎植物）形态复杂的体形图的发育需要分生组织细胞在三维平面分裂。与胚胎植物不同的是，陆生植物轮藻绿藻近亲的分枝丝状生长完全是通过二维的细胞分裂进行的，其中丝状分枝是由斜向扩展的藻丝平面的细胞分裂开始的。最有可能的是，向三维分裂分生组织细胞的转变，能够产生形态上复杂的胚胎植物体形，发生在胚胎植物的一个未知的水生祖先身上。 在苔藓发育的单倍体配子体阶段，这一关键的进化创新从丝状体到直立形态被复现。与维管植物不同，无核无维管苔藓的萌发孢子进行单平面分裂，形成由叶绿体丰富的细胞组成的丝状原丝体，称为绿线体。当原丝体顶端细胞通过单平面分裂延伸纤维时，双平面细胞分裂发生在离尖端更远的地方，从而产生分枝状的原丝体。当暴露于诱导的环境刺激和 / 或生长素的存在下，绿丝状体可能会单面分裂，并转变为第二种丝状细胞类型，称为芽，其中含有倾斜的细胞壁和很少的叶绿体，虽然约有 5% 的芽细胞转化为三维分裂的干细胞（SCs），称为配子体芽。芽细胞是分生组织，形成复杂的芽轴，称为配子体，其中包含称为叶状体的光合侧生器官。为了收集足够的芽材料，用萘乙酸和激动素 (kinetin) 处理，使茎基分枝点的芽（诱导芽）比未处理的对照植株多 12 倍。 配子体由一个分生组织细胞发育而来，同时具有不确定性和器官发生的功能。在种子植物中，茎分生组织被分成功能上不同的多细胞区。分生组织中央区分裂不频繁，维持着不确定的干细胞生态位，而外围区分裂迅速，启动侧器官。植物发育中的一个基本问题是藓类单细胞分生组织芽细胞如何发挥 SC 不确定性和器官发生的综合功能，这些功能在维管植物茎分生组织中被赋予不同的多细胞区。 已知调节苔藓 SC 特性的关键遗传因子包括平行的小 RNA 途径、染色质重塑、转录因子、激素信号传导和转运基因以及细胞分裂的调节因子。在已知的 SC 调节因子列表中，显著缺失的是 KNOTTED 1-like (class I KNOX) 基因，它们在被子植物的茎分生组织中起着不可或缺的作用。尽管转录组学证据表明 I 类 KNOX 基因 MKN2 确实在苔藓的分生组织芽细胞中表达，但小立碗藓 KNOX 基因的靶向敲除没有产生配子体表型。 激光显微切割和下一代测序技术的结合使单个细胞的转录组分析成为可能。在这里，我微切单平面原丝体顶端细胞和芽细胞产生了细胞特异性的小立碗藓转录组。的目标有两个：（i）探索被子植物茎分生组织在单细胞顶端和诱导苔藓芽细胞中的遗传程序的程度，（ii）发现在苔藓配子体二维单面和三维平面 SCs 的分子结构。 转录组比较显示，成千上万的基因转录本区分了叶尖细胞和诱导芽细胞。虽然这两种 SC 类型的转录本都在多能干细胞类型中得到了丰富的功能，但是诱导的芽细胞转录组显示出在被子植物中调节芽模式和不对称细胞分裂的同源基因的积累显著增加。从这些数据中，提出了一个通过茎分生功能和不对称细胞分裂相结合的复杂身体计划进化模型。 # RESULTS AND DISCUSSION # 成千上万的基因转录本区分芽细胞和顶端细胞 配子体的发育经历了从单面分裂形成不分枝细丝，到形成分枝细丝的双面分裂，最后发展到形成配子体复杂体形的三维分裂。由于平面和三维生长模式都来自于单个分生组织细胞，激光显微切割和转录组学分析这两种不同的 SC 类型是直接的。在顶端细胞和芽细胞群体之间发现了 6957 个显著差异表达的基因。其中 4472 个差异表达基因表现出双重差异表达：1043 个在单平面叶尖细胞中上调，3429 个在三维生长诱导的芽细胞中上调。数据表明，与顶端细胞相比，芽细胞处于转录活跃状态。 &lt;center&gt; 原丝体尖端和配子体芽样本的转录组比较揭示了数千个分离这两种 SC 类型的基因。(a) 激光显微分离使尖端细胞和芽细胞特异分离。(b, c) 10 至 2000 万 reads 生成每个样本类型 (b), 和超过 10000 个基因被发现差异表达 (c)。(d) k - means 聚类之间的差异表达基因的 SC 和全植物 (WP) 转录组显示离散独立分组在三种样本类型。(e) WP、芽、尖转录组间差异表达基因的热图。层次聚类形成的主要基因簇以紫色、黄色、蓝色、橙色和绿色块表示。在 heatmap 的左侧显示缩放后的基因表达水平值条，红色和蓝色分别表示上调和下调。 &lt;/center&gt; # GO 富集分类在芽细胞中丰富，而在尖端细胞中不丰富 对尖端细胞和芽细胞中转录物积累的分析表明，与整个植物转录组相比，有数千个上调转录物（1382 个）和下调转录物（2135 个）。real-time PCR 进一步验证了上调诱导芽和叶尖基因的表达模式。GO 富集分析确定在诱导芽和叶尖转录组数据集中显著富集的预测基因功能。芽细胞 GO 预测主要参与分子模式和发育。这些包括转录因子，蛋白激酶，细胞命运决定和形态发生，以及跨膜外排转运。一些与尖端细胞生长相关的 GO 类也富集在芽细胞，如顶端生长和花粉管生长。原丝体被认为是苔藓尖端生长的主要细胞；转录组数据表明，诱导的配子体发育的某些基因也出现在尖端细胞中。 &lt;center&gt; Real-time quantitative PCR validation of transcripts enriched in bud SCs and tip SCs. &lt;/center&gt; 与芽转录组中发现的大量发育模式相关的 GO 类别不同，在尖端细胞转录组中富集的 GO 类别大多数与光合功能有关。在尖端细胞转录组中发现了大量与光合作用相关的 GO 类别，表明固碳是顶端细胞的主要功能之一。根毛发育过程中 GO 的富集也被发现，这进一步证明了苔藓原丝体和被子植物根毛之间有共同的生长策略。 令人惊讶的是，在尖端细胞中显著富集的 GO 类没有涉及转录调控、激素反应或表观遗传修饰。先前对原丝体细胞重编程的转录组学研究显示，发育基因的缺失与此类似。 # 涉及茎分生组织模式和细胞不对称分裂的基因在芽细胞中上调 为了确定差异表达的候选基因，从组织特异性转录组中提取了具有所述发育功能的被子植物基因同源物。转录本选自八个功能类别：细胞壁生物发生、细胞骨架和不对称细胞分裂、一般发育、光合作用、细胞周期调节、激素信号、茎尖分生组织发育和表观遗传修饰。下图显示了在尖端细胞转录组（75 个基因）和芽细胞转录组（100）中上调的特定基因转录本的比较。然而，数百个功能未知的差异表达基因在芽或尖端细胞转录体中特异性上调。 &lt;center&gt; 尖端细胞转录组包含大量参与细胞壁生物发生和光合作用的基因，而芽细胞转录组的特征是调控激素信号，表观遗传修饰，芽顶端分生组织发育，细胞周期调节，细胞骨架和不对称细胞分裂的基因。 &lt;/center&gt; 在诱导芽细胞转录组中，表达上调的基因可以指导芽分生组织模式的形成和不对称的细胞分裂。例如，拟南芥受体信号转导基因的同源物，这些基因调节茎的分生组织大小和模式，包括 CLAVATA 1 和 2（CLV1 和 CLV2）、MERISTEMATIC RECEPTOR-LIKE KINASE（MRLK）、丝裂原活化蛋白激酶激酶 YODA（YDA）、ERECTA-LIKE，CRINKLY4（CR4）和 calpain 编码的信号基因 DEFECTIVE KERNEL1（DEK1）。 在被子植物茎分生组织的中心区和外围区，多种染色质重塑复合物调控着细胞命运的转变。在 bud 细胞中，包括拟南芥 SWI/SNF 复合物同源基因在内的多种染色质重塑基因也上调，但在 tip 细胞中没有上调。先前的研究表明，原丝体和配子体具有不同的染色质状态；这些上调的染色质重塑因子可能参与了染色质状态的改变。此外，显示与染色质重塑复合物相互作用的细胞周期同源物在诱导芽细胞转录组中特别上调，例如直接 SWI/SNF 相互作用因子 E2F 转录因子（E2F），以及一些周期蛋白（CDC/CYC）和细胞周期蛋白依赖激酶（CDK）。 bud 细胞富含参与控制细胞不对称分裂的特定细胞周期调节因子，包括 CYCB1;1，CDKA1;1 和 E2F 的同源物，对分化组织和复杂植物结构的发育至关重要。一种由不对称细胞分裂引起的预测功能是配子体芽细胞中不均匀的细胞分裂形叶状体前体细胞。与含有 10 多种细胞周期调控因子的诱导芽细胞转录组相比，尖端细胞转录组只有两个显著上调的细胞周期基因（STRUBBELIG 和 CYCLOPHILIN 38） 。 在 bud 细胞中特异性上调的其他 bud 预测的 25 个基因控制植物激素生长素、细胞分裂素和油菜素甾体的生物合成和信号转导的基因。最有趣的是，在 bud 细胞中发现了两个 PIN 基因的同源物。此外，在 bud 细胞中，一种参与 PIN 蛋白极性定位的蛋白激酶 PINOID 的同源物也上调。最近的一项研究表明，在苔藓配子体中，质膜相关的 PIN 蛋白是正常芽发育所必需的。 在被子植物中，大量的转录因子网络参与了对细胞特异性命运和发育模式的控制。值得注意的是，在 tip 细胞中表达上调的转录因子基因不包括模式植物同源的基因。相比之下，bud 细胞中上调的转录物包括与芽图案有关的几种被子植物转录物的同源物，如 DORNROSCHEN-LIKE（DRN-LIKE）和 LEAFY（LFY），表皮 PROTODERMAL FACTOR 2（PDF2）和 SCREAM2（SCRM），以及 I 类 KNOX 基因 MOSSKNOTTED- RELATED HOMEOBOX 2（MKN2）。bud 细胞中发现 MKN2 上调表达是出乎意料的，因为先前的遗传分析表明，KNOX 基因的功能仅限于孢子体世代。 两种类型的干细胞都是由一个不可区分的单细胞分支点和一个平面细胞分裂产生的。在这一阶段，bud 和 tip 的干细胞在形态上相似，但面临着截然不同的发展命运，这可能是由仅仅两次细胞分裂后数千个差异表达的基因所决定的。在单细胞阶段分离 bud 和 tip 细胞在形态学上是不可行的；然而，这项研究可能有助于识别在 tip 和 bud 细胞命运形态表现之前的分子标记。 # CONCLUSION 被子植物模式植物基因同源物和不对称细胞分裂调控因子的协同上调启发了一个模型，其中这些遗传途径的协同作用有助于在形态复杂的配子体中发现新的发育创新。从这个观点来看，这些组合的发育功能所赋予的特性可以使 bud 细胞出现新的干细胞功能，以及由覆盖侧器官启动程序的不对称分裂程序所赋予的器官发生。分生组织母细胞的不对称分裂产生了包括气孔复合体的多种细胞类型；然而，分生组织母细胞的这种多能性是短暂的。气孔的最早古植物学证据与苔藓植物的出现相吻合。推测苔藓配子体分生组织功能发育途径的出现，可能在气孔演化过程中起到了类似的作用。","tags":"literature_reading"},{"title":"文献导读：小立碗藓组织特异转录组","url":"/2020/09/17/2020-09-17-specific_transcriptome/","text":"最近在做小立碗藓的 10X 转录组，最大的问题就是 maker gene，所以要从文献中发掘 maker gene，将其用于自己的细胞注释中，目前选择了 2016 年发表在《Molecular Plant》的一篇文章，主要做了小立碗藓各个组织的转录组，找到一些组织特异性基因，希望对我的注释工作能有帮助。 # 摘要 本研究主要制作了小立碗藓的转录组图谱，涵盖了苔藓植物的生命周期的大部分阶段，包括了孢子体发育的详细进展。研究鉴定了一套完整的孢子体特异性的转录因子，并发现许多这些基因在被子植物中具有同源性，在发育过程中起很多作用，比如开花和分枝。 # 引言 在适应陆地生活的过程中，早期陆地植物的配子体和孢子体世代经历了相当大的形态变化，导致了今天苔藓植物和维管植物典型的世代交替。例如，人们认为孢子体从一个小而简单的结构，在生理上依赖于配子体，进化成复杂的，自由生活的，有时是巨大的生物，支配着今天大多数陆地生态系统。这种转变涉及到新器官和组织系统的产生。目前，有几个转录因子已经被鉴定可能是实现这种转化的关键：例如，class I KNOTTED-LIKE HOMEOBOX（KNOX1）基因主要在开花植物中负责调节顶端分生组织的生长，在 P.patens 中局限在孢子体中，可能具有调节孢子体分生组织生长的作用。其他可能在陆地植物进化过程中发挥重要作用的调节孢子体发育的重要家族有 BELLRINGER 1-LIKE HOMEOBOX (BELL1), MADS-box, GRAS 以及 TEOSINTE BRANCHED1/CYCLOIDEA/PROLIFERATING CELL FACTOR1 (TCP). 大规模的比较转录组分析已经被成功地用于根据它们的时间和空间表达谱来确定候选基因。通过识别早期陆地植物的基因调控网络并评估它们在进化过程中是如何变化的，这可以应用到进化研究中。在拟南芥中，已经有大量的转录组数据可供参考。在小立碗藓中目前也在尝试类似的工作，例如，在几种发育条件条件下的原丝体的转录组，配子体和原丝体在几种生物和非生物胁迫下的转录组反应，但是关于孢子体发育进展的详细信息仍然缺失，此外，目前还没有对根茎类或单个生殖器官的转录组数据进行研究，也没有对 P.patens 生命周期的大部分组织的转录组数据进行全面的分析。在识别差异基因时，这是一个问题，因为缺乏相应组织和发育阶段的转录组数据将对后续的研究有巨大的影响。 在本研究中，描述了大部分 P.patens 的生活史阶段的转录数据，包括绿丝体、轴丝体、假根、配子体、孢子、颈卵器和四个不同的孢子体发育阶段。并创建了一个数据集 http://bar.utoronto.ca/efp_physcomitrella/cgi-bin/efpWeb.cgi。将 P.patens 转录组数据与现有的拟南芥的数据进行比较，以提取早期分化的陆地植物类群中具有进化保守性的基因表达特征。结果发现被子植物的孢子体中也有一些重要的同源基因，如与芽器官形态发生和花器官发育有关的基因。此外，通过对孢子体特异性 TCP 转录因子 PpTCP5 的功能表征，推测该基因在控制孢子体结构方面具有进化保守功能，因此，该基因可能在陆地植物进化过程中获得孢子体复杂性方面发挥了重要作用。关于配子体的产生，分析表明，拟南芥和小立碗藓的尖端生长有一个相似的核心转录因子，这些转录因子表达模式的特定修饰可以解释这些远缘物种尖端生长细胞之间的发育差异。 # 结果与讨论 # 生成一个 P. patens 转录组图谱和 eFP 浏览器集成 制作小立碗藓的转录组图谱，选取了大量的组织生长时期，分析的组织包括绿丝体、轴丝体、配子体、假根、原生质体、颈卵器以及四个不同的孢子生长阶段。以孢子体为例，根据形态特征 (如大小、形状和成熟程度) 将发育分为不同阶段。作为指导，根据受精事件的假定时间确定孢子体收集的日期如下：S1：受精后 5-6 天，S2：受精后 9-11 天，S3：受精后 18-20 天，S4：受精后 28-33 天。在所有被分析的组织中，都达到了预期的结果，此外，还可以确定与孢子体密切相关的组织 / 阶段（如轴丝体和绿丝体）或不同孢子体阶段之间的差异。研究还对在多个组织中筛选出的优先表达的基因进行了 qRT PCR 检测，发现转录组结果与 qRT PCR 表达数据高度相关。最后，比较了我们的芯片预测的几个基因家族的表达谱，并将其与已发表的实验数据进行了比较，发现它们之间存在高度相关性。总的来说，这些观察结果验证了转录组的结果。 &lt;center&gt; 在植物生物学生物分析资源 (BAR) 中显示了整合到 Physcomitrella eFP 浏览器中的 P. patens 组织的卡通形象。在孢子体发育阶段，用于 mRNA 分离的组织的代表性图像包括 (底部)。根据受精事件发生后的天数 (d.AF，受精后的天数)，分期被称为孢子体 1 (S1)、孢子体 2 (S2)、孢子体 3 (S3) 和成熟 (棕色) 孢子体 (SM)。&lt;/center&gt; &lt;center&gt; 使用标记基因进行 qRT-PCR 检测组织 (A) 检测 PIP2;1 水通道蛋白 (Pp1s8_151V6.1)，结果与之相反。在本例中，配子体和孢子体组织均有表达，而在原丝体组织中未检测到转录本。(B) 检测原体组织中有报道的 RM09 基因 (Pp1s407_31V6.1) 的表达。原体根 (轴丝体、绿丝体、原生质体和假根) 中表达丰富，在这些组织中也可以观察到表达水平的差异。(C) 选择组织优先表达的基因进行 qRT-PCR 模式确证。(D) 报告的基因表达值与 PpMKN 转录因子家族转录本存在的实验证据的相关性。组织图上方的圆圈表示了文献中 PpMKN 基因在各自阶段的表达。 &lt;/center&gt; # 整体转录趋势与主要发育转变和生理功能相对应 通过主成分分析 (PCA) 和层次聚类 (HC) 来分析数据集之间的相关关系。在对所有样本的主成分分析中，观察到与发育或生理功能相关的优先分组于配子体或孢子体的身份。HC dendogram 确认了之前在 PCA 中观察到的样本分离。重要的是，相同的生物复制被分组在一起，表明本次研究成功分离了发育阶段，特别是孢子体发育阶段。 # 小立碗藓中的基因表达表明，与在拟南芥中观察到的相比，小立碗藓具有较低的世代偏向化 为了获得所有组织间转录多样性的概述，确定了每个组织中表达、富集和只在特定组织中表达，而在其他组织中没有表达的基因数量。为了计算表达阈值，对一组低表达值的基因进行 qRT PCR 实验。检测与相应基因的转录表达价值报告的数组，建立最小值调用一个基因。发现有一个高和常数被表达的基因数量在所有组织。因此，根据先前在 Funaria hygrometrica 中观察到的，P. patens 中两代基因表达的分化要弱于被子植物 A. thaliana，后者配子体表达的基因数量只有孢子体表达的一半。此外还进行了额外的分析，以确定每一代优先表达基因的数量。发现 P. patens 中配子体的唯一表达基因数量是孢子体的两倍多。在这种情况下，这一观察结果与苔藓中组成配子体世代的较高的组织多样性及其在孢子体中的优势地位是一致的。 &lt;center&gt; (A) PCA 应用于每个组织三个重复的平均基因表达值。(B) 利用 Pearson s 相关系数进行层次聚类。(C) 组织表达基因相对于基因总数的百分比 (黑色)，以及组织富集基因相对于被检测到的富集基因总数的百分比 (红色)。(D) 维恩图，显示配子体和孢子体世代之间共同和唯一表达的基因数目。 &lt;/center&gt; &lt;center&gt; 出现的、富集的和优先表达的每个组织表达转录本 &lt;/center&gt; # 在被子植物中，控制二倍体发育和一般植物结构的转录因子在孢子体的几个阶段都有表达 在维管植物中，孢子体生命周期的优势表现为体计划结构的复杂性增加，这是由一组转录因子控制的，其中 KNOX、BELL1 和 TCP 家族尤为重要。例如，KNOX2 转录因子在苔藓的世代交替中被证明是必不可少的，因为它们阻止了单倍体遗传程序的表达。此外，在维管植物的孢子体中，KNOX 和 BELL1 之间的相互作用是已知的。这种相互作用改变了这些转录因子控制 SAM 活性和维持的方式，最终产生了植物体形态和大小的巨大多样性。表达数据表明，在 P. patens 孢子体发育过程中，KNOX2 类蛋白 MKN1、MKN6 和一个 bell -like 同源物 (Pp1s258_6v6) 表达水平相似，这与这些蛋白在苔藓中相互作用的假设一致。此外，还发现两个 TCP 同源物 (Pp1s332_35v6 和 Pp1s207_110v6) 在孢子体各发育阶段均有很高的表达水平，在 SM 中表达达到峰值。在被子植物中，TCP 基因也是孢子体结构的重要调节器，因为它们控制腋芽的发育、分枝和芽的对称。 &lt;center&gt; 基因标识符 (左) 和基因描述 (右)，包括家族、基因名称和拟南芥同源性。转录因子从 S1, S2, S3, SM 的丰富基因列表中选择。寻找至少在三个孢子体发育阶段富集的基因，并与非孢子体组织进行比较。红色代表高表达，黄色代表低表达值。从这个列表中选择了两个 TCP 基因进行进一步分析。 &lt;/center&gt; # 大量表达的 TCP 家族成员抑制孢子体分枝 在孢子体中，PpTCP 转录本的丰度高于其他转录因子的表达；它们几乎和组成性表达的微管蛋白一样丰富。系统发育分析表明，TCP 基因既存在于基底层植物类群的基因组中，也存在于它们的藻类亲缘物种中。它们被分为两个主要亚科：第一类，也被称为 TCP-P，第二类，也被称为 TCP-C。在南芥中，I 类基因促进一般细胞的生长和增殖，II 类基因通过调节组织增殖模式来控制茎的分枝、侧器官的发育和花的对称。利用 A. thaliana 和 P. patens 的 TCP 氨基酸序列进行进一步的系统发育分析，发现 P. patens 有两个 TCP II 类同源物和四个 I 类同源物。II 类基因 PpTCP5 和 PpTCP6 在孢子体中有明显的富集。 为了研究 P. patens 中 II 类基因的功能，通过同源重组生成了 5 个独立的敲除突变株 PpTCP5 (Pp1s332_35V6)。选择 3 个株系进行进一步表型分析 (指定为 PpTCP5 (5)、PpTCP5(8) 和 PpTCP5 (27))。在 WT 孢子体中扩增出 PpTCP5 和 PpTCP6 转录本，但在突变株中未检测到 PpTCP5 转录本。重要的是，与转录组结果 PpTCP6 转录本水平大致相同。热图显示了在孢子体中丰富的转录因子的表达动态。寻找至少在三个孢子体发育阶段富集的基因，并与非孢子体组织进行比较。红色代表高表达，黄色代表低表达值。PpTCP6 转录水平在突变系中并没有增加来弥补 Pptcp5 功能的缺失。 将 Pptcp5 突变体转移到孢子体诱导条件下，与 WT 进行表型比较。比较了 Pptcp5 突变体和 WT 的孢子体数量和分枝孢子体的百分比。所有突变系的分枝孢子体数量都是 WT 的两倍多。WT 的分枝频率约为 5%，而 Pptcp5 (27) 的分枝频率接近 15%。此外，具有两个或更多分枝的孢子体在 Pptcp5 株系中比野生型更常见，有些个体在一个结构上可产生多达 5 个蒴果。 &lt;center&gt; (A) 6 个 PpTCP 基因同源物的归一化芯片强度值，以可视化其在不同组织分析中的表达模式。(B) PpTCP5 基因敲除突变显示，在不同发育阶段，出现数个蒴果 (箭头)。(C) RT - PCR 扩增显示突变株和 WT 系中 TCP II 类和 I 类 (PpTCPI) 基因的表达情况。(D) WT 和敲除株系的孢子体分枝平均百分比。 &lt;/center&gt; # 孢子体发育的 GO 分析反映了导致孢子成熟的主要转变 使用 DAVID 功能注释工具进行 GO 富集分析，在 S1 阶段，转录调控是唯一确定的功能类别。这是由于在这个阶段只有 17 个基因表达丰富；然而，它们中的大多数是转录因子，它们可能负责启动孢子体转录程序。在 S2 阶段，相关功能类别是脂质分解代谢、形态发生，以及少部分的转录因子的活动。在 S3 和 SM 阶段，基因的数量和功能类别的多样性大幅增加，由于两个最丰富的分类是配子体发育和减数分裂，这一发现是相关的，并表明在这个特定的阶段，孢子开始发生。此外，脂质生物合成的过程是在 S3 中高度富集，表明脂质代谢对孢子生物起源也很重要，这一发育阶段似乎与能量储备的运输和储存以及孢子的生长和成熟有关。 # 控制春化和气孔发育的转录因子的同源性在孢子体发育的早期得到表达 在 S1 期间，所有被鉴定的注释基因都与转录调控有关。特别值得注意的是，有一种转录因子与 A. thaliana REDUCED VERNALIZATION RESPONSE 1 (VRN1) 基因同源 (Pp1s434_19V6)。拟南芥的 VRN 基因主要负责调节春化作用，植物暴露在寒冷环境中一段时间后加速开花的过程。然而，在谷物中，VRN1 的表达可以在没有春化的情况下增加，这意味着它可以调节分生组织而并不局限于春化。同源基因在 P. patens 孢子体早期阶段的表达表明，它对维持该物种分生组织的活性 / 同一性也很重要。 其他转录因子在这个阶段富集似乎参与水运特殊细胞的分化，如 PpVNS6 和 PpVNS4, 此外，在 S2 期，发现 bHLH FAMA 的同源基因 PpSMF1 高表达。在 A. thaliana 中，FAMA 和 MUTE 转录因子主要负责控制保护细胞的分化。 # 花粉发育相关的同源基因的表达标志着 S3 期孢子发生的开始 植物的有性生殖依赖于减数分裂细胞产生单倍体细胞，单倍体细胞产生配子体。在 P. patens 中，减数分裂发生在孢子体发育的某个阶段，之后产生孢子。鉴定了一个与 MALE MEIOTIC DEATH 1 (MMD1) 同源的转录因子 (Pp1s271_42V6)，该转录因子在孢子体发育的 S2 和 S3 阶段优先表达。在 A. thaliana 中，MMD1 突变体表现出减数分裂的改变，导致雄性减数细胞停止和细胞死亡。该转录因子表达在 S2 和 S3 期间达到一个非常高的表达水平，而且在 SM 阶段之后的其他组织中不会表达。此外，减数分裂重组蛋白 DOSAGE SUPPRESSOR OF MCK1 (DMC1) 的同源基因、SPORULATION 11（SPO11）也优先表达在 S3 阶段。最后，还发现 MALE STERILITY 1 (MS1) 也在 S3 阶段富集。在 A. thaliana 中，MS1 控制着花粉质组分的形成，与 MMD1 属于同一转录因子家族。这些观察结果为减数分裂控制提供了有力的证据，因此表明孢子发生开始于 S3 发育阶段。此外，花粉母细胞控制减数分裂的基因似乎与花粉母细胞控制减数分裂的基因是同源的。 # 顶端生长细胞的转录组揭示了配子体的发育过程 由于顶端生长细胞代表了单倍体产生的一个主要阶段，分析了它们的转录组，以提供重要的配子体发育过程的见解。该研究确定了在每一种末端生长细胞类型中单独富集的一组基因，以评估是否可以识别与特定功能相关的类。假根的 GO 注释都与离子运输相关，包括阳离子和阴离子转运、钾转运和磷代谢，这表明假根参与不同离子的吸收和交换，与提供配子托与无机营养来维持生长相关。与钾、磷和铁转运相关的基因转录本尤其丰富。而绿丝体注释最多的是乙烯介导的信号通路、四吡啶结合、金属离子结合和对光反应，反映了该组织通过光合作用和碳同化产生能量的作用。根据这一分析，乙烯信号可能参与绿丝体的生长与发展。最后，在轴丝体细胞中，发现了叶尖生长相关的生理过程更加活跃；最丰富的分类是细胞壁修饰，细胞大小的调节，葡聚糖代谢过程，碳水化合物分解代谢。根据这一观察，可以发现轴丝体的生长速度明显高于绿丝体。 # 在尖端生长细胞中高表达的基因变成了花粉管或根毛特异性基因 为了确定在 P. patens 中控制一般尖端生长功能的候选转录因子，搜索了在三种尖端生长细胞中高表达的基因：轴丝体，绿丝体和假根。大多数的 tip- growth cell enrichment (TGE) 转录因子属于 bHLH 或 MIKC MADS-box 亚家族的 MIKC 类。已知这些家族的几个成员分别控制根毛和花粉管的发展。在 P. patens 中发现的属于 bHLH 家族的 TGE 转录因子分别有 PpRSL1 和 PpRSL2、RHD6 和 RSL1 以及 LRL-like 转录因子的两个同源基因。这些基因在 P. patens 和 A. thaliana 中的表达模式是不同的，因为在后者中它们的表达仅限于一种顶端生长细胞：根毛。从生物学功能上看，PpRSL1 和 PpRSL2 是 P. patens 植物茎和根茎发育所必需的，而 A. thaliana 的同源基因则是根毛发育所必需的，对花粉管的生长没有作用，也就是说它们的活性仅局限于一种顶端生长细胞。 类似的例子可以在 MIKC 转录因子中找到，因为在 A. thaliana 中，除了一个基因外，所有的 MIKC 基因都只在一种顶端生长细胞中表达：花粉管。同样，发现 P. patens 基因组编码的 11 个 MIKC 蛋白中有 10 个在所有的端生长细胞中表达。尽管有 3 个基因在轴丝体、绿丝体和假根中优先表达，其余 8 个基因在孢子和成熟孢子体中表达的水平也较低。因此，MIKC* mRNA 在成熟的孢子体样本中的存在，可能是分离出 RNA 的孢子囊中含有大量孢子的结果。 综上所述，这些观察结果表明轴丝体、绿丝体和假根的转录组比被子植物顶端生长的细胞更相似。在 P. patens 中，发现 142 个基因转录在所有的顶端生长细胞中同时表达和富集，而在 A.thaliana 中总共发现 49 个。 后者的 TGE 基因数量较少，这可以解释为花粉和根毛没有 P. patens 顶端生长细胞那样表达许多共同基因，然而，在拟南芥中，组织多样性较高，这也会影响 TGE 基因的最终数量。 另一方面，当花粉和根毛分别与其他组织进行比较时，可以获得大量丰富的基因。控制根毛生长的部分基因网络的表达是从配子体世代通过进化而来的，所以可以想象一个可以解释我们观察到的情况，其中根毛仅部分获得祖先顶端生长细胞发育基因网络的表达。这就解释了为什么它们不表达与花粉相同的基因。另一方面，花粉管中可能有几个基因的表达中断，这些基因包括前面提到的 bHLH 转录因子 PpRSL1 和 PpRSL2（假设这些基因也在祖先苔藓植物的所有叶尖生长细胞中表达）。这些观察结果是相关的，因为它们支持陆地植物进化的对立理论。 # 孢子的转录组表明广泛的转录和表观遗传重编程 孢子和花粉在萌发时能产生顶端生长的细胞，在某种程度上可以认为是类似的结构。然而，虽然花粉粒和花粉管的转录组仅显示出中等程度的变化，但成熟孢子的转录组与小立碗藓顶端生长细胞的转录组有很大不同。事实上，孢子在转录上是独一无二的，因为有几个转录因子家族在这个阶段特别丰富。孢子中高度富集的基因转录物主要参与 RNA 代谢。一些相关的分类包括非编码 RNA（ncRNA）加工、ATP 依赖性解旋酶活性、RNA 剪接和 DNA 修复。特别是，一些涉及 mRNA 和 sRNA 处理的基因被高度富集。其中包括一个 HEN1 抑制子 1（HESO1）（Pp1s131 v6）的同源物，此外，还发现了编码与 DNA 染色质修饰和甲基化有关的蛋白质的转录物，这表明这些过程在孢子中是活跃的。综上所述，这些观察结果表明，基因表达修饰所涉及的过程是高度活跃和动态的，包括表观遗传修饰。令人费解的是，在成熟孢子中观察到这种基因表达模式，而不是在任何其他组织或花粉转录组中观察到。一种假设可能是转录程序的广泛变化是实现活跃和休眠代谢状态之间的转换所必需的。在被子植物中，种子也必须经历一个类似的转变，并且已经确定参与染色质重塑过程的基因，包括甲基化，在这种重排中起作用。 &lt;center&gt; 从每代富集的转录因子基因总数中，计算属于特定转录因子家族的基因百分比。有几个转录因子家族在孢子中专一富集。 &lt;/center&gt; # Summary 本文献做了相当大量的工作，可以说为我们以后小立碗藓组织特异性的基因研究提供了一个大纲，该研究中缺乏动态的研究，比如小立碗藓从横向生长转变为立体生长的过程没有涉及，主要的侧重点在孢子体与配子体的比较，如果对转型期（bud-cell）细胞在进行更加深入的研究将更全面。而且文献中并没有所谓的 summary，对一些信息没有汇总。 总之，篇文献对于我目前的细胞类型注释还是很有帮助的，根据文献中的一些组织特异性基因我可以将自己的细胞聚类大体分为了想要的几种，对于转型期的细胞还需要查询相关文献","tags":"literature_reading"},{"title":"马士兵教育Python入门基础:2.七十二变（1）","url":"/2020/09/15/2020-09-15-python3/","text":"Python 系列笔记 马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) 本章主要学习： 二进制与字符编码 Python 中的标识符与保留字 Python 中的变量与数据类型 Python 中的注释 # 二进制与字符编码 ## 不管中文还是英文，在计算机中都叫做字符print (chr (0b100111001011000)) ## 二进制的乘print (ord (&quot;乘&quot;)) ## 乘的十进制数乘20056# Python 中的标识符和保留字 保留字：有一些单词被 Python 赋予了特定的含义，这些单词你在给你的任何对象起名字的时候都不能用 变量、函数、类、模块和其他对象的起的名字就叫标识符 规则：字母数字下划线，不能以数字开头、不能是保留字、严格区分大小写 import keywordprint (keyword.kwlist)## 输出保留字符，这些不能被设置为变量[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]# 变量的定义与使用 变量是内存中带有标签的一个盒子 name &#x3D; &quot;玛利亚&quot;print (name)print (&quot;标识&quot;,id (name))print (&quot;类型&quot;,type (name))print (&quot;值&quot;,name)玛利亚标识 2691903063984类型 &lt;class&#39;str&#39;&gt;值 玛利亚当多次赋值之后，变量名会指向新的空间 name&#x3D;&#39; 玛利亚 &#39;print (name)name&#x3D;&#39; 楚溜冰 &#39;print (name)玛利亚楚溜冰# 数据类型 # 整数类型 integer，简写为 int，可以表示正数负数和零 n1&#x3D;90n2&#x3D;-76n3&#x3D;0print (n1,type (n1))print (n2,type (n2))print (n3,type (n3))# 整数可以表示为二进制，十进制，八进制，十六进制，默认十进制print (&quot;十进制&quot;,118)print (&quot;二进制&quot;,0b10101111) ##0b 是二进制print (&quot;八进制&quot;,0o176)##0o 是八进制print (&quot;十六进制&quot;,0x1EAF)##0x 是十六进制90 &lt;class &#39;int&#39;&gt;-76 &lt;class &#39;int&#39;&gt;0 &lt;class &#39;int&#39;&gt;十进制 118二进制 175八进制 126十六进制 7855# 浮点类型 a&#x3D;3.14159print(a,type(a))n1&#x3D;1.1n2&#x3D;2.2print(n1+n2)n3&#x3D;2.1print(n1+n3)from decimal import Decimalprint(Decimal(&quot;1.1&quot;)+Decimal(&quot;2.2&quot;))3.14159 &lt;class &#39;float&#39;&gt;3.30000000000000033.23.3# 布尔类型 用来表示真或者假，True 表示为真，False 为假 布尔值可以转化为整数 True 1 False 0 f1&#x3D;Truef2&#x3D;Falseprint(f1,type(f1))print(f2,type(f2))print(f1+1)print(f2+1)True &lt;class &#39;bool&#39;&gt;False &lt;class &#39;bool&#39;&gt;21# 字符串类型 str1&#x3D;&#39; 人生苦短，我用 Python&#39;print (str1,type (str1))str2&#x3D;&quot;人生苦短，我用 Python&quot;print (str2,type (str2))str3&#x3D;&#39;&#39;&#39; 人生苦短， 我用 Python&#39;&#39;&#39;# 可以在多行显示print (str3,type (str3))人生苦短，我用 Python &lt;class&#39;str&#39;&gt;人生苦短，我用 Python &lt;class&#39;str&#39;&gt;人生苦短， 我用 Python &lt;class&#39;str&#39;&gt;","tags":"python"},{"title":"马士兵教育Python入门基础:1.python入门（二）","url":"/2020/09/12/2020-09-12-python2/","text":"Python 系列笔记 马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # 转义字符 反斜杠 + 想要实现的转义功能首字母 # 作者：周小钊# 时间：2020&#x2F;9&#x2F;23 19:18## 转义字符print (&quot;hello\\nworld&quot;)print (&quot;hello\\tworld&quot;)print (&quot;hello\\rworld&quot;)print (&quot;hello\\bworld&quot;)## 原字符。不希望字符串中的转义字符其作用，就使用原字符，就是在字符串之前加上 r 或 Rprint (r&quot;hello\\rworld&quot;)## 注意事项，最后一个字符不能是反斜杠helloworldhello worldworldhellworldhello\\rworld","tags":"python"},{"title":"马士兵教育Python入门基础:1.python入门（一）","url":"/2020/09/10/2020-09-10-python1/","text":"本教程主讲老师：马士兵教育杨淑娟老师，国内 Java 技术专家，Python 技术专家，数据库技术专家，腾讯评选教育培训界 “中国好老师” 称号。所编写的《Java 程序设计教程》，被广大高校作为计算机专业教材，51 自学网《SQL Server2008 视频教程》被几十万学员点赞观看。 目前该教程全套视频在 B 站，本系列笔记根据该视频编写，希望对大家有所帮助 Python 系列笔记： 马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # Python 的自述 pyhton 对大数据分析、人工智能中至关重要的机器学习、深度学习都提供了大量了支持，背后拥有最庞大的代码库 python 也被称为胶水语言，可以将 c++ 和 java 整合在一起 有一句话说的好：Python 除了不会生孩子，剩下啥都会 可以根据发展方向进行自身定位 # python 的简介 Python 是一个 90 后，被荷兰人吉多。范罗苏姆在 1989 年的圣诞节期间创建，为了打发无趣的圣诞节创造了 Python，在 1991 年时候被真正出现，吉多。范罗苏姆给这个编程语言起了个非常吓人的名字叫 Python (大蟒蛇的意思），该名字取自英国 20 世纪 70 年代首播的电视喜剧《蒙提。派森的飞行马戏团》（Monty Python's Flying Circus)。 现在 python 已经更新到 3.0 版本了，被大家叫做 Python3000，在 2020 年 1 月 1 日，官宣停止了 Python2 的更新，所以对于初学者的来说，你只需要学习 Python3.0 就可以了 Python 是一种跨平台的计算机程序设计语言 &gt; 把你的想法告诉 Python，Python 再以计算机认识的方式告诉计算机，Python 们是你们之间交流的工具 Python 是一种解释型语言 &gt; Python 在开发过程中是没有编译这个环节的，这一点 Python 与 Java 不一样 Python 是一种交互式语言 &gt; 你可以在 Python 的提示符 &gt;&gt;&gt; 后直接执行代码 Python 是面向对象语言 &gt; 在 Python 的世界里一切皆对象 Python 是初学者最好的语言 &gt; 对于初级程序员而言，Python 是非常伟大的，Python 支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏，Python 无所不能 # 搭建 Python 开发环境 下载 Python 编译器：Python3.8.5 安装后出现四个文件 一串代码可以直接打开 IDLE 编辑，多行代码时需要点击上方的 File&gt;New File 新建 Python 文件进行编写后保存 第一个 Python 程序 交互式命令行程序 Python 自带的简单开发环境 IDLE 新建 python 文件 first.py # 第三方开发环境 PyCharm 的下载与安装 下载 PyCharm 社区版：PyCharm 首先创建项目 File&gt; New Project 创建 python 文件 可以设置模板 File&gt; settings&gt;Editor&gt;File and Code Templates&gt;Python Script 编写注释模板 # Python 输出函数 print () 函数 将任何内容在 IDLE 或其它控制台显示 print () 可以输出数字、字符串、含有运算符的表达式，可以输出至文件和控制台 # 作者：周小钊# 时间：2020&#x2F;9&#x2F;20 17:25# 可以输出数字print (520)print (98.5)# 可以输出字符串print (&quot;hello world&quot;)# 含有运算符的表达式print (3+1)D:\\data\\pythoncourse\\venv\\Scripts\\python.exe D:&#x2F;data&#x2F;pythoncourse&#x2F;first.py52098.5hello world4该结果输出到控制台上 如果输出到文件上 #将数据输出到文件中，使用 file&#x3D;xx 格式fp&#x3D;open (&quot;D:&#x2F;text.txt&quot;,&quot;a+&quot;)# 如果文件不存在就创建，如果存在就追加print (&quot;helloworld&quot;,file&#x3D;fp)fp.close此时 D 盘出现了 text.txt 的文件 如果不想换行就使用 print (&quot;hello&quot;,&quot;world&quot;)，将多个想输出的内容放在一个 print 中","tags":"python"},{"title":"马士兵教育Python入门基础:1.python入门（一）","url":"/2020/09/10/2020-09-10-python11/","text":"本教程主讲老师：马士兵教育杨淑娟老师，国内 Java 技术专家，Python 技术专家，数据库技术专家，腾讯评选教育培训界 “中国好老师” 称号。所编写的《Java 程序设计教程》，被广大高校作为计算机专业教材，51 自学网《SQL Server2008 视频教程》被几十万学员点赞观看。 目前该教程全套视频在 B 站，本系列笔记根据该视频编写，希望对大家有所帮助 Python 系列笔记： 马士兵教育 Python 入门基础：1.python 入门（一） 马士兵教育 Python 入门基础：1.python 入门（二） 马士兵教育 Python 入门基础：2. 七十二变（1） 马士兵教育 Python 入门基础：2. 七十二变（2） 马士兵教育 Python 入门基础：3. 运算（1） 马士兵教育 Python 入门基础：3. 运算（2） 马士兵教育 Python 入门基础：4. 流程控制（1） 马士兵教育 Python 入门基础：4. 流程控制 (2) 马士兵教育 Python 入门基础：4. 流程控制 (3) # Python 的自述 pyhton 对大数据分析、人工智能中至关重要的机器学习、深度学习都提供了大量了支持，背后拥有最庞大的代码库 python 也被称为胶水语言，可以将 c++ 和 java 整合在一起 有一句话说的好：Python 除了不会生孩子，剩下啥都会 可以根据发展方向进行自身定位 # python 的简介 Python 是一个 90 后，被荷兰人吉多。范罗苏姆在 1989 年的圣诞节期间创建，为了打发无趣的圣诞节创造了 Python，在 1991 年时候被真正出现，吉多。范罗苏姆给这个编程语言起了个非常吓人的名字叫 Python (大蟒蛇的意思），该名字取自英国 20 世纪 70 年代首播的电视喜剧《蒙提。派森的飞行马戏团》（Monty Python's Flying Circus)。 现在 python 已经更新到 3.0 版本了，被大家叫做 Python3000，在 2020 年 1 月 1 日，官宣停止了 Python2 的更新，所以对于初学者的来说，你只需要学习 Python3.0 就可以了 Python 是一种跨平台的计算机程序设计语言 &gt; 把你的想法告诉 Python，Python 再以计算机认识的方式告诉计算机，Python 们是你们之间交流的工具 Python 是一种解释型语言 &gt; Python 在开发过程中是没有编译这个环节的，这一点 Python 与 Java 不一样 Python 是一种交互式语言 &gt; 你可以在 Python 的提示符 &gt;&gt;&gt; 后直接执行代码 Python 是面向对象语言 &gt; 在 Python 的世界里一切皆对象 Python 是初学者最好的语言 &gt; 对于初级程序员而言，Python 是非常伟大的，Python 支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏，Python 无所不能 # 搭建 Python 开发环境 下载 Python 编译器：Python3.8.5 安装后出现四个文件 一串代码可以直接打开 IDLE 编辑，多行代码时需要点击上方的 File&gt;New File 新建 Python 文件进行编写后保存 第一个 Python 程序 交互式命令行程序 Python 自带的简单开发环境 IDLE 新建 python 文件 first.py # 第三方开发环境 PyCharm 的下载与安装 下载 PyCharm 社区版：PyCharm 首先创建项目 File&gt; New Project 创建 python 文件 可以设置模板 File&gt; settings&gt;Editor&gt;File and Code Templates&gt;Python Script 编写注释模板 # Python 输出函数 print () 函数 将任何内容在 IDLE 或其它控制台显示 print () 可以输出数字、字符串、含有运算符的表达式，可以输出至文件和控制台 # 作者：周小钊# 时间：2020&#x2F;9&#x2F;20 17:25# 可以输出数字print (520)print (98.5)# 可以输出字符串print (&quot;hello world&quot;)# 含有运算符的表达式print (3+1)D:\\data\\pythoncourse\\venv\\Scripts\\python.exe D:&#x2F;data&#x2F;pythoncourse&#x2F;first.py52098.5hello world4该结果输出到控制台上 如果输出到文件上 #将数据输出到文件中，使用 file&#x3D;xx 格式fp&#x3D;open (&quot;D:&#x2F;text.txt&quot;,&quot;a+&quot;)# 如果文件不存在就创建，如果存在就追加print (&quot;helloworld&quot;,file&#x3D;fp)fp.close此时 D 盘出现了 text.txt 的文件 如果不想换行就使用 print (&quot;hello&quot;,&quot;world&quot;)，将多个想输出的内容放在一个 print 中","tags":"python"},{"title":"进化树在线制作工具iTOL教程（4）：添加点图","url":"/2020/09/08/2020-09-08-iTOL4/","text":"# 添加点图 依然去找示例文本 dataset_external_shapes_template.txt 前面部分依旧不更改，只修改 DATA 可以看到输入不同的 value 可能会使点的属性发生变化，为了防止出错，推荐一个表型（一列 value）用一个 dataset，最后挨个拖进去即可，这里只展示一组 点击 shape type 可以修改形状，点击 rawdata 可以局部修改 点击 legend 可以添加图例 刚刚是利用 iTOL 加的数量性状，接下来加质量性状，还是去找示例数据 不多说，只编辑 DATA 然后拖到网页 然后更改 看一下最终成品图","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（3）：添加图片","url":"/2020/09/06/2020-09-06-iTOL3/","text":"# 添加图片 依然是寻找示例文本 上面的不作任何修改，只修改最后的 DATA 需要注意，图片添加的是网址，而不是本地的图片，我们可以把想上传的图片写到简书上发表后在复制图片地址即可。 直接拖到网页，看一下效果 图片是没有办法单独设置的，如果感觉效果不太好，就在 datasets 调一下参数 最后导出文件即可","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（2）：添加文本","url":"/2020/09/03/2020-09-03-iTOL2/","text":"# 添加文本 利用 iTOL，我将进化树分为三个群体，接下来就是添加文本 与 evolview 一样，添加文本需要 datasets，依然可以去参考 help 页面 这里我放上了官网中所有参考格式模板的压缩包，需要可以下载 每个参数都作了说明，可以根据需要修改，有一些可以在网页更改，所以建议上面不做修改，只在 DATA 部分修改，根据示例修改即可 修改之后 可以直接将该文件拖到网页上，查看效果 此时 datasets 界面出现了我们上传文件的信息 如果想要修改一些属性，你会发现这是对三个文本同时修改，想要单独修改就点击 raw data&gt;edit using the web interface 这样就可以单独修改了","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树在线制作工具iTOL教程（1）：基本操作","url":"/2020/09/01/2020-09-01-iTOL1/","text":"# 使用界面 与 Evolview 一样，可以注册后使用，也可以白嫖，点击 upload 即可上传树文件 # 基本操作 右侧 controls 负责对进化树进行修改： basic 主要负责修改树的造型、分支、标签，还有标签的字体、字号是否加粗等 advance 主要负责展示 bootstrap 的特征 iTOL 最好用的一个功能是能修改局部的 label 和 leaf 当我们鼠标悬停在某个位置时，我们可到这个局部数据的信息 鼠标点击即可修改局部 node 的属性，比如我改一下颜色和风格，可以看到局部的 node 被改为红色虚线，局部的 label 也可以更改 在选好节点后，再点击 color&gt;new color range, 我们可以把一部分 label 和 branch 加入背景色 然后我再将 S26 添加到 h1 中，点击相应的 node，选择 color&gt;add to existing 即可，去掉的话选择 remove from 即可 点击 h1 的 cover，可以选择背景色出现在 label、clade、full 上，也可以关闭，我选一下 full border 负责加边框，0 就是不加，在这里我加一个 1px 的边框展示下 鼠标悬停在 label 上时，我们也可以修改局部 label 的属性，我在这里修改了 label 的名字 # 导出 点击 export，可以看到支持不同类型文件的导出 当 colored ranges lenged 点击 on 时，会出现图例 以上便是利用 iTOL 进行进化树美化的一些基本操作，相比起 evolview，iTOL 使用起来更加方便。","tags":"bioinformatics phylogenetic_tree itol"},{"title":"进化树+蛋白结构域","url":"/2020/08/30/2020-08-30-evolview3/","text":"# 目标 # 数据准备 依然查看 help 界面的 Protein domains 在上传数据的时候我们发现多了按钮，可以从 PFAM 上上传数据，evolview 使用的标签名必须与 PFAM 的 URL API 是一样的 # 手动上传 示例数据 KLF9_HUMAN 244 189,212,zf-H2C2_2,Pfam-A,,,PF13465,5.4e-05,32.80 159,186,zf-H2C2_2,Pfam-A,,,PF13465,0.0036,27.00 tab 分割 第一列，基因名，第二列，长度，第三列（189,212,zf-H2C2_2,Pfam-A,,,PF13465,5.4e-05,32.80），结构域信息，用逗号分割，一共有八个内容，如果有多个结构域，就用空格添加多个 其实结构与信息也不用全部加上，这样的例子也可以 159,186 159,186,WD40 159,186,WD40,Pfam-A 159,186,,Pfam-A 159,186,zf-H2C2_2,Pfam-A,,,PF13465 中间有内容缺失要补上逗号 159,186,zf-H2C2_2,Pfam-A,,,,0.0036,27.00 159,186,zf-H2C2_2,Pfam-A,,,PF13465,0.0036,27.00 还有一些对输出图形的属性更改 # 使用示例数据作图 成品图 可以看到我没有添加 group 和 color，系统会自动给我分类并用不同的颜色显示 还有个方法，我们可以去看示例数据的图比如 DEMOS 下的 protein domains 查看该进化树的 protein domain 信息，可以为我们的作图提供帮助 其他的进化树美化方法可以自己去参考 help 界面寻找帮助","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"进化树美化之Evolview--热图（2）","url":"/2020/08/28/2020-08-28-evolview/","text":"上个教程中已经修改了进化树的分支颜色和标签颜色，接下来进行热图绘制 # 数据准备 我们可以从 help 界面查看我们需要输入的数据类型 #heatmap !title Example of heatmap 图例标题 !showLegends 1 是否显示图例，1：显示，0：不显示 !defaultStrokeColor gold !defaultStrokeWidth 2 !colorgradient blue, yellow,red 热图配色 !colorgradientMarkLabel 0,5,10,15,20,25 颜色梯度值 # -- heatmap column labels -- !showHeatMapColumnLabel 1 热图表头显示 !heatmapColumnLabels e1,e2,e3,control 表头内容 # -- heatmap -- !heatmap margin=2,colwidth=30,roundedcorner=2 热图内部信息 # -- show data value !showdataValue show=1,fontsize=12 A -2,3,5,0 B 7,9,10,23 C 13,15,19,8 D 20,22,25,4 根据示例数据将我们的数据修改好 #heatmap !title Expression of heatmap !showLegends 0 #!defaultStrokeColor gold #!defaultStrokeWidth 2 !colorgradient red,white,blue !showHeatMapColumnLabel 1 # -- heatmap column labels -- !showHeatMapColumnLabel 1 !heatmapColumnLabels HS1,HS2,HS3,HS4 # -- heatmap -- !heatmap margin=1,colwidth=30,roundedcorner=5 # -- show data value !showdataValue show=0,fontsize=12,fontitalic=0,fontbold=1,textangle=-60,fontcolor=red AT1G03160.1 138.2662,119.4188,117.5653,131.9267 AT4G17540.1 190.04398,130.73198,140.72378,150.41085 Os06t0247800-01 22.3589,20.9118,19.7673,25.1028 Os02t0738900-01 93.544,21.6591,18.8547,31.3205 Os03t0732200-01 5.52722,4.83038,4.29929,3.81299 Os10t0185200-00 83.1737,83.2791,71.5573,69.86103 AT1G59610.1 40.8104,19.7877,21.998,34.7177 AT1G10290.1 140.8104,119.7877,121.998,134.7177 Os08t0425100-01 20.41115,39.6234,47.14298,63.02084 Os12t0178700-01 48.51467,52.1542,52.7949,62.7378 AT3G19720.1 124.4894,129.6265,127.352,132.6961 Os01t0748000-00 103.341,352.318,236.861,293.542 Os04t0129900-01 1.89585,8.67967,6.65843,2.84205 Os03t0260000-01 131.2451,61.22141,49.86475,97.78848 AT1G60500.1 29.84108,119.9479,125.1772,140.0944 Os01t0920400-01 152.695,113.472,74.9321,61.9664 AT2G14120.3 118.5393,229.62,230.3712,223.395 AT4G33650.2 15.4361,255.7039,138.4035,133.0883 Os04t0381000-01 1.81532,2.71541,4.09116,7.76133 Os05t0556100-01 322.122,217.55541,18.8402,15.2791 Os01t0681100-01 229.41612,249.59223,245.90516,125.5316 AT3G61760.1 232.8752,251.1922,136.812,117.087 AT5G42080.1 7.60426,3.105,8.66416,6.68762 Os09t0572900-01 27.5529,94.32025,40.786299,40.476955 AT1G14830.1 233.5316,235.4096,155.9334,164.4508 Os03t0713100-01 5.59436,3.86999,5.44011,4.85916 Os10t0567800-01 213.2103,218.9935,290.9288,225.216 AT2G44590.3 29.6786,52.4297,272.53,278.289 成品图： 可以看到三个 dataset 已经在右边显示了，可以选择是否显示或者删除，也可以点笔的形状进行修改 # 结果导出 在上方有三个按钮，可以保存为 png 格式、pdf 格式以及 nwk 格式 左侧也有一个按钮，可以保存为多种格式 将 png 格式保存到本地，可以看看效果 fine！！！","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"进化树美化之Evolview--热图（1）","url":"/2020/08/25/2020-08-25-evolview1/","text":"# 目标 达成以下效果 # Evolview 介绍 在线的进化树美化工具，可直接在搜索引擎找到，可以注册账号也可以直接点击 Try me 白嫖 # 数据上传 点击 uploadtree，选择 nwk 文件上传 该按钮可以选择树的整体布局 该按钮可以控制显示节点和分支的数值以及字体的样式和线的宽度 # 局部标签加背景色 该按钮主要负责上传树的一些控制文件 可以看到有不同的类型，根据图片指示就能看出是怎样改变树的。 一般来讲，我们可以去 help 界面去寻找我们想要的美化树的方法，然后根据提示创建文件即可。 准备好的表格文件，可以看到我已经把需求体现在表格中，下一步要按照标准格式进行修改上传 可以看到背景色已经变化 # 分支颜色更改 与标签颜色一样，按照相同的操作进行即可 目前已完成对标签和分支的颜色更改，下一步将加入右边的热图","tags":"bioinformatics evolview phylogenetic_tree"},{"title":"使用IGV简单绘制甲基化分布图","url":"/2020/08/23/2020-08-23-IGV/","text":"废话不多说，直接简单粗暴的开始吧 # 导入基因组 导入基因组文件：Genomes→load geome from file→选择 &quot;reference.fa&quot; 文件 导入注释文件：file →load geome from file →选择 om&quot;reference.gff&quot;，由于 gff 文件已经是按坐标顺序排列的，因此不需要重新排序。 # 导入甲基化数据文件 这是拿到的结果，标注了甲基化的类型以及所在位点。 IGV 导入的数据需要改为 IGV 格式，建议先学习下 IGV 文件的格式 可以看到，官网中给了我们 IGV 文件的格式例子，patient 就可以改为不同的甲基化类型，由于 IGV 格式的文件不支持正负链的标注，所以在转换成 IGV 格式文件时，我把负链的甲基化值变为负值 最后修改的 IGV 文件如下（tab 分割）： 然后通过 file→load from file 导入，结果如下图： 接下来，我们可以修改图片的颜色和字体大小，右键点击相应的行即可 点击 file→save image 即可保存最终图片","tags":"bioinformatics methylation"},{"title":"使用本地nt数据库对reads和Trinity结果进行blast","url":"/2020/08/20/2020-08-20-nt/","text":"上个笔记中，进行了共生物种的确定，由于地下部位的转录组还有一部分 reads 没有比对上，可能是样品污染问题，也可能含有其他的物种，所以，想使用 Trinity 和为比对上的 reads 去比对到 nt 数据库查看结果 # nt 数据库下载和构建 wget https:&#x2F;&#x2F;ftp.ncbi.nih.gov&#x2F;blast&#x2F;db&#x2F;FASTA&#x2F;nt.gzwget https:&#x2F;&#x2F;ftp.ncbi.nih.gov&#x2F;blast&#x2F;db&#x2F;FASTA&#x2F;nr.gz.md5md5sum nt.gzgunzip nt.gznohup makeblastdb -in nt -parse_seqids -hash_index -dbtype nucl -logfile nt_logfile &amp;这样，nt 数据库就构建好了，后续的话利用这个数据库去确定物种 下载数据库和构建时间有点长，需要耐心等待 # 使用未比对的 reads 进行 blast 在运行 STAR 时，加入 --outReadsUnmapped Fastx 参数会将未比对的 reads 输出到文件，双端测序会生成 mate1 和 mate2 两个文件，利用该 reads 去 blast $cat S1-1Ufli.left.fa S1-1Ufli.right.fa&gt;S1-1.reads.fa$cat S3-1fli.left.fa S3-1fli.right.fa&gt;S3-1.reads.fa$nohup blastn -query S1-1.reads.fa -out S1-1.reads.blast -db &#x2F;datadisk02&#x2F;data&#x2F;nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn1-1.log &amp;$nohup blastn -query S3-1.reads.fa -out S3-1.reads.blast -db &#x2F;datadisk02&#x2F;data&#x2F;nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn3-1.log &amp;# 使用 Trinity 组装未比对的 reads 后进行 blast 在把未比对的 reads 进行 blast 之后，我又试着把未比对的 reads 用 Trinity 进行组装，并进行 blast $nohup Trinity --seqType fa --max_memory 50G --left S1-1Ufli.left.fa --right S1-1Ufli.right.fa --CPU 16 --output S1-1Ufli_trinity &amp;$nohup Trinity --seqType fa --max_memory 50G --left S3-1fli.left.fa --right S3-1fli.right.fa --CPU 16 --output S3-1fli_trinity &amp;$nohup blastn -query S1-1Ufli_trinity&#x2F;Trinity.fasta -out S1-1.trinity.blast -db &#x2F;datadisk02&#x2F;data&#x2F;nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn1-1t.log &amp;$nohup blastn -query S3-1fli_trinity&#x2F;Trinity.fasta -out S3-1.trinity.blast -db &#x2F;datadisk02&#x2F;data&#x2F;nt -outfmt 6 -evalue 1e-10 -num_threads 8 -qcov_hsp_perc 50.0 -num_alignments 5 2&gt; blastn3-1t.log &amp;# 查看 blast 结果 对于 blast 结果，主要是对比对到的基因进行汇总，去找哪个物种比对到的基因最多，涉及课题原因比对到的物种我就不在这里展示了。","tags":"bioinformatics transcriptome"},{"title":"根据转录组数据鉴定共生物种","url":"/2020/08/18/2020-08-18-sys/","text":"最近做的项目是关于地衣的转录组和基因组，拿到的结果是真菌部位的基因组以及不同时期和部位的转录组，地下部位的藻类部由于太复杂而且杂质过多不好分离就没有测基因组，目前想知道地下部位的藻类到底是什么？根据之前的观察，推测是 Coccomyxa subellipsoidea，想要具体确定的话还需要进一步证明。 可以看到该地衣的地上部位是一种担子菌，地下部位不仅有藻类还有其他的物种。 # 转录组比对到真菌参考基因组 目前有真菌的测序基因组，第一步就是想把转录组数据比对到真菌的参考基因组上 比对工具我选择 STAR，使用地上部位（真菌部_Lh3-1）和地下部位（藻类部 _Lh1-1）的转录组比对到基因组上 建立索引 S$ATR --runMode genomeGenerate --genomeDir &#x2F;datadisk02&#x2F;mpoly&#x2F;hun_db&#x2F; --genomeFastaFiles &#x2F;datadisk02&#x2F;mpoly&#x2F;hudsoiana.fa比对 $STAR --runThreadN 20 --genomeDir &#x2F;datadisk02&#x2F;mpoly&#x2F;hun_db&#x2F; --readFilesCommand zcat --readFilesIn _Lh2-1_S110_L007_R1_001.fastq.gz _Lh2-1_S110_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S2-1$STAR --runThreadN 20 --genomeDir &#x2F;datadisk02&#x2F;mpoly&#x2F;hun_db&#x2F; --readFilesCommand zcat --readFilesIn _Lh3-1_S108_L007_R1_001.fastq.gz _Lh3-1_S108_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S1-1比对结束后我最关心的是比对率，按照预期，地下部位的比对率比地上部位低。 $less S1-1Log.final.out Started job on | Aug 20 05:48:00 Started mapping on | Aug 20 05:48:01 Finished on | Aug 20 06:42:35 Mapping speed, Million of reads per hour | 26.61 Number of input reads | 24198466 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 15397710 Uniquely mapped reads % | 60.89% $less S3-1Log.final.out Started job on | Aug 20 08:38:29 Started mapping on | Aug 20 08:38:30 Finished on | Aug 20 08:49:15 Mapping speed, Million of reads per hour | 134.06 Number of input reads | 24018884 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 19151198 Uniquely mapped reads % | 79.73% 可以看到结果符合预期，地下部位的 reads 比对率为 64%，地上部位为 80%。 # 地下部位转录组分析 接下来用地下部位的转录组分析确定共生藻，首先的想法是利用转录组数据比对到初步确定的共生藻 Coccomyxa subellipsoidea 上，使用 Coccomyxa subellipsoidea 的基因组建库进行比对 S$ATR --runMode genomeGenerate --genomeDir &#x2F;datadisk02&#x2F;mpoly&#x2F;cocco&#x2F; --genomeFastaFiles &#x2F;datadisk02&#x2F;mpoly&#x2F;Coccomyxa.fa$STAR --runThreadN 20 --genomeDir &#x2F;datadisk02&#x2F;mpoly&#x2F;cocco&#x2F; --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outSAMtype BAM SortedByCoordinate --outBAMsortingThreadN 5 --outFileNamePrefix S1-1C结果有点出乎意料，只有零点几的比对率， $less S1-1CLog.final.out Started job on | Aug 19 14:25:11 Started mapping on | Aug 19 14:25:16 Finished on | Aug 19 20:51:41 Mapping speed, Million of reads per hour | 3.96 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 92457 Uniquely mapped reads % | 0.36%由于地下部位比对到真菌部也有 64% 的比对率，所以我重新跑了一遍 STAR，利用 unmapped reads 进行比对。 $STAR --runThreadN 32 --genomeDir hun_db&#x2F; --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --readFilesCommand zcat --outSAMtype SAM --outFileNamePrefix S1-1 --outReadsUnmapped Fastx$awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; S1-1Unmapped.out.mate1| awk &#39;&#123;if (NR%4&#x3D;&#x3D;1||NR%4&#x3D;3) print&#125;&#39; &gt; S1-1.left.fa$sed -i &quot;s&#x2F;@&#x2F;&gt;&#x2F;g&quot; S1-1.left.fa$awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; S1-1Unmapped.out.mate2| awk &#39;&#123;if (NR%4&#x3D;&#x3D;1||NR%4&#x3D;3) print&#125;&#39; &gt; S1-1.right.fa$sed -i &quot;s&#x2F;@&#x2F;&gt;&#x2F;g&quot; S1-1.right.fa$STAR --runThreadN 20 --genomeDir cocco&#x2F; --readFilesIn S1-1.left.fa S1-1.right.fa --outSAMtype SAM --outFileNamePrefix S1-1UC --outReadsUnmapped Fastx$less S1-1UCLog.final.out Started job on | Aug 26 10:59:26 Started mapping on | Aug 26 10:59:39 Finished on | Aug 26 15:32:14 Mapping speed, Million of reads per hour | 1.58 Number of input reads | 7180320 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 96710 Uniquely mapped reads % | 1.35%比对率也只有可怜的 1.35%，一开始我怀疑是不是藻类物种鉴定错了，后来我用了 ncbi 中所有藻类的基因组，比对率都不到 1%。 后来去网上搜索比对率低的原因，在 github 上发现相应解答，加入 --outFilterScoreMinOverLread 0.3 和 --outFilterMatchNminOverLread 0.3 参数 $STAR --runThreadN 20 --genomeDir hun_db&#x2F; --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outFileNamePrefix S1-1fli --outReadsUnmapped Fastx --outSAMtype SAM --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1fliLog.finall.out Started job on | Aug 27 09:52:31 Started mapping on | Aug 27 09:52:37 Finished on | Aug 27 13:02:11 Mapping speed, Million of reads per hour | 8.08 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 16371292 Uniquely mapped reads % | 64.16%$STAR --runThreadN 20 --genomeDir cocco&#x2F; --readFilesCommand zcat --readFilesIn _Lh1-1_S110_L007_R1_001.fastq.gz _Lh1-1_S110_L007_R2_001.fastq.gz --outFileNamePrefix S1-1Cfli --outReadsUnmapped Fastx --outSAMtype SAM --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1CfliLog.final.out Started job on | Aug 27 09:52:51 Started mapping on | Aug 27 09:52:53 Finished on | Aug 28 04:02:41 Mapping speed, Million of reads per hour | 1.40 Number of input reads | 25517519 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 1475579 Uniquely mapped reads % | 5.78%对率有 5.78%，提高了一点。 接下来，我使用真菌的 unmapped reads 进行比对，看看没有比到真菌上的 reads 有多少是藻类的。 $awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; S1-1fliUnmapped.out.mate1| awk &#39;&#123;if (NR%4&#x3D;&#x3D;1||NR%4&#x3D;3) print&#125;&#39; &gt; S1-1fli.left.fa$sed -i &quot;s&#x2F;@&#x2F;&gt;&#x2F;g&quot; S1-1.left.fa$awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; S1-1fliUnmapped.out.mate2| awk &#39;&#123;if (NR%4&#x3D;&#x3D;1||NR%4&#x3D;3) print&#125;&#39; &gt; S1-1fli.right.fa$sed -i &quot;s&#x2F;@&#x2F;&gt;&#x2F;g&quot; S1-1.right.fa$STAR --runThreadN 20 --genomeDir cocco&#x2F; --readFilesIn S1-1fli.left.fa S1-1fli.right.fa --outSAMtype SAM --outFileNamePrefix S1-1Ufli --outReadsUnmapped Fastx --outFilterScoreMinOverLread 0.3 --outFilterMatchNminOverLread 0.3$less S1-1UfliLog.final.out Started job on | Aug 27 14:28:39 Started mapping on | Aug 27 14:28:44 Finished on | Aug 27 21:38:00 Mapping speed, Million of reads per hour | 0.86 Number of input reads | 6123885 Average input read length | 300 UNIQUE READS: Uniquely mapped reads number | 1441904 Uniquely mapped reads % | 23.55%也就是说，在剩余的 36% 未比对的 reads 中有 23% 属于 Coccomyxa，总比对率有 70% 左右，地上部位按照相同的步骤进行比对有 83% 的比对率，这个现象也正常，因为地下部位的组织特别复杂，在取样时肯定包含了很多杂质，比对率肯定比地上部位低。 # 总结 目前已经可以确定地下部位的藻类就是 Coccomyxa 属的，是不是 Coccomyxa subellipsoidea 目前还不确定，接下来的工作是确定地下部位未比对上 reads 的所属。","tags":"bioinformatics transcriptome"},{"title":"R数据科学笔记:4","url":"/2020/08/16/2020-08-16-R4ds4/","text":"本次笔记整理了第一部分《探索》，具体函数的用法还是要去之前的笔记看一下 R 数据科学笔记：1 R 数据科学笔记：2 R 数据科学笔记：3 # 1.ggplot2 相关 gglpot2 绘图模板： ggplot(data = &lt;DATA&gt;) +&lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;),stat = &lt;STAT&gt;,position = &lt;POSITION&gt;) +&lt;FACET_FUNCTION&gt; 真正的绘图命令（stat_ ，geom_ ，annotate），这三类就是实现一个函数一个图层的核心函数。 geom_abline 线图，由斜率和截距指定 geom_area 面积图（即连续的条形图） geom_bar 条形图 geom_bin2d 二维封箱的热图 geom_blank 空的几何对象，什么也不画 geom_boxplot 箱线图 geom_contour 等高线图 geom_crossbar crossbar 图（类似于箱线图，但没有触须和极值点） geom_density 密度图 geom_density2d 二维密度图 geom_errorbar 误差线（通常添加到其他图形上，比如柱状图、点图、线图等） geom_errorbarh 水平误差线 geom_freqpoly 频率多边形（类似于直方图） geom_hex 六边形图（通常用于六边形封箱） geom_histogram 直方图 geom_hline 水平线 geom_jitter 点、自动添加了扰动 geom_line 线 geom_linerange 区间，用竖直线来表示 geom_path 几何路径，由一组点按顺序连接 geom_point 点 geom_pointrange 一条垂直线，线的中间有一个点（与 Crossbar 图和箱线图相关，可以用来表示线的范围） geom_polygon 多边形 geom_quantile 一组分位数线（来自分位数回归） geom_rect 二维的长方形 geom_ribbon 彩虹图（在连续的 x 值上表示 y 的范围，例如 Tufte 著名的拿破仑远征图） geom_rug 触须 geom_segment 线段 geom_smooth 平滑的条件均值 geom_step 阶梯图 geom_text 文本 geom_tile 瓦片（即一个个的小长方形或多边形） geom_vline 竖直线 统计变换函数 stat_abline 添加线条，用斜率和截距表示 stat_bin 分割数据，然后绘制直方图 stat_bin2d 二维密度图，用矩阵表示 stat_binhex 二维密度图，用六边形表示 stat_boxplot 绘制带触须的箱线图 stat_contour 绘制三维数据的等高线图 stat_density 绘制密度图 stat_density2d 绘制二维密度图 stat_function 添加函数曲线 stat_hline 添加水平线 stat_identity 绘制原始数据，不进行统计变换 stat_qq 绘制 Q-Q 图 stat_quantile 连续的分位线 stat_smooth 添加平滑曲线 stat_spoke 绘制有方向的数据点（由 x 和 y 指定位置，angle 指定角度） stat_sum 绘制不重复的取值之和（通常用在三点图上） stat_summary 绘制汇总数据 stat_unique 绘制不同的数值，去掉重复的数值 stat_vline 绘制竖直线 aes : 用于修改 geom_XXX () aes 参数控制了对哪些变量进行图形映射，图形属性（aes） 横纵坐标（x 与 y）、点的大小（size）、颜色（color），透明度（alpha）和形状（shape）等。 position: 定位函数。 position_dodge 并列。 position_fill 填充。 position_identity 不对位置进行处理。 position_jitter 扰动处理。 position_stack 堆叠处理。 coord：坐标函数。 coord_cartesian 笛卡儿坐标。 coord_equal 等尺度坐标（斜率为 1）。 coord_flip 翻转笛卡儿坐标。 coord_map 地图投影 。 coord_polar 极坐标投影 。 coord_trans 变换笛卡儿坐标。 # 2.dplyr 数据转换 1. 按行筛选:filter (): 按给定的逻辑判断筛选出符合要求的子数据集，类似于 subset () 函数 2. 按列筛选:select ():select () 用列名作参数来选择子数据集。 starts_with (“abc”) 匹配以 “abc” 开头的名称 ends_with (“xyz”) 匹配以 “xyz” 结尾的名称 ontains (“ijk”) 匹配包含 “ijk” 的名称 matches (“(.)\\1”) 匹配正则表达式的那些变量 3. 排列行:arrange (): 改变行的顺序，如果列名不止一个，就使后面的列在前面的基础上进行排序 4. 添加新变量:mutate ():mutate 可以对数据框中已有的变量进行操作或者增加变量，如果只想保留新变量，可以使用 transmute () 函数 5. 分组摘要:summarize: 与 group_by () 连用可以构成 dplyr 的最常用操作之一：分组摘要，亦可以与 mutate () 和 filter () 结合。","tags":"r_study r_for_data_science"},{"title":"基因共表达网络图的绘制","url":"/2020/08/10/2020-08-10-cytoscape/","text":"前面的教程已经进行了 WGCNA 分析并将各个模块的网络图绘制文件导出，接下来将进行共表达网络的绘制，本次教程依旧根据 PlantTech 的 Cytoscape 课程编写，希望对大家有所帮助。 WGCNA 教程 WGCNA 分析原理 WGCNA 应用场景 WGCNA 分析实践 # 1. 数据导入 WGCNA 分析后有许多模块，我选择上次分析中与 Luminal 亚型最相关的 pink 模块进行分析。 打开 cytoscape， 选择 File&gt;import&gt;import network from file, 打开 WGCNA 分析中得到的 CytoscapeInput-edges-pink.txt 文件，可以看到如下界面 接下来我们需要修改每个表头（每一列的属性），改成如下即可 可以看到做出来的网络非常丑，不着急，下一步进行网络的修改，美化一下 # 2. 修改网络 点击 Tools&gt;networkanalyzer&gt;network analysis&gt;analyze network 弹出以下界面 选择第二个的无方向网络，接着选择 node degree distribution，点击下方的 Visualize Parameters。 出现四个选择项：上边两个是调节 node 的，下边两个是调节 edge 的，大家可以根据自己的需要去选择。 可以看到所有的 node 已经根据节点数的多少有不同的大小。 在最下方的表格中将数据按照节点数目排序，将大于 100 的 node 选出，在 name 一列选择相应的 node 然后右键 select node from selected rows 可以将想要的 node 选出，然后拖拽到合适的位置。 选中 degree 大于 100 的所有点，点击 layout&gt;circular layout&gt;select node only , 将选中的 nodes 按照圆形排列 出现了奇怪的图，点击 layout&gt;setting, 设置 Circle size 的大小，可以设置圆的大小。 最后，我们再修改一下 node 和 egde 的颜色 左侧的设置栏我们可以修改 node 的颜色以及标签的颜色 然后点击下方的 edge，修改 edge 的状态。在做 WGCNA 分析时，不同基因的之间的相关度有一个 weight 值，我们可以根据 weight 值的大小判断两个基因之间的相关性。 将 Edge color to arrows 打钩，选择最上方的 Color（Unselected）选项。column 选择 weight，mapping type 选择 continuous mapping 选项 点击那个渐变的色块，我们可以修改颜色 点击上面的三个小箭头，然后点击下方的 Edge Color，可以对不同位置的颜色进行修改。 最后放上成品图，可能有点丑，大家根据自己的需要自行修改即可 # 3. 数据导出 最后，我们可以将网络的表格文件和网络图导出 首先导出网络表格，点击最右侧的 export，将表格文件导出至想要的位置即可 接下来是导出图片，选择 file&gt;export&gt;network to image, 选择想要的图片文件格式，需要注意，保存图片时其实是对主界面进行一个截图操作，先将网络调成自己想要的大小然后再导出即可 最后我们也可以将图例导出，选择 create legend，保存想要的图例格式即可 # 后记 该课程主要借鉴了 PlantTech 的 Cytoscape 课程编写，视频我已下载，大家有需要可以去百度云下载（提取码：5z41） 视频压缩包解压密码是我博客 about 界面下的一行小字（出自《蒲公英女孩》，标点是英文），如果链接炸了去博客找我联系方式。 网络图绘制教程个人感觉还是用视频教程更好，目前有录制视频的打算，录制好之后我会放到 B 站，主要还是看自己的时间允不允许。","tags":"bioinformatics cytoscape"},{"title":"R数据科学笔记:3","url":"/2020/08/10/2020-08-13-R4ds3/","text":"# 第四章：工作流：脚本 迄今为止，我们一直使用 RStudio 控制台来运行代码。这是一个非常好的开始，但如果需要创建更复杂的 ggplot2 图形或者 dplyr 管道，你很快就会发现控制台非常不方便。为了拓展工作空间，我们应该使用 RStudio 脚本编辑器。要想打开脚本编辑器，可以点击 File 菜单，选择 New File，接着选择 R Script；也可以使用组合键 Ctrl+Shift+N。现在你可以看到 4 个窗格。 如果你很重视一段代码，那么脚本编辑器就是存放这段代码的绝好位置。你可以在控制台中不断调试，一旦代码正常运行并输出预期结果，你就可以将其放在脚本编辑器中。当退出 RStudio 时，它会自动保存编辑器中的内容，并在重新打开时自动加载编辑器中的内容。尽管如此，我们还是应该定时保存脚本，并做好备份。 # 4.1 运行代码 脚本编辑器还非常适合建立复杂的 ggplot2 图形或较长的 dplyr 操作序列。有效使用脚本编辑器的关键是记住最重要的快捷键之一：Ctrl+Enter。这组快捷键会在控制台中执行当前的 R 语句。例如，输入以下代码后，如果光标在█ 处，那么按 Ctrl+Enter 会运行生成 not_cancedlled 的完整命令，并将光标移到下一个语句（即以 not_cancelled %&gt;% 开头的语句）。因此，重复按 Ctrl+Enter 就可以轻松运行整个脚本： 除了按照语句顺序运行，还可以一次性运行整个脚本：Ctrl+Shift+S。定期运行整个脚本是非常好的做法，可以让你确认脚本中所有重要的代码都没有问题。 # 4.2 Rstudio 自动诊断 脚本编辑器还会利用红色波浪线和边栏的红叉来高亮显示语法错误： 将鼠标移到红叉上就可以看到错误提示： RStudio 还能找出潜在的代码问题： # 第五章：探索性数据分析 # 5.1 简介 本章将展示如何使用可视化方法和数据转换来系统化地探索数据，统计学家将这项任务称为探索性数据分析（exploratory data analysis，EDA）。EDA 是一个可迭代的循环过程，具有以下作用。 (1) 对数据提出问题。 (2) 对数据进行可视化、转换和建模，进而找出问题的答案。 (3) 使用上一个步骤的结果来精炼问题，并提出新问题。 EDA 并不是具有严格规则的正式过程，它首先是一种思维状态。在 EDA 的初始阶段，应该天马行空地发挥想象力，并考察和试验能够想到的所有方法。有些想法是行得通的，有些想法则会无疾而终。当探索更进一步时，你就可以锁定容易产生成果的几个领域，将最终想法整理成文，并与他人进行沟通。 EDA 是所有数据分析过程中的重要环节，因为总是需要考察一下数据质量，即使你可以不费吹灰之力就找出问题。数据清洗只是 EDA 的一项具体应用，此时你提出的问题是，数据是否符合预期。要想进行数据清洗，需要使用所有的 EDA 工具：可视化、数据转换和建模。 # 5.2 问题 EDA 期间的目标是获取对数据的理解。进行 EDA 的最简单的方式就是将问题作为指导调查研究的工具。提出问题后，这个问题就使得你将注意力集中在数据集中的特定部分，并帮助你进行有关图形、模型和数据转换的决定。 EDA 本质上是一个创造性过程。和多数创造性过程一样，问题的质量关键在于问题的数量。分析过程的开始阶段很难提出有启发性的问题，因为你并不知道数据集中包含了哪些真知灼见。另一方面，你提出的每个新问题都可以揭示数据中的新内容，并增加发现知识的机会。如果在知识发现的基础上不断使用新问题来补充每个老问题，那么你就可以快速地获取数据中最令人感兴趣的部分，并总结出一组发人深省的问题。 对于应该提出什么样的问题来指导我们的研究，现在还没有确定的规则。但有两类问题总是有助于我们在数据中发现知识。我们可以粗略地将这两类问题表述如下。 (1) 变量本身会发生何种变动？ (2) 不同变量之间会发生何种相关变动？ 本章剩余部分会继续讨论这两个问题。我们将解释什么是变动，什么是相关变动，并介绍回答这两个问题的几种方法。为了简化讨论，我们先定义几个术语。 ・变量：一种可测量的数量、质量或属性。 ・值：变量在测量时的状态。变量值在每次测量之间可以发生改变。 ・观测：或称个案，指在相同条件下进行的一组测量（通常，一个观测中的所有测量是在同一时间对同一对象进行的）。一个观测会包含多个值，每个值关联到不同的变量。有时我们会将观测称为数据点。 ・表格数据：一组值的集合，其中每个值都关联一个变量和一个观测。如果每个值都有自己所属的 “单元”，每个变量都有自己所属的列，每个观测都有自己所属的行，那么表格数据就是整洁的。 # 5.3 变动 变动是每次测量时数据值的变化趋势。实际生活中很容易看到变动。如果对任意连续型变量进行两次测量，那么会得到两个不同的结果，即使测量的是一个常数（如光速），情况也是如此。每次测量的结果都包括少量误差，误差在每次测量间是不同的。如果测量多个项目（如不同人的眼睛颜色）或进行多次测量（如电池在不同时刻的电量），分类变量也会发生变化。所有变量都有自己的变动模式，可以揭示出一些有趣的信息。理解这种模式的最好方法就是对变量值的分布进行可视化表示。 # 5.3.1 对分布进行可视化表示 对变量分布进行可视化的方法取决于变量是分类变量还是连续变量。如果仅在较小的集合内取值，那么这个变量就是分类变量。分类变量在 R 中通常保存为因子或字符向量。要想检查分类变量的分布，可以使用条形图： ggplot(data &#x3D; diamonds) +geom_bar(mapping &#x3D; aes(x &#x3D; cut)) 条形的高度表示每个 x 值中观测的数量，可以使用 dplyr::count () 手动计算出这些值： &gt; diamonds %&gt;%+ count(cut)# A tibble: 5 x 2 cut n &lt;ord&gt; &lt;int&gt;1 Fair 16102 Good 49063 Very Good 120824 Premium 13791如果可以在无限大的有序集合中任意取值，那么这个变量就是连续变量。数值型和日期时间型变量就是连续变量的两个例子。要想检查连续变量的分布，可以使用直方图： ggplot(data &#x3D; diamonds) + geom_histogram(mapping &#x3D; aes(x &#x3D; carat), binwidth &#x3D; 0.5) 可以通过 dplyr::count () 和 ggplot2::cut_width () 函数的组合来手动计算结果： &gt; diamonds %&gt;%+ count(cut_width(carat, 0.5))# A tibble: 11 x 2 &#96;cut_width(carat, 0.5)&#96; n &lt;fct&gt; &lt;int&gt; 1 [-0.25,0.25] 785 2 (0.25,0.75] 29498 3 (0.75,1.25] 15977 4 (1.25,1.75] 5313 5 (1.75,2.25] 2002 6 (2.25,2.75] 322 7 (2.75,3.25] 32 8 (3.25,3.75] 5 9 (3.75,4.25] 410 (4.25,4.75] 1直方图对 x 轴进行等宽分箱，然后使用条形的高度来表示落入每个分箱的观测的数量。在上图中，最高的条形表示几乎有 30 000 个观测的 carat 值在 0.25 和 0.75 之间，这两个值分别是条形的左侧值和右侧值。 使用 binwidth 参数来设定直方图中的间隔的宽度，该参数是用 x 轴变量的单位来度量的。在使用直方图时，你应该试验一下不同的分箱宽度，因为不同的分箱宽度可以揭示不同的模式。例如，如果只考虑重量小于 3 克拉的钻石，并选择一个更小的分箱宽度，那么直方图如下所示： smaller &lt;- diamonds %&gt;% filter(carat &lt; 3)ggplot(data &#x3D; smaller, mapping &#x3D; aes(x &#x3D; carat)) + geom_histogram(binwidth &#x3D; 0.1) 如果想要在同一张图上叠加多个直方图，那么我们建议你使用 geom_freqploy () 函数来代替 geom_histogram () 函数。geom_freqploy () 可以执行和 geom_histogram () 同样的计算过程，但前者不使用条形来显示计数，而是使用折线。叠加的折线远比叠加的条形更容易理解： # 5.3.2 典型值 条形图和直方图都用比较高的条形表示变量中的常见值，而用比较矮的条形表示变量中不常见的值。没有条形的位置表示数据中没有这样的值。为了将这些信息转换为有用的问题，看看是否具有意料之外的情况。 ・哪些值是最常见的？为什么？ ・哪些值是非常罕见的？为什么？这和你的预期相符吗？ ・你能发现任何异乎寻常的模式吗？如何解释？ 作为示例，可以从以下直方图发现几个有趣的问题。 ・为什么重量为整数克拉和常见分数克拉的钻石更多？ ・为什么位于每个峰值稍偏右的钻石比稍偏左的钻石更多？ ・为什么没有重量超过 3 克拉的钻石？ ggplot(data &#x3D; smaller, mapping &#x3D; aes(x &#x3D; carat)) + geom_histogram(binwidth &#x3D; 0.01) 一般来说，相似值聚集形成的簇表示数据中存在子组。为了理解子组，我们提出以下问题。 ・每个簇中的观测是如何相似的？ ・不同簇之间的观测是如何不相似的？ ・如何解释或描述各个簇？ ・为什么有些簇的外观可能具有误导作用？ 以下的直方图显示了美国黄石国家公园中的老忠实喷泉的 272 次喷发的时长（单位为分钟）。喷发时间似乎聚集成了两组：短喷发（2 分钟左右）和长喷发（4~5 分钟），这两组间几乎没有其他喷发时间： ggplot(data &#x3D; faithful, mapping &#x3D; aes(x &#x3D; eruptions)) + geom_histogram(binwidth &#x3D; 0.25) # 5.3.3 异常值 异常值是与众不同的观测或者是模式之外的数据点。有时异常值是由于数据录入错误而产生的；有时异常值则能开辟出一块重要的新科学领域。如果数据量比较大，有时很难在直方图上发现异常值。例如，查看钻石数据集中 y 轴变量的分布，唯一能表示存在异常值的证据是，y 轴的取值范围出奇得宽： ggplot(diamonds) + geom_histogram(mapping &#x3D; aes(x &#x3D; y), binwidth &#x3D; 0.5) 正常值分箱中的观测太多了，以致于包括异常值的分箱高度太低，因此我们根本看不见（如果仔细观察 x 轴 0 刻度附近，没准你能发现点什么）。为了更容易发现异常值，我们可以使用 coord_cartesian () 函数将 y 轴靠近 0 的部分放大： ggplot(diamonds) +geom_histogram(mapping &#x3D; aes(x &#x3D; y), binwidth &#x3D; 0.5) +coord_cartesian(ylim &#x3D; c(0, 50)) coord_cartesian () 函数中有一个用于放大 x 轴的 xlim () 参数。ggplot2 中也有功能稍有区别的 xlim () 和 ylim () 函数：它们会忽略溢出坐标轴范围的那些数据。 这样一来，我们就可以看出有 3 个异常值，分别位于 0、30 左右和 60 左右。我们使用 dplyr 将它们找出来： &gt; unusual &lt;- diamonds %&gt;%+ filter(y &lt; 3 | y &gt; 20) %&gt;%+ arrange(y)&gt; unusual# A tibble: 9 x 10 carat cut color clarity depth table price x y &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;1 1 Very~ H VS2 63.3 53 5139 0 0 2 1.14 Fair G VS1 57.5 67 6381 0 0 3 1.56 Ideal G VS2 62.2 54 12800 0 0 4 1.2 Prem~ D VVS1 62.1 59 15686 0 0 5 2.25 Prem~ H SI2 62.8 59 18034 0 0 6 0.71 Good F SI2 64.1 60 2130 0 0 7 0.71 Good F SI2 64.1 60 2130 0 0 8 0.51 Ideal E VS1 61.8 55 2075 5.15 31.89 2 Prem~ H SI2 58.9 57 12210 8.09 58.9# ... with 1 more variable: z &lt;dbl&gt;y 变量测量钻石的三个维度之一，单位为毫米。我们知道钻石的宽度不可能是 0 毫米，因此这些值肯定是错误的。我们也完全可以认为 32 毫米和 59 毫米同样是令人难以置信的，这样的钻石长度超过 1 英寸（1 英寸 = 2.54 厘米），简直就是无价之宝！ # 5.4 缺失值 如果在数据集中发现异常值，但只想继续进行其余的分析工作，那么有 2 种选择。 ・将带有可疑值的行全部丢弃 diamonds2 &lt;- diamonds %&gt;% filter(between(y, 3, 20))不建议使用这种方式，因为一个无效测量不代表所有测量都是无效的。此外，如果数据质量不高，若对每个变量都采取这种做法，那么你最后可能会发现数据已经所剩无几！ ・相反，我们建议使用缺失值来代替异常值。最简单的做法就是使用 mutate () 函数创建一个新变量来代替原来的变量。你可以使用 ifelse () 函数将异常值替换为 NA： diamonds2 &lt;- diamonds %&gt;% mutate(y &#x3D; ifelse(y &lt; 3 | y &gt; 20, NA, y))ifelse () 函数有 3 个参数。第一个参数 test 应该是一个逻辑向量，如果 test 为 TRUE，函数结果就是第二个参数 yes 的值；如果 test 为 FALSE，函数结果就是第三个参数 no 的值。 和 R 一样，ggplot2 也遵循不能无视缺失值的原则。因为无法明确地绘制出缺失值，所以 ggplot2 在绘图时会忽略缺失值，但会提出警告以通知缺失值被丢弃了： &gt; ggplot(data &#x3D; diamonds2, mapping &#x3D; aes(x &#x3D; x, y &#x3D; y)) ++ geom_point()Warning message:Removed 9 rows containing missing values (geom_point). 要想不显示这条警告，可以设置 na.rm = TRUE： ggplot(data &#x3D; diamonds2, mapping &#x3D; aes(x &#x3D; x, y &#x3D; y)) + geom_point(na.rm &#x3D; TRUE)# 5.5 相关变动 如果变动描述的是一个变量内部的行为，那么相关变动描述的就是多个变量之间的行为。相关变动是两个或多个变量以相关的方式共同变化所表现出的趋势。查看相关变动的最好方式是将两个或多个变量间的关系以可视化的方式表现出来。如何进行这种可视化表示同样取决于相关变量的类型。 # 5.5.1 分类变量与连续变量 我们经常需要探索连续变量的分布，这种分布按照一个分类变量的值可以分为几个组，就像前面的频率多边形图一样。geom_freqpoly () 的默认外观不太适合这种比较，因为高度是由计数给出的。这就意味着，如果一组观测的数量明显少于其他组的话，就很难看出形状上的差别。举个例子，我们探索一下钻石价格是如何随着质量而变化的： ggplot(data &#x3D; diamonds, mapping &#x3D; aes(x &#x3D; price)) +geom_freqpoly(mapping &#x3D; aes(color &#x3D; cut), binwidth &#x3D; 500) 很难看出分布上的差别，因为总体看来各组数量的差别太大了： 按分类变量的分组显示连续变量分布的另一种方式是使用箱线图。箱线图是对变量值分布的一种简单可视化表示，这种图在统计学家中非常流行。每张箱线图都包括以下内容。 ・一个长方形箱子，下面的边表示分布的第 25 个百分位数，上面的边表示分布的第 75 个 百分位数，上下两边的距离称为四分位距。箱子的中部有一条横线，表示分布的中位数， 也就是分布的第 50 个百分位数。这三条线可以表示分布的分散情况，还可以帮助我们 明确数据是关于中位数对称的，还是偏向某一侧。 ・圆点表示落在箱子上下两边 1.5 倍四分位距外的观测，这些离群点就是异常值，因此需 要单独绘出。 ・从箱子上下两边延伸出的直线（或称为须）可以到达分布中最远的非离群点处。 使用 geom_boxplot () 函数查看按切割质量分类的价格分布： ggplot(data &#x3D; diamonds, mapping &#x3D; aes(x &#x3D; cut, y &#x3D; price)) +geom_boxplot() 虽然看不出太多关于分布的信息，但箱线图更加紧凑，因此可以更容易地比较多个类别（也更适合使用一张图来表示）。与前面的图形一样，我们可以从箱线图中发现违反直觉的现象：质量更好的钻石的平均价格更低！你将在练习中接受这一挑战，说明为什么会这样。 cut 是一个有序因子：“一般” 不如 “较好”、“较好” 不如 “很好”，以此类推。因为很多分类变量并没有这种内在的顺序，所以有时需要对其重新排序来绘制信息更丰富的图形。重新排序的其中一种方法是使用 reorder () 函数。 例如，我们看一下 mpg 数据集中的 class 变量。你可能很想知道公路里程因汽车类别的不同会有怎样的变化： ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; class, y &#x3D; hwy)) + geom_boxplot() 为了更容易发现趋势，可以基于 hwy 值的中位数对 class 进行重新排序： ggplot(data &#x3D; mpg, mapping &#x3D; aes( x &#x3D; reorder(class,hwy,FUN &#x3D; median), y &#x3D; hwy)) + geom_boxplot() 如果变量名很长，那么将图形旋转 90 度效果会更好一些。你可以通过 coord_flip () 函数完成这一操作： # 5.5.2 两个分类变量 要想对两个分类变量间的相关变动进行可视化表示，需要计算出每个变量组合中的观测数量。完成这个任务的其中一种方法是使用内置的 geom_count () 函数： ggplot(data &#x3D; diamonds) + geom_count(mapping &#x3D; aes(x &#x3D; cut, y &#x3D; color)) 图中每个圆点的大小表示每个变量组合中的观测数量。相关变动就表示为特定 x 轴变量值与特定 y 轴变量值之间的强相关关系。 计算变量组合中的观测数量的另一种方法是使用 dplyr： &gt; diamonds %&gt;%+ count(color, cut)# A tibble: 35 x 3 color cut n &lt;ord&gt; &lt;ord&gt; &lt;int&gt; 1 D Fair 163 2 D Good 662 3 D Very Good 1513 4 D Premium 1603 5 D Ideal 2834 6 E Fair 224 7 E Good 933 8 E Very Good 2400 9 E Premium 233710 E Ideal 3903# ... with 25 more rows接着使用 geom_tile () 函数和填充图形属性进行可视化表示： diamonds %&gt;% count(color, cut) %&gt;% ggplot(mapping &#x3D; aes(x &#x3D; color, y &#x3D; cut)) + geom_tile(mapping &#x3D; aes(fill &#x3D; n)) 如果分类变量是无序的，那么可以使用 seriation 包对行和列同时进行重新排序，以便更清楚地表示出有趣的模式。对于更大的图形，你可以使用 d3heatmap 或 heatmaply 包，这两个包都可以生成有交互功能的图形。 # 5.5.3 两个连续变量 对于两个连续变量间的相关变动的可视化表示，我们已经介绍了一种非常好的方法：使用 geom_point () 画出散点图。你可以将相关变动看作点的模式。例如，你可以看到钻石的克拉数和价值之间存在一种指数关系： ggplot(data &#x3D; diamonds) + geom_point(mapping &#x3D; aes(x &#x3D; carat, y &#x3D; price)) 随着数据集规模的不断增加，散点图的用处越来越小，因为数据点开始出现过绘制，并堆积在一片黑色区域中（如上面的散点图所示）。我们已经介绍了解决这个问题的一种方法，即使用 alpha 图形属性添加透度： ggplot(data &#x3D; diamonds) + geom_point( mapping &#x3D; aes(x &#x3D; carat, y &#x3D; price), alpha &#x3D; 1 &#x2F; 100 ) 但是很难对特别大的数据集使用透明度。另一种解决方法是使用分箱。我们之前使用了 geom_histogram () 和 geom_freqpoly () 函数在一个维度上进行分箱，现在学习如何使用 geom_bin2d () 和 geom_hex () 函数在两个维度上进行分箱。 geom_bin2d () 和 geom_hex () 函数将坐标平面分为二维分箱，并使用一种填充颜色表示落入每个分箱的数据点。geom_bin2d () 创建长方形分箱。geom_hex () 创建六边形分箱。要想使用 geom_hex ()，需要安装 hexbin 包： ggplot(data &#x3D; smaller) + geom_bin2d(mapping &#x3D; aes(x &#x3D; carat, y &#x3D; price)) ggplot(data = smaller) + geom_hex(mapping = aes(x = carat, y = price)) 另一种方式是对一个连续变量进行分箱，因此这个连续变量的作用就相当于分类变量。接下来就可以使用前面学过的对分类变量和连续变量的组合进行可视化的技术了。例如，你可以对 carat 进行分箱，然后为每个组生成一个箱线图： ggplot(data &#x3D; smaller, mapping &#x3D; aes(x &#x3D; carat, y &#x3D; price)) + geom_boxplot(mapping &#x3D; aes(group &#x3D; cut_width(carat, 0.1))) 以上示例使用了 cut_width (x, width) 函数将 x 变量分成宽度为 width 的分箱。默认情况下，不管其中有多少个观测，箱线图看上去都差不多（除了离群点的数量不同），因此很难分辨出每个箱线图是对不同数量的观测进行摘要统计的。如果想要体现这种信息，可以使用参数 varwidth = TRUE 让箱线图的宽度与观测数量成正比。 另一种方法是近似地显示每个分箱中的数据点的数量，此时可以使用 cut_number () 函数： ggplot(data &#x3D; smaller, mapping &#x3D; aes(x &#x3D; carat, y &#x3D; price)) + geom_boxplot(mapping &#x3D; aes(group &#x3D; cut_number(carat, 20))) # 5.6 模式和模型 数据中的模式提供了关系线索。如果两个变量之间存在系统性的关系，那么这种关系就会 在数据中表现为一种模式。如果发现了模式，需要问自己以下几个问题。 ・这种模式的出现会不会是一种巧合（也就是随机的偶然因素）？ ・应该如何描述这种模式中隐含的关系？ ・这种模式中隐含的关系有多强？ ・其他变量会如何影响这种关系？ ・如果对数据的独立分组进行检查，这种关系会有所变化吗？ 我们就前面提到的美国黄石国家公园中老忠实喷泉的喷发时长和两次喷发之间的等待时间 做出一张散点图，该图会显示出一个模式：较长的等待时间与较长的喷发时间是相关的。 图中还显示出两个簇，这个我们之前就发现了： ggplot(data &#x3D; faithful) + geom_point(mapping &#x3D; aes(x &#x3D; eruptions, y &#x3D; waiting)) 模式是数据科学中最有效的工具之一，因为其可以揭示相关变动。如果说变动会生成不确定性，那么相关变动就是减少不确定性。如果两个变量是共同变化的，就可以使用一个变量的值来更好地预测另一个变量的值。如果相关变动可以归因于一种因果关系（一种特殊情况），那么就可以使用一个变量的值来控制另一个变量的值。 模型是用于从数据中抽取模式的一种工具。例如，我们思考一下钻石数据。切割质量与价格之间的关系是很难理解的，因为切割质量和克拉数以及克拉数和价格之间是紧密相关的。我们可以使用模型去除价格和克拉数之间的强关系，这样就可以继续研究剩余的微妙关系。以下代码拟合了一个模型，可以根据 carat 预测 price，并计算出残差（预测值和实际值之间的差别）。一旦去除克拉数对价格的影响，残差就能反映出钻石的价格： library(modelr)mod &lt;- lm(log(price) ~ log(carat), data &#x3D; diamonds)diamonds2 &lt;- diamonds %&gt;%add_residuals(mod) %&gt;%mutate(resid &#x3D; exp(resid))ggplot(data &#x3D; diamonds2) +geom_point(mapping &#x3D; aes(x &#x3D; carat, y &#x3D; resid)) 去除克拉数和价格之间的强关系后，就可以看到预料中的切割质量与价格的关系，对于同样大小的钻石，切割质量更好的钻石更昂贵： ggplot(data &#x3D; diamonds2) +geom_boxplot(mapping &#x3D; aes(x &#x3D; cut, y &#x3D; resid)) # 5.7 ggplot2 调用 通常情况下，一个函数的前一个或前两个参数是非常重要的，你应该将它们牢记于心。ggplot () 函数的前两个参数是 data 和 mapping，aes () 函数的前两个参数是 x 和 y。在本书剩余的部分中，我们不再写出这些参数名，这样既可以节省输入时间，也可以让代码样板更精简，以便更容易找出两张图之间的不同之处。 ggplot(data &#x3D; faithful, mapping &#x3D; aes(x &#x3D; eruptions)) +geom_freqpoly(binwidth &#x3D; 0.25)ggplot(faithful, aes(eruptions)) +geom_freqpoly(binwidth &#x3D; 0.25)# 第六章：工作流：项目 # 6.1 什么是真实的 作为 R 的一名新手，你可以认为自己的 R 环境（也就是环境窗格中列出的那些对象）是 “真实的”。但从长远来看，你最好认为 R 脚本是 “真实的”。可以通过 R 脚本（以及数据文件）重建 R 环境，但在 R 环境中重建 R 脚本就要困难得多！要么被迫重敲一次内存中的代码（伴随着各种输入错误），要么被迫在 R 历史记录中埋头翻找。为了培养良好的使用习惯，我们强烈建议你指示 RStudio 不在两次会话间保存工作空间。 # 6.2 你的分析位于哪里 R 中有个名为工作目录的重要概念。R 在这个目录中查找你要加载的文件，也将你要保存的文件放在这个目录中。RStudio 在控制台上方显示当前工作目录。 可以通过运行 getwd () 命令在 R 代码中输出这个目录： &gt; getwd()[1] &quot;C:&#x2F;Users&#x2F;zszpc&#x2F;Documents&quot;作为 R 语言新手，你可以使用自己的主目录、文档目录或计算机上其他稀奇古怪的目录作为 R 的工作目录。但既然已经学习了本书的 6 章内容，你也应该掌握一定的知识了。从现在开始，你应该逐渐学会使用目录来组织分析项目，每开始一个项目，就应该将 R 的工作目录设置为与这个项目相关的目录。 还可以使用 R 的命令来设置工作目录，但我们不建议使用这种方法： setwd(&quot;&#x2F;path&#x2F;to&#x2F;my&#x2F;CoolProject&quot;)不要使用这种操作，因为还有更好的方法，可以让你像专家一样管理与 R 相关的工作。 # 6.3 路径与目录 路径与目录稍微有一点复杂，因为路径有 2 种基本风格：Mac/Linux 和 Windows。它们主要有以下 3 种区别。 ・最重要的区别是如何分隔路径中的各个部分。Mac 和 Linux 使用的是斜杠（如 plots/diamonds.pdf），Windows 使用的则是反斜杠（如 plots\\diamonds.pdf）。R 支持任意一种类型（不管你现在使用的是哪种平台），但问题是，反斜杠在 R 中具有特殊意义，因此，如果想要表示路径中的单个反斜杠，你需要输入 2 个反斜杠！这有点令人沮丧，因此我们建议你一直使用 Linux/Mac 风格的斜杠。 ・绝对路径（即不管你的工作目录是什么，都指向一个位置的路径）的形式不同。在 Windows 系统中，绝对路径的开头是驱动器号（如 C:）或两个反斜杠（如 \\servername）；在 Mac/Linux 系统中，绝对路径的开头则是斜杠 “/”（如 /user/hadley）。千万不要在脚本中使用绝对路径，因为不利于分享：没有任何人会和你具有完全相同的目录设置。 ・最后一个小区别是～指向的位置。~ 是指向主目录的一个很方便的快捷方式。Windows 其实没有主目录的概念，因此～指向的是文档目录。","tags":"r_study r_for_data_science"},{"title":"WGCNA学习：WGCNA分析实战","url":"/2020/08/08/2020-08-08-WGCNA3/","text":"WGCNA 笔记第三弹 WGCNA 分析原理 WGCNA 应用场景 WGCNA 分析实践 本代码借鉴了生信技能树的 WGCNA 教程以及 PlanTech 的 WGCNA 课程编写，转载请注明出处 # 1.WGCNA 安装 &gt; install.packages (&quot;BiocManager&quot;)&gt; BiocManager::install (&quot;WGCNA&quot;)&gt; library (WGCNA)载入需要的程辑包：dynamicTreeCut载入需要的程辑包：fastcluster载入程辑包：‘fastcluster’The following object is masked from ‘package:stats’: hclust载入程辑包：‘WGCNA’The following object is masked from ‘package:stats’: cor# 2. 数据准备与读入 # 2.1 数据准备 需要两个数据 表达矩阵（All_fpkm.list） 表型文件（pheno.txt）, 需要注意表型文件分为两类，连续变量型与分类变量型. # 2.2 数据读入 library (WGCNA)library (reshape2)library (stringr)setwd (&#39;D:&#x2F;data&#x2F;wgcna&#x2F;Categorical&#39;)options (stringsAsFactors &#x3D; FALSE)# 在读入数据时，遇到字符串后，不要将其转换成因子，仍然保留为字符串格式enableWGCNAThreads ()# 打开多线程##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step 1 : 数据读入RNAseq_voom &lt;- fpkm## 因为 WGCNA 针对的是基因进行聚类，而一般我们的聚类是针对样本用 hclust 即可，所以这个时候需要转置WGCNA_matrix &#x3D; t (RNAseq_voom [order (apply (RNAseq_voom,1,mad), decreasing &#x3D; T)[1:5000],])datExpr &lt;- WGCNA_matrix ## top 5000 mad genes# 明确样本数和基因nGenes &#x3D; ncol (datExpr)nSamples &#x3D; nrow (datExpr)# 首先针对样本做个系统聚类datExpr_tree&lt;-hclust (dist (datExpr), method &#x3D; &quot;average&quot;)par (mar &#x3D; c (0,5,2,0))png (&quot;img&#x2F;step1-sample-cluster.png&quot;,width &#x3D; 800,height &#x3D; 600)plot (datExpr_tree, main &#x3D; &quot;Sample clustering&quot;, sub&#x3D;&quot;&quot;, xlab&#x3D;&quot;&quot;, cex.lab &#x3D; 2, cex.axis &#x3D; 1, cex.main &#x3D; 1,cex.lab&#x3D;1)dev.off () # 3. β 值估计 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step 2：β 值确定 &#x3D;&#x3D;&#x3D;&#x3D;datExpr [1:4,1:4]powers &#x3D; c (c (1:10), seq (from &#x3D; 12, to&#x3D;20, by&#x3D;2))# 设置 beta 值的取值范围sft &#x3D; pickSoftThreshold (datExpr, RsquaredCut &#x3D; 0.9,powerVector &#x3D; powers, verbose &#x3D; 5)# 设置网络构建参数选择范围，计算无尺度分布拓扑矩阵png (&quot;img&#x2F;step2-beta-value.png&quot;,width &#x3D; 800,height &#x3D; 600)par (mfrow &#x3D; c (1,2));cex1 &#x3D; 0.9;# Scale-free topology fit index as a function of the soft-thresholding powerplot (sft$fitIndices [,1], -sign (sft$fitIndices [,3])*sft$fitIndices [,2], xlab&#x3D;&quot;Soft Threshold (power)&quot;,ylab&#x3D;&quot;Scale Free Topology Model Fit,signed R^2&quot;,type&#x3D;&quot;n&quot;, main &#x3D; paste (&quot;Scale independence&quot;));text (sft$fitIndices [,1], -sign (sft$fitIndices [,3])*sft$fitIndices [,2], labels&#x3D;powers,cex&#x3D;cex1,col&#x3D;&quot;red&quot;);# this line corresponds to using an R^2 cut-off of habline (h&#x3D;0.90,col&#x3D;&quot;red&quot;)# Mean connectivity as a function of the soft-thresholding powerplot (sft$fitIndices [,1], sft$fitIndices [,5], xlab&#x3D;&quot;Soft Threshold (power)&quot;,ylab&#x3D;&quot;Mean Connectivity&quot;, type&#x3D;&quot;n&quot;, main &#x3D; paste (&quot;Mean connectivity&quot;))text (sft$fitIndices [,1], sft$fitIndices [,5], labels&#x3D;powers, cex&#x3D;cex1,col&#x3D;&quot;red&quot;)dev.off () 可以确定最佳 β 值为 6 # 4. 一步法构建共表达矩阵 最核心的一步，同时也是最耗费计算资源的一步 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step 3: 自动构建 WGCNA 模型 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 首先是一步法完成网络构建net &#x3D; blockwiseModules ( datExpr, power &#x3D; sft$powerEstimate, #软阈值，前面计算出来的 maxBlockSize &#x3D; 6000, #最大 block 大小，将所有基因放在一个 block 中 TOMType &#x3D; &quot;unsigned&quot;, #选择 unsigned，使用标准 TOM 矩阵 deepSplit &#x3D; 2, minModuleSize &#x3D; 30, #剪切树参数，deepSplit 取值 0-4 mergeCutHeight &#x3D; 0.25, # 模块合并参数，越大模块越少 numericLabels &#x3D; TRUE, # T 返回数字，F 返回颜色 pamRespectsDendro &#x3D; FALSE, saveTOMs &#x3D; TRUE, saveTOMFileBase &#x3D; &quot;FPKM-TOM&quot;, loadTOMs &#x3D; TRUE, verbose &#x3D; 3)# 5. 模块可视化 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step4: 模块可视化 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# Convert labels to colors for plottingmergedColors &#x3D; labels2colors (net$colors)table (mergedColors)moduleColors&#x3D;mergedColors# Plot the dendrogram and the module colors underneathpng (&quot;img&#x2F;step4-genes-modules.png&quot;,width &#x3D; 800,height &#x3D; 600)plotDendroAndColors (net$dendrograms [[1]], mergedColors [net$blockGenes [[1]]], &quot;Module colors&quot;, dendroLabels &#x3D; FALSE, hang &#x3D; 0.03, addGuide &#x3D; TRUE, guideHang &#x3D; 0.05)dev.off ()## assign all of the gene to their corresponding module## hclust for the genes.# 明确样本数和基因nGenes &#x3D; ncol (datExpr)nSamples &#x3D; nrow (datExpr)# 首先针对样本做个系统聚类datExpr_tree&lt;-hclust (dist (datExpr), method &#x3D; &quot;average&quot;)par (mar &#x3D; c (0,5,2,0))plot (datExpr_tree, main &#x3D; &quot;Sample clustering&quot;, sub&#x3D;&quot;&quot;, xlab&#x3D;&quot;&quot;, cex.lab &#x3D; 2, cex.axis &#x3D; 1, cex.main &#x3D; 1,cex.lab&#x3D;1)## 如果这个时候样本是有性状，或者临床表型的，可以加进去看看是否聚类合理# 针对前面构造的样品矩阵添加对应颜色sample_colors &lt;- numbers2colors (as.numeric (factor (datTraits$subtype)), colors &#x3D; c (&quot;white&quot;,&quot;blue&quot;,&quot;red&quot;,&quot;green&quot;),signed &#x3D; FALSE)## 这个给样品添加对应颜色的代码需要自行修改以适应自己的数据分析项目# sample_colors &lt;- numbers2colors ( datTraits ,signed &#x3D; FALSE)## 如果样品有多种分类情况，而且 datTraits 里面都是分类信息，那么可以直接用上面代码，当然，这样给的颜色不明显，意义不大#10 个样品的系统聚类树及性状热图par (mar &#x3D; c (1,4,3,1),cex&#x3D;0.8)png (&quot;img&#x2F;sample-subtype-cluster.png&quot;,width &#x3D; 800,height &#x3D; 600)plotDendroAndColors (datExpr_tree, sample_colors, groupLabels &#x3D; colnames (sample), cex.dendroLabels &#x3D; 0.8, marAll &#x3D; c (1, 4, 3, 1), cex.rowText &#x3D; 0.01, main &#x3D; &quot;Sample dendrogram and trait heatmap&quot;)dev.off ()可以看到模块用不同的颜色来标注，灰色模块是无法归类于任何模块的基因，在后续分析的时候不需要考虑 # 6. 模块与性状的关系 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step5: 模块与性状的关系 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;table (datTraits$subtype)nGenes &#x3D; ncol (datExpr)nSamples &#x3D; nrow (datExpr)design&#x3D;model.matrix (~0+ datTraits$subtype)colnames (design)&#x3D;levels (datTraits$subtype)moduleColors &lt;- labels2colors (net$colors)# Recalculate MEs with color labelsMEs0 &#x3D; moduleEigengenes (datExpr, moduleColors)$eigengenesMEs &#x3D; orderMEs (MEs0); ## 不同颜色的模块的 ME 值矩 (样本 vs 模块)# 输出每个基因所在的模块，以及与该模块的 KME 值file.remove (&#39;All_Gene_KME.txt&#39;)for (module in substring (colnames (MEs),3))&#123; if (module &#x3D;&#x3D; &quot;grey&quot;) next ME&#x3D;as.data.frame (MEs [,paste (&quot;ME&quot;,module,sep&#x3D;&quot;&quot;)]) colnames (ME)&#x3D;module datModExpr&#x3D;datExpr [,moduleColors&#x3D;&#x3D;module] datKME &#x3D; signedKME (datModExpr, ME) datKME&#x3D;cbind (datKME,rep (module,length (datKME))) write.table (datKME,quote &#x3D; F,row.names &#x3D; T,append &#x3D; T,file &#x3D; &quot;All_Gene_KME.txt&quot;,col.names &#x3D; F)&#125;moduleTraitCor &#x3D; cor (MEs, design , use &#x3D; &quot;p&quot;);moduleTraitPvalue &#x3D; corPvalueStudent (moduleTraitCor, nSamples)sizeGrWindow (10,6)# Will display correlations and their p-valuestextMatrix &#x3D; paste (signif (moduleTraitCor, 2), &quot;\\n (&quot;, signif (moduleTraitPvalue, 1), &quot;)&quot;, sep &#x3D; &quot;&quot;);dim (textMatrix) &#x3D; dim (moduleTraitCor)png (&quot;img&#x2F;step5-Module-trait-relationships.png&quot;,width &#x3D; 800,height &#x3D; 600)par (mar &#x3D; c (6, 8.5, 3, 3));# Display the correlation values within a heatmap plotlabeledHeatmap (Matrix &#x3D; moduleTraitCor, xLabels &#x3D; colnames (design), yLabels &#x3D; names (MEs), ySymbols &#x3D; names (MEs), colorLabels &#x3D; FALSE, colors &#x3D; blueWhiteRed (50), textMatrix &#x3D; textMatrix, setStdMargins &#x3D; FALSE, cex.text &#x3D; 0.5, zlim &#x3D; c (-1,1), main &#x3D; paste (&quot;Module-trait relationships&quot;))dev.off ()# 绘制两两模块间的邻接矩阵png (&quot;img&#x2F;wgcna.adjacency.heatmap.pdf&quot;,height &#x3D; 800,width &#x3D; 600)plotEigengeneNetworks (MEs, &quot;Eigengene adjacency heatmap&quot;,plotDendrograms &#x3D; F, marDendro &#x3D; c (4,4,2,4))dev.off ()可以看到不同的模块与不同的性状是有不同的相关性的，在后续分析的时候我们可以选择感兴趣的模块进行分析。 两两模块之间的邻接矩阵，主要看不同模块之间的相关性 # 7. 选择感兴趣的模块进行分析 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step 6：感兴趣性状的模块的具体基因分析 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 查看第五步出图：step5-Module-trait-relationships.png# 发现跟 Luminal 亚型 最相关的是 pink 模块# 所以接下来就分析这两个Luminal &#x3D; as.data.frame (design [,3])names (Luminal) &#x3D; &quot;Luminal&quot;module &#x3D; &quot;pink&quot;# names (colors) of the modulesmodNames &#x3D; substring (names (MEs), 3)geneModuleMembership &#x3D; as.data.frame (cor (datExpr, MEs, use &#x3D; &quot;p&quot;))## 算出每个模块跟基因的皮尔森相关系数矩阵## MEs 是每个模块在每个样本里面的## datExpr 是每个基因在每个样本的表达量MMPvalue &#x3D; as.data.frame (corPvalueStudent (as.matrix (geneModuleMembership), nSamples))names (geneModuleMembership) &#x3D; paste (&quot;MM&quot;, modNames, sep&#x3D;&quot;&quot;)names (MMPvalue) &#x3D; paste (&quot;p.MM&quot;, modNames, sep&#x3D;&quot;&quot;)geneModuleMembership [1:4,1:4]## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量 0,1 进行数值化Luminal &#x3D; as.data.frame (design [,3])names (Luminal) &#x3D; &quot;Luminal&quot;geneTraitSignificance &#x3D; as.data.frame (cor (datExpr, Luminal, use &#x3D; &quot;p&quot;))GSPvalue &#x3D; as.data.frame (corPvalueStudent (as.matrix (geneTraitSignificance), nSamples))names (geneTraitSignificance) &#x3D; paste (&quot;GS.&quot;, names (Luminal), sep&#x3D;&quot;&quot;)names (GSPvalue) &#x3D; paste (&quot;p.GS.&quot;, names (Luminal), sep&#x3D;&quot;&quot;)module &#x3D; &quot;pink&quot;column &#x3D; match (module, modNames)moduleGenes &#x3D; moduleColors&#x3D;&#x3D;modulepng (&quot;step6-Module_membership-gene_significance.png&quot;,width &#x3D; 800,height &#x3D; 600)#sizeGrWindow (7, 7)par (mfrow &#x3D; c (1,1))verboseScatterplot (abs (geneModuleMembership [moduleGenes, column]), abs (geneTraitSignificance [moduleGenes, 1]), xlab &#x3D; paste (&quot;Module Membership in&quot;, module, &quot;module&quot;), ylab &#x3D; &quot;Gene significance for Luminal&quot;, main &#x3D; paste (&quot;Module membership vs. gene significance\\n&quot;), cex.main &#x3D; 1.2, cex.lab &#x3D; 1.2, cex.axis &#x3D; 1.2, col &#x3D;module)dev.off ()由于是分类变量，只能按照 0 至 1 量化，可以看出模块内的基因与表型有很好的线性关系 然后再绘制性状与模块的关系 # Recalculate module eigengenesMEs &#x3D; moduleEigengenes (datExpr, moduleColors)$eigengenes## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量 0,1 进行数值化Luminal &#x3D; as.data.frame (design [,3]);names (Luminal) &#x3D; &quot;Luminal&quot;# Add the weight to existing module eigengenesMET &#x3D; orderMEs (cbind (MEs, Luminal))# Plot the relationships among the eigengenes and the traitsizeGrWindow (5,7.5);par (cex &#x3D; 0.9)png (&quot;img&#x2F;step6-Eigengene-dendrogram.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;&quot;, marDendro &#x3D; c (0,4,1,2), marHeatmap &#x3D; c (3,4,1,2), cex.lab &#x3D; 0.8, xLabelsAngle &#x3D; 90)dev.off ()# Plot the dendrogramsizeGrWindow (6,6);par (cex &#x3D; 1.0)## 模块的进化树png (&quot;img&#x2F;step6-Eigengene-dendrogram-hclust.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;Eigengene dendrogram&quot;, marDendro &#x3D; c (0,4,2,0), plotHeatmaps &#x3D; FALSE)dev.off ()# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)par (cex &#x3D; 1.0)## 性状与模块热png (&quot;img&#x2F;step6-Eigengene-adjacency-heatmap.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;Eigengene adjacency heatmap&quot;, marHeatmap &#x3D; c (3,4,2,2), plotDendrograms &#x3D; FALSE, xLabelsAngle &#x3D; 90)dev.off ()# Recalculate module eigengenesMEs &#x3D; moduleEigengenes (datExpr, moduleColors)$eigengenes## 只有连续型性状才能只有计算## 这里把是否属 Luminal 表型这个变量 0,1 进行数值化Luminal &#x3D; as.data.frame (design [,3]);names (Luminal) &#x3D; &quot;Luminal&quot;# Add the weight to existing module eigengenesMET &#x3D; orderMEs (cbind (MEs, Luminal))# Plot the relationships among the eigengenes and the traitsizeGrWindow (5,7.5);par (cex &#x3D; 0.9)png (&quot;img&#x2F;step6-Eigengene-dendrogram.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;&quot;, marDendro &#x3D; c (0,4,1,2), marHeatmap &#x3D; c (3,4,1,2), cex.lab &#x3D; 0.8, xLabelsAngle &#x3D; 90)dev.off ()# Plot the dendrogramsizeGrWindow (6,6);par (cex &#x3D; 1.0)## 模块的进化树png (&quot;img&#x2F;step6-Eigengene-dendrogram-hclust.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;Eigengene dendrogram&quot;, marDendro &#x3D; c (0,4,2,0), plotHeatmaps &#x3D; FALSE)dev.off ()# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)par (cex &#x3D; 1.0)## 性状与模块热png (&quot;img&#x2F;step6-Eigengene-adjacency-heatmap.png&quot;,width &#x3D; 800,height &#x3D; 600)plotEigengeneNetworks (MET, &quot;Eigengene adjacency heatmap&quot;, marHeatmap &#x3D; c (3,4,2,2), plotDendrograms &#x3D; FALSE, xLabelsAngle &#x3D; 90)dev.off () # 8. 网络的可视化 # 主要是可视化 TOM 矩阵，WGCNA 的标准配图# 然后可视化不同 模块 的相关性 热图# 不同模块的层次聚类图# 还有模块诊断，主要是 intramodular connectivitynGenes &#x3D; ncol (datExpr)nSamples &#x3D; nrow (datExpr)geneTree &#x3D; net$dendrograms [[1]];dissTOM &#x3D; 1-TOMsimilarityFromExpr (datExpr, power &#x3D; 6);plotTOM &#x3D; dissTOM^7;diag (plotTOM) &#x3D; NA;#TOMplot (plotTOM, geneTree, moduleColors, main &#x3D; &quot;Network heatmap plot, all genes&quot;)nSelect &#x3D; 400# For reproducibility, we set the random seedset.seed (10);select &#x3D; sample (nGenes, size &#x3D; nSelect);selectTOM &#x3D; dissTOM [select, select];# There’s no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.selectTree &#x3D; hclust (as.dist (selectTOM), method &#x3D; &quot;average&quot;)selectColors &#x3D; moduleColors [select];# Open a graphical windowsizeGrWindow (9,9)# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing# the color palette; setting the diagonal to NA also improves the clarity of the plotplotDiss &#x3D; selectTOM^7;diag (plotDiss) &#x3D; NA;png (&quot;img&#x2F;step7-Network-heatmap.png&quot;,width &#x3D; 800,height &#x3D; 600) TOMplot (plotDiss, selectTree, selectColors, main &#x3D; &quot;Network heatmap plot, selected genes&quot;)dev.off ()不知道为啥，这张图有点奇怪 # 9. 模块的导出 ##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;step 8：模块导出 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 导出模块内部基因的连接关系，进入其它可视化软件# 比如 cytoscape 软件等等。# Recalculate topological overlapTOM &#x3D; TOMsimilarityFromExpr (datExpr, power &#x3D; 6);# Select modulemodule &#x3D; &quot;pink&quot;;# Select module probesprobes &#x3D; colnames (datExpr) ## 我们例子里面的 probe 就是基因inModule &#x3D; (moduleColors&#x3D;&#x3D;module)modProbes &#x3D; probes [inModule]## 也是提取指定模块的基因名# Select the corresponding Topological OverlapmodTOM &#x3D; TOM [inModule, inModule]dimnames (modTOM) &#x3D; list (modProbes, modProbes)## 模块对应的基因关系矩cyt &#x3D; exportNetworkToCytoscape ( modTOM, edgeFile &#x3D; paste (&quot;CytoscapeInput-edges-&quot;, paste (module, collapse&#x3D;&quot;-&quot;), &quot;.txt&quot;, sep&#x3D;&quot;&quot;), nodeFile &#x3D; paste (&quot;CytoscapeInput-nodes-&quot;, paste (module, collapse&#x3D;&quot;-&quot;), &quot;.txt&quot;, sep&#x3D;&quot;&quot;), weighted &#x3D; TRUE, threshold &#x3D; 0.02, nodeNames &#x3D; modProbes, nodeAttr &#x3D; moduleColors [inModule])模块导出后可以用 cytoscape 构建网络，后面的教程会教大家利用这个文件构建网络图 # 后记 本次 WGCNA 的代码结合了生信技能树和 PlantTech 的 WGCNA 教程，原始数据也来自这两个教程，我将代码和原始数据上传到自己的 github 中，其中 PlantTech 课程是收费课程，我已将其下载，大家有需要可以去百度云下载（提取码：es41） 视频压缩包解压密码是我博客 about 界面下的一行小字（出自《蒲公英女孩》，标点是英文），如果链接炸了去博客找我联系方式。","tags":"bioinformatics wgcna"},{"title":"WGCNA学习：WGCNA应用场景与实例解读","url":"/2020/08/05/2020-08-05-WGCNA2/","text":"WGCNA 笔记第二弹 WGCNA 分析原理 WGCNA 应用场景 WGCNA 分析实践 # 1.WGCNA 应用场景 不同组织样品 时间序列样品：生长发育，胁迫处理 单个材料：相同处理不同时间，不同处理相同时间，不同处理不同时间 两个材料：相同处理不同时间，不同处理相同时间，不同处理不同时间 表型数据：同级相关表型的数据 # 2.WGCNA 实验设计 1. 时间序列样品，两个材料相同处理，可以一起做 WGCNA 分析，也可以分别做然后比较，相同材料不同处理之间也一样 2. 同一物种，不同来源的转录组数据，可以放在一起做 WGCNA，也可以分开来比较 3. 一般建议 15 个样品以上进行 WGCNA 分析有生物学意义，可以使 5 个时间点三个重复的 15 个样品 4. 表型数据，建议收集可以统计量化的性状数据，可将模块和表型数据关联分析，有助于筛选关键基因模块和基因来解释相关表型 # 3. 单个材料案例 Floral Transcriptomes in Woodland Strawberry Uncover Developing Receptacle and Anther Gene Networks 野草莓花器官转录组解析花发育中花托和花药的基因调控网络 # 3.1 方案设计 单个材料不同组织样品 取材野草莓花器官不同组织 从不同发育时期的花器官分离花药、花粉、心皮、花托等组织，再加上小苗叶片，共 17 个组织。每个组织两个重复，共 34 个样本。 # 3.2 转录组数据整体分析 # 3.2 鉴定配子体孢子体相关基因 在不同发育时期花药中共同表达的基因鉴定为雄性孢子体特异性基因 GO 富集显示，雄性孢子基因集主要为代谢生物学过程，如小分子、有机酸、细胞内酮代谢等等 在花粉和小孢子特异表达的基因中共同表达的基因鉴定为配子体特异基因 # 3.3 花发育过程转录组的时空表达模式分析 对所有差异表达的基因进行 K-means 聚类分析鉴定 19 个 cluster，呈现出发育时期和组织特异性表达模式，如 C1 C22 为心皮特异性 进一步将 19 个 cluster 合并为 10 个 supercluster，并进行功能富集分析，如心皮特异性的 supercluster，并进行功能富集分析。如心皮特异性的 supercluster1 富集的功能为 DNA 合成。 对 cluster 中的 161 个转录因子进行表达量聚类分析，也呈现发育时期和组织特异性的表达模式。 # 3.4 WGCNA 构建共表达网络 用差异表达基因进行 WGCNA 分析，鉴定了 23 个基因模块。 用每个模块的 epigengene 值与不同组织样品进行关联分析，鉴定组织紧密关联的基因模块。 12 个模块与单一的组织样品特异性高度相关，如 blue 模块与花粉（pollen）特异性相关。 WGCNA 鉴定的组织特异性基因集合与 K-means 的结果相符合 WGCNA 鉴定的花托特异性模块（light yellow）和幼嫩花（stage1-4）特异性模块（dark red），在 K-means 的 cluster 中并没有 # 3.5 组织特异性表达模块 WGCNA 鉴定的花托特异性模块（light yellow）和幼嫩花（stage1-4）特异性模块，在 K-means 的 cluster 中并没有。 分析了 Dark red 模块和 Light yellow 模块 epigengene 在各样品中的表达模式 热图呈现了 Dark red 模块和 Light yellow 模块中每个基因在各个样品中的表达模式 # 3.6 花托特异性模块内部分析 关键基因（hub gene）：模块内网络中连接度较多的基因。 关注模块中的转录因子：花托特异性模块 111 个基因中有 27 个转录因子，重点分析这些转录因子。 大部分 hub gene 为参与调控分生组织的转录因子，如 WOX、GRS、NAC 等。 hub gene 中连接度最高的为 GRS 转录因子家族的 FveLOM3。拟南芥中三突变体 lom1 lom2 lom3 表现出分生组织异常的表型。因此 FveLOM3 可能是花托发育的关键调控因子。 此外，高连接度的 hub gene 还包括一个 B3 domain 转录因子、一个 Myb 转录因子和 WUS 同源基因 # 3.7 花药发育差异基因分析 stage9 花药中上调表达的 1453 个基因中，211 个编码 FBX domain 蛋白。在野草莓基因组中包含 820 个 FBX 基因。大比例 FBX 上调表达说明在花药减数分裂这个时期发生了大量的蛋白降解。 K-means 的 cluster 富集分析中花药 - 9 的 cluster 富集的为蛋白降解。 FBX 基因表达聚类热图分析显示，大部分 FBX 只在 stage9 时期暂时高表达，随后的 stage10 和 11 下调表达。 在花药发育过程中，共 296 个 FBX 基因差异表达，其中 6 个亚家族占的比例较大，包括 FBD、LRR、DUF295 # 3.8 花药特异性模块分析 花药 stage9 特异性基因模块为 pink，其中包含了 37 个 FBX 基因。 通过筛选连接度较高的基因来鉴定 hub gene。5 个基因的度数目高于 200。 其中 4 个基因参与蛋白降解，F-box、WD-repeat # 3.8 小结：WGCNA 分析思路 实验方案：单个材料，不同组织样品，所有差异表达基因进行 WGCNA 分析 通过模块 Epigengene 值与不同组织样本进行关联分析，鉴定组织特异性模块 hub 基因筛选 连接度较高的基因 重点关注转录因子（花托特异性模块） 前期结果中的目标基因（话要特异性模块中的 FBX） # 4. 两个材料 Global transcriptome and coexpression network analyses reveal cultivara specific molecular signatures associated with seed development and seed size/weight determination in chickpea # 4.1 方案设计 # 4.2 两个鹰嘴豆栽培种的种子发育表性分析 两个鹰嘴豆栽培种 Himchana1 (小种子，平均 100 粒种子重量为 13.1g) 和 JGK3 (大 种子，平均 100 粒种子重量为 53.3g). 种子发育的 7 个时间段（S1-S7), 分别代表了种子发育的三个阶段：胚芽发育（S1-S3)、早期和中期成熟阶段（籽粒灌浆，S4-S5)、成熟晚期（种子干燥，S6-S7) 种子的不同发育阶段 S1-S7 依据授粉天数（Day after Pollination,DAP) 划分，5、9.12,19,25、30 和 40 DAP 分别为 S1、S2、S3.S4、S5、S6 和 S7. 表型分析：种子发育不同时间点的种子重量和大小的统计数据比较。 # 4.3 两个材料种子发育过程转录组的整体解析 为了分析两个材料种子发育过程转录组动态变化的差异，基于 16 个组织样品所有表达基因的表达量的斯皮尔曼相关系数（SCC）进行层次聚类和主成分分析（PCA）。 两个材料中相同发育时期组织样品表现出很高的相关性。 两个材料叶片聚在一起，与所有种子样品表现出明显差异。 两个材料的 S3 有差异，JGK3-S3 与 S2 更接近，而 HC1-S3 与 S4 更像。这说明 HC1 在种子发育早期比 JGK3 生长发育得更快。 虽然两个材料 S5 也聚类在一起，但是关系并没有其他时期的紧密，也呈现一定的差异。 因此，S3 和 S5 可能是两个材料种子大小和重量差异的关键发育时期 # 4.4 种子发育过程中差异基因表达分析 鉴定种子发育过程中每个时期特异表达的基因 各个时期特异表达的基因数目差异很大，S2 最少，S5 最多。 两个材料中各自时期特异表达的基因数目也有所不同，HC1 在 S2 最少，JGK3 则在 S6 最少，但是两者在 S5 都是最多的。 两个材料中均时期特异表达的基因比例也不小，表达量层次聚类分析呈现出明显的发育时期特异性。 说明每个发育阶段有着自己独立的发育程序。 Go 富集分析，主要为生殖过程、细胞壁组装、细胞周期和细胞分裂、碳代谢等，这些都是已知参与种子发育的。 有些 GOterm 在两个材料中均富集，有些只在一个材料中富集。 # 4.5 两个材料差异表达基因分析 定两个材料在种子发育每个时期的显著差异表达基因集。 HC1 VS JGK3, 共有 8562 个基因上调表达，9023 个下调表达。 差异基因数目最多的是 S7，其次为 S3；最少的为 S4。 重点分析了 TF，许多 TF 家族在 JGK3 中显著上调或下调模式。 GO 富集显示，在 JGK3 中上调表达基因主要富集在一些细胞分裂相关 term 中，尤其在 S3 中。 代谢通路注释分析显示，在 S3 时期某些代谢通路呈现显著的差异。 在 JGK3 中淀粉代谢和光合作用相关基因激活表达，细胞周期和细胞分裂相关基因也上调表达。 在 S3 时期 JGK3 中细胞壁合成和修饰的许多基因上调表达。 # 4.6 WGCNA 鉴定共表达基因模块 WGCNA 分别鉴定了 HC1 的 27 个基因模块和 JGK3 的 21 个基因模块。 所有模块中都包含 TF，数量从几个到几百个不等。 模块和发育时期样品关联分析（PCC），13 个 HC1 模块和 6 个 JGK3 模块与发育时期样品高度关联（0.6 以上）。 许多模块不仅与一个发育时期关联，一些模块仅与某个特定发育时期样品关联。如 JGK 3 的 lightyellow 模块与 S4 高度特异关联（0.93）. 模块的 GO 富集分析结果与差异表达基因分析结果相一致。如，种子发育早期相关模块主要富集的 GO term 为细胞分离、细胞形态、细胞壁组装、基因表达调控。 # 4.7 两个材料的基因模块保守性分析 鉴定两个材料共表达基因模块的保守性。 计算不同模块中的相同基因数目，然后通过 Fisher 精确检验的 P-value 值评估显著性。 两个材料中大部分保守模块关联的是相似的种子发育时期样品。 少部分保守模块在不同材料中表型不同的发育时期关联性和转录激活时期。 鉴定了材料特异性模块，如 HC1 的 3 个模块（organe-HS4 等）和 4 个 JGK3 模块（如 lightgreen-JS4）。 HC1 特异性模块主要富集 GO term 为转录调控、细胞程序性死亡、衰老等；JGK3 特异性模块富集的为 DNA 复制、细胞分裂、基因表达、蛋白修饰等。 # 4.8 种子发育和种子大小、重量相关转录调控模块分析 目的：鉴定 JGK3 发育 S3 和 S5 的转录调控网络。主要为 TFs 及其共表达的靶基因（包含 TFs 结合位点，motif 显著富集分析） 候选模块：HC1 和 JGK3 中与 S3、S5 时期相关的共表达基因模块 JGK3 的 S3 时期相关模块 brown 转录调控网络：显著富集的 DNA motifs 有 ATHB1、JASE1 等，相关的 TFs 有 woX9、PDF2、RLT2 等，以及靶基因相关的 GO term，基因表达调控、细胞壁组装、表达大小调控等。 比较 JS3 和 HS3 模块转录调控网络，大部分组分是相同的，但是也有一些材料特异性的组分。 同样也分析了 JS5 和 HS5 相关模块转录调控网络组分，包括 DNA motifs、TFs，以及 GO term。 JS5 和 HS5 的调控网络大部分组分是相同的，但是也有一些材料特异性的组分。 该分析鉴定了种子发育中的关键调控因子，两个材料的调控相似但不完全一样。 # 4.9 种子发育和种子大小、重量相关转录调控模块分析 一些基因模块在两个材料的 S3 和 S5 时期表现出相反表达模式。 主要有 3 类：HS3 下调 JS3 上调，HS3 上调 JS3 下调，HS5 下调 JS5 上调。 这些模块可能与两个材料种子发育不同相关，进行转录调控网络分析。 HJ3 上调 JS3 下调转录调控网络鉴定：motifs、TF、GOterms。 S3 时期的 top hub 基因表达模式反应了这不同模块中所有基因的表达模式。 这些网络中的许多 motifs、TFs 都是已知参与调控种子大小、重量的重要调控因子。 # 4.10 小结 实验方案：两个材料，不同发育时期样品，所有差异表达基因进行 WGCNA 分析。 两个材料分别进行 WGCNA 分析鉴定各自的基因模块。 通过模块 Epigengene 值与不同发育时期样品进行关联分析，鉴定时期特异性模块，并通过模块 GO 功能富集来解析各发育时期的调控机制。 两个材料模块保守性分析，鉴定保守性和特异性模块，通过 Go 富集解析各自表型。 模块筛选： 依据前面研究结果 S3 和 S5 两个材料差异最大，重点分析这两个时期相关的基因模块。 依据表达模式筛选在两个材料的 S3 和 S5 时期表现出相反表达模式的模块。 转录调控网络关键基因筛选：TFs 和包含显著富集 motifs 的靶基因、top 20/40 hub gene。 # 5. 表型数据 Root Cell-Specific Regulators of Phosphate-Dependent Growth # 5.1 PRCE 在根部的细胞特异性表达验证和 T-DNA 插入突变体筛选 构建了 12 个 PRCE 基因的启动子 - GFP 转基因 line，验证它们是否呈现细胞特异性表达模式。 其中 10 个基因表现出严格的细胞类型特异性表达模式（皮层、中柱鞘、中柱、木质部薄壁细胞等）。 筛选鉴定了 11 个 PRCE 基因的 T-DNA 插入纯合突变体，其中 10 个为功能缺失突变体，1 个为功能获得型突变体。 # 5.2 突变体表型分析 prce 突变体在磷足够和缺乏条件下，植物根和芽中磷的浓度变化。 prce 突变体在磷足够和缺乏条件下，植物生长情况，根和芽中生物量的变化。 大部分 prce 突变体表现出明显不同于野生型（Col-0) 的特征，包括所有定量的生理表型。 # 5.3 prce 突变体根中相应基因的转录水平变化 选取以前发表文献中的缺磷的两个转录组数据集，包含不同的基因型材料，其中 Col-0 和 phr1-1 为对照材料。 在两个数据集中，Col-0 的 63% 和 6% 的 PSR 基因在 phr1-1 中没有变化；许多野生型 PSR 基因在 prce 突变体中呈现出不同的表达。 在两个数据集中筛选了 Col-0 中差异表达 2 倍以上的 831 个磷响应核心基因，进步通过层次聚类分析其在不同基因型材料中的表达模式。并依据基因表达模式分析不同基因型样品之间的关系。 S6k2 突变体表现出与 phr1-1 类似的缺磷反应，而 wdd1 突变体表现出类似 Col-0 的缺磷反应。 # 5.4 鉴定 prce 突变体相关共表达网络 对 32 个 RNA-seq 数据集（磷足够和磷缺乏）的所有表达转录本分别进行 WGCNA 分析，都鉴定了 18 个共表达基因模块。 计算模块的特征值（Eigengene)，并通过特征值来计算模块和生理性状（数量性状，如磷含量和浓度、生物量、根相对生长速率、初根根长等) 的相关性。 重点关注与性状显著相关的 10 个模块，以及在不同基因型中呈现相反表达模式的模块。 缺磷时，yellowf 和 red 模块与生物量显著正相关；磷充足时，black 模块与生物量显著负相关。 与生物量呈现相反关联的还有缺磷的 green 模块和磷足够的 pink 模块。 # 5.5 重点模块和模块内 hub 基因分析 缺磷的 yellow 模块，包含 684 个基因，与生物量、磷含量、根芽比例都显著相关。其中 24% 基因与之前转录组鉴定的 PSI 基因相一致。 模块基因，相对野生型，在 phr1-1 中下调表达，在 prce 突变体（cb/1、prce2 等）上调表达。 筛选与该模块的 ME（kME) 排在前 300 的基因进行富集分析，显著富集的 GO term 有缺磷相关、磷脂和半乳糖脂代谢等。 模块 hub gene 筛选：kME 大于 0.9。主要为脂代谢、感知磷、磷信号导、磷运输等相关基因。 Yellow 模块在 cb/1 中表现较高的 ME 值，说明钙信号通过 CBL1 影响磷转运。进一步筛选该模块中钙信号相关基因，重点关注，作为 hub gene 候选。 # 5.6 小结 实验方案：两种处理，不同基因型样品，所有表达基因进行 WGCNA 分析。 两种处理分别进行 WGCNA 分析鉴定各自的基因模块。 模块筛选： 通过模块 Epigengene 值与不同表型（数量性状）进行关联分析，筛选性状相关模块；筛选在缺磷和磷足够条件下与表型呈现相反关联的模块。 模块功能分析：GO 功能富集分析。 模块 hub gene 筛选： 与模块的 kME 值大于 0.9；分析模块特征值在各基因型样品中表达模式，筛选关联高的突变体，重点关注突变基因及相关通路基因。","tags":"bioinformatics wgcna"},{"title":"WGCNA学习：WGCNA分析原理","url":"/2020/08/03/2020-08-03-WGCNA1/","text":"本教程根据 PlantTech 的 WGCNA 课程编写，课程还是不错的，所以将该课程给大家分享一下。 WGCNA 笔记第一弹 WGCNA 分析原理 WGCNA 应用场景 WGCNA 分析实践 # 1.WGCNA 简介 WGCNA (Weighted Gene Co-Expression Network Analysis, 加权基因共表达网络分析)，鉴定表达模式相似的基因集合（module）。解析基因集合与样品表型之间的联系，绘制基因集合中基因之间的调控网络并鉴定关键调控基因。 WGCNA 适合于复杂的转录组数据 研究不同器官 / 组织类型和不同阶段的发育调控、生物和非生物胁迫的不同时间点响应机制 # 2. 主要内容 一、WGCNA 原理 1. 构建基因关系网络 2. 构建基因模块 3. 筛选关键基因 4. 鉴定关键基因 二、WGCNA 应用 1. 应用场景 - 实验设计、经典文献 2. 实例分析 - 单个材料、两个材料 3. 实例分析 - 结合表型 三、WGCNA 实战 # 3.WGCNA 原理 # 4. 构建基因关系网络 # 4.1 计算基因间相关关系 基因间相似性（similarity）：根据基因在不同样品中的表达情况，计算任意两个基因间的相关关系。用 Pearson 相关系数 基因共表达矩阵： S=[Sij] Sij 表示基因 i 和基因 j 的 Pearson 相关系数。 软阈值：通过加权函数将相关系数变换，形成邻接矩阵（Adjacency Matrix）, 矩阵中元素连续化。 邻接函数：power 函数（幂指数函数） aij=power(Sij, β)=|Sij|β 需要确定邻接函数的参数 β，依据无尺度网络原则，即基因表达网络符合无尺度网络的幂函数分布 # 4.2 无尺度网络 网络图的点指图中的每一个节点，度指与该点的连接数 随机网络（Random network），每个节点的度相对平均 无尺度网络（Scale-free network），少数节点具有明显高于一般点的度，这些点被称为 hub，由少数 hub 与其他节点关联，最终构成整个网络 无尺度网络的幂率分布：节点连接数为 k 的节点数 h，k 与 h 成反比，负相关 尺度：随机网络中每个节点的连接数符合泊松分布，大部分节点的连接数居中，中值称为随机网络的尺度。 无尺度网络符合幂率分布，大多数点只有很少的连接，少数点有很多的连接 基因相关关系，幂函数处理后，少数强相关性不受影响或者影响较小，而相关性弱的取 n 次幂后，相关性明显下降。 # 4.3 确定关键参数 β 寻找合适的 β，使得基因表达关系符合无尺度网络，度数高的节点少，度数低的节点多。 节点度数 k 与具有该度数节点的个数 h 服从幂律分布 具体计算度数为 k 的节点个数的对数值 log（k），与该节点出现的概率对数（log (p (k))）呈现负相关，一般会设置相关系数大于 0.8 为了检测设置的参数 β 是否满足无尺度网络，对 log10 (p (k)) 和 log10 (k) 作图，同时为更好评估，对两者之间的相关系数做平方，即 R2。如果模型 R2 接近 1，则两者之间为很好的线性关系。 # 4.4 计算基因间表达关系 评估基因间表达关系：直接关系 生物体内基因间的关系：直接关系 + 间接关系 TOM：用拓扑重叠（topological overlap measure，TOM）来计算基因之间关联程度，除了分析两个基因之间的关系，还考虑这两个基因与其他基因之间的连接。这样更具有生物学意义。 建立 TOM 矩阵 $$（TOM）\\Omega=[\\omega_{ij}]=[TOM_{ij}]$$ TOMij=∑μaiμaμj+aijmin(ki,kj)+1−aijTOM_{ij}=\\frac{\\sum_{\\mu}a_{i\\mu}a_{\\mu j}+a_{ij}}{min(k_i,k_j)+1-a_{ij}} TOMij​=min(ki​,kj​)+1−aij​∑μ​aiμ​aμj​+aij​​ TOM 公式中，计算 i 与 j 之间的关系，不仅考虑了 i 和 j 的直接关系，还考虑了第三个基因 μ 的间接关系 # 5 构建基因模块 # 5.1 层次聚类树 基因模块的划分基于基因间的连接稀疏性，将 TOM 矩阵（Similarity）转化为相异度矩阵（Dissimilarity）:$$d^\\omega_{ij}=1-\\omega_{ij}$$ 利用基于 TOM 值的相异度 $$d^\\omega_{ij}$$ 层次聚类建树 建树方法：动态剪切树和静态剪切树 # 5.2 动态混合剪切法 第一步：识别满足设定条件的初级模块 1. 满足模块预定义的最低基因数目 2. 距离集群过远的基因，即使与集群处于同一分支，也去除 3. 每个集群与其他周围的集群显著不同 4. 处在树分支尖端的每个群集的核心基因紧密相连 第二步：测试步骤 将未分配的基因进行测试，如果足够接近某个初级群集，则分配进去 通常 WGCNA 使用动态混合剪切法建树 # 5.3 建树过程的参数 模块最少基因数目（minModuleSize） 合并模块的最小距离（mincutHeight）计算模块的特征值，利用模块特征值建树，合并距离很近的模块（如 Height 小于 0.2） 模块特征值（Epigengene） 模块内所有基因进行主成分分析（PCA），第一主成分的值即为 Epigengene。它代表该模块内基因表达的整体水平 # 6 筛选基因模块 主要介绍四种方法 # 6.1 表达模式分析 模块表达模式分析：模块在各个样品中的丰度 模块特征值（Epigengene）：模块内所有基因进行主成分分析（PCA），第一主成分的值即为 Epigengene。它代表该模块内基因表达的整体水平。 如果某模块在样品中特征值正或负表达较高，说明模块与这个样品关系紧密 # 6.2 模块与表型性状关联分析 模块显著性值（Module significance，MS）：模块内所有基因的基因显著性值的平均值。 基因显著性值（Gene significance, GS）: 基因表达水平与因变量水平的相关系数。用 T 检验计算每个基因在不同表型样品组间的差异表达显著性检验 P 值（Pearson 相关系数），通常将 P 值取以 10 底对数值定义为基因显著性 GS 计算各模块与一表型性状的 MS 值，如一个模块的 MS 值显著高于其他模块，则这一模块与该性状存在关联关系 模块特征值显著性（Epigengene significance, ES）: 模块特征值与某一性状的相关系数，筛选与性状关联度最高的模块 # 6.3 富集分析 对各个模块都进行 GO 和 KEGG 富集分析，找出与我们研究性状相关通路相关性最强的模块进行深入挖掘 # 6.4 依据目标基因筛选模块 依据研究目的、前期研究结果和已发表文献，有重点关注的目标基因，可直接筛选目标基因所在的基因模块重点进一步分析 # 7 鉴定关键基因 # 7.1 模块内部基因连接度分析 Connectivity (degree)- 连接度：与某个基因连接的所有其他基因的总和，即描述一个基因与其他所有基因的关联程度，一般用 K 值表示。 Intramodular connectivity KIM - 模块内部连接度 IC: 某个模块中的基因与该模块中其他基因的关联程度（共表达程度）。可用来衡量模块身份 (module membership,MM). Module Membership MM,or Epigengene-based connectivity KME: 模块身份，用一个基因在所有样本中的表达语与某个模块特征值的表达谱的相关性，来衡量这个基因在这个模块中的身份。 KME 值接近 0, 说明这个基因不是该模块的成员：KME 接近 1 或者－1, 说明这个基因与该模块密切相关（正相关或者负相关）。 可以对所有基因计算相对某个模块的 KME 值，并不一定要是该模块的成员。 KME 与 KIM 高度相关。某个模块中 KIM 值高的 hub 基因一定与该模块的 KME 也很高。 KME 与 KIM 的区别：IC 衡量基因在特定模块中的身份，MM 衡量基因在全局网络中的位置。 筛选关键基因： TOM 值（模块调控系表中的 weight 值）大于阈值（默认是 0.15) 的两个基因才认为是相关的，然后计算每个基因的连接度。即先筛选有足够强度的关系，然后计算连接度。 模块内部高连接度的基因，模块内排名前 30 或者 10%(KME 或 KIM). 筛选关键基因：将该基因模块身份 MM 相对于基因显著性 GS 做散点图，选择右上角 MM 和 GS 均高的基因进一步分析。 基因显著性值（Gene significance,GS) 因变量水平的相关系数。衡量基因与表型性状的关联程度，GS 越高，说明与表型越相关，越具有生物学意义。GS 可以为正值或负值（正相关或负相关） Cytoscape 中一般用 weight 值（TOM 值）来绘制网络图。 # 7.2 特定功能基因分析 高连通性的基因一般位于调控网络的上游；低连通性的基因一般位于调控网络的下游。 调控网络上游一般是调控因子，如转录因子；下游一般是功能性的酶或蛋白分子 重点关注具有调控功能的基因，典型的为转录因子，这些基因往往是关键基因 # 7.3 目标基因关联分析 依据研究目的，选取跟目标基因关系紧密的基因，如筛选与目标基因的 TOM 值排名前 10，或者 TOM 值大于 0.2 的基因 可准确筛选与目标基因存在上下游调控关系的候选基因 当目标基因连接度不高时，可筛选与目标基因 TOM 值很高，且自身连接度也很高的基因 参考文献： Langfelder, P., Horvath, S. WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 9, 559 (2008). https://doi.org/10.1186/1471-2105-9-559","tags":"bioinformatics wgcna"},{"title":"文献导读:真菌和陆栖藻类水平基因转移","url":"/2020/07/30/2020-07-30-HGT/","text":"这篇文献于 2014 年 12 月 30 日发表在 Organism Diversity &amp; Evolution , 主要描述了在地衣中，地衣真菌可以向藻类捐赠基因，该文献对藻类进行测序，探究真菌基因进入藻类基因组的 HGT 证据，我的课题是对真菌进行了测序，藻类有参考基因，也可以借鉴该方法。 # 摘要 科学家们几个世纪前就已经知道真菌和藻类之间亲密而持久的关系，而这些古老的共生关系可能为这两种生物伙伴之间编码蛋白的基因水平转移 (HGT) 提供了极好的机会。在本研究中，对地衣 Xanthoria parietina（子囊菌门：Ascomycota，茶渍纲：Lecanoromycetes，黄枝衣科：Teloschistaceae）中的绿色藻类光生生物 Trebouxia decolorans（绿藻门：Chlorophyta，共球藻科：Trebouxiaceae）（PS: 我做的项目里，地衣的藻类与该藻类属于一个纲：共球藻纲（Trebouxiophyceae））进行了基因组测序，组装出 451Mbp 的全基因组。这种藻类也是一种自由生活的陆生生物。该研究的目的是在地衣真菌和地衣藻类之间寻找指向 HGT 的候选基因。发现了真菌基因进入 Trebouxia 基因组的三个假定的 HGT 事件的证据，但这些可能比真菌子囊菌中的地衣化起源更古老 (超过 600mya)。这三个被转移的基因是编码抗碲酸二羧酸转运蛋白 (TDT) 家族蛋白的基因组的一部分，一个 I 类 nitrilase/cyanide 酶（CH），和一个氧化还原酶 / 视黄醇脱氢酶。在每一种情况下，系统基因组分析显示，从 Trebouxia 到所有真菌或子囊菌的同源基因是姐妹的，而绿藻和陆生植物的同源基因形成了独立的进化谱系。备择假设测试显著支持这些 HGT 事件。通过 PCR 扩增分离 Trebouxia 的 DNA，验证了这些基因在 Trebouxia 中的存在。这些特殊绿藻的基因组中古老的真菌基因的结合是有趣的，它可能是早期地球上陆地生命中存在的藻类和真菌的主要真核分支之间的共生和进化关系的早期证据。这些基因可能在一些真菌和藻类共生地衣起源中发挥了易感作用，但这还需要进一步的研究来详细评价。 # 引言 水平基因转移 (HGT) 涉及遗传物质从一个生物体转移到另一个生物体，属于独立的进化谱系。HGT 在原核生物的进化和多样性中起着重要的作用；然而，HGT 在真核生物宏观进化中的程度尚不清楚。最近的基因组研究表明，在真菌、细菌和真菌之间以及真菌和植物之间存在 HGT。HGT 也发生在有密切联系的 (微生物) 有机体之间，如宿主和它们的寄生虫，微生物的猎物和它们的捕食者。即使知道真核 HGT 事件的数量 (包括真菌) 很小，这些事件可能有相当大的影响功能创新和适应特定的生态位。 例如，在豌豆蚜虫、青桃蚜虫和双斑蜘蛛螨中合成类胡萝卜素是可行的，因为真菌类胡萝卜素生物合成基因进入节肢动物基因组。 HGT 还促进了卵菌中植物寄生机制的进化，过氧化氢酶基因进入真菌致病物种 Nosema locustae, Stagonospora nodorum, Mycosphaerella fijiensis 和 Botrytis cinerea 中有助于克服宿主防御机制。同样，多酮合酶基因在大量次生地衣物质的产生中起着至关重要的作用，是细菌和地衣真菌之间 HGT 的结果。地衣真菌和光生物之间的 DNA 转移的可能性之前已经被提出，但到目前为止还没有证据表明这一点。在藻类地衣光生生物中，有报道称 Trebouxia 物种间 I 组内含子的 HGT，并解释为病毒的发生可能促进内含子的迁移。 ​ Trebouxia 是最常见的绿藻地衣光合生物。当它们生活在地衣共生系统中时，它们的种群数量最多，但至少有一些物种是自由生活的。Trebouxia 也是共球藻纲的模式属，与石莼纲和淡水绿藻纲共同构成绿藻门的核心。 绿藻是包括陆地植物在内的链状植物的姐妹谱系，它们共同构成了真核生物的绿色植物谱系。 ​ 真菌通常与藻类形成共生关系，形成微生物土壤结壳或生物膜。其中一些紧密的联系导致了被称为地衣的共生生物体的形成，至少一种真菌 (支原体) 和一种藻类或蓝藻细菌 (光生物体) 生物的稳定共存，通常还包括额外的内聚真菌和细菌，所有这些共同形成了自成一体的微型生态系统。地衣是极其成功的，从热带到极地地区，从海岸到高海拔地区，几乎所有的陆地栖息地都有地衣的身影。地衣共生的基础尚不清楚，观点从互惠共生到寄生。在发现地衣的共生性质一百多年后，许多关于地衣生物学的基本问题仍然没有得到解答。其中之一是真菌和光生物之间复杂的相互作用是如何实现的，以产生复杂的和形态上不同的结构，如叶状或果状地衣。遗传控制 (例如，蛋白质信号) 似乎是必要的，因为地衣共生体之间的细胞外交流已被证明无需物理细胞接触。此外，地衣共生系统内的相互作用还伴随着光生物和支原体基因调控和表达的变化。特别值得注意的是地衣藻类，它们向真菌提供碳水化合物，因此可能受到真菌衍生基因的严重影响，以促进这一过程，从而加强共生关系。 ​ 在地衣中，真菌的种类对每一种地衣来说都是独一无二的，但藻类成分通常可以在几种地衣中找到。这种藻类并不表现出严格的共同进化的寄主特异性，正如前面提到的，有时可以在没有真菌的情况下生存。据报道，T. decolorans 是来自其他几个地衣真菌科（如 Lecidiaceae, Parmeliaceae, Physciaceae）的光生物。 ​ 对于所有的基因，考虑了三种可能的情况：(1) 没有 HGT 的证据，(2) 最近从真菌转移到藻类的证据，(3) 古代从真菌转移到绿色植物的证据。考虑到真核生物中也存在相当多的 HGT，希望至少能在地衣真菌或其直系祖先的光生藻类 (Trebouxia; 假设 2)，当对光生藻类的基因组数据进行测序并与大量真核生物基因组进行比较时，就会发现这一点。在系统基因组学分析中，这将被显示为地衣化真菌基因支中高度嵌套的藻类基因的进化模式。为了验证这一假设，对 Trebouxia 的部分基因组进行了测序，并将推断出的基因与许多其他真核生物、细菌和古菌的大型基因组数据库进行了比较，结果在本研究中公布。 # 结论 利用 illumina・平台得到的 T. decolorans 数据为 451Mbp。从头组装产生共计 55.3Mbp 的基因组数据，保留长度为 250 bp 或平均覆盖面积为 5 的 contigs 子集以作进一步分析。该序列包括 24,655 个序列 (N50= 590 bp)，总计 13.4 Mbp，共编码 18,178 个假定蛋白。 # 亚硫酸盐外排泵 /tellurite-resistance 二羧酸转运体（TDT）家族 该家族的 360 氨基酸序列包括 76 个序列，其中 27 个来自真核生物，49 个来自原核生物。为了去除模糊区域，该序列被手工细化为 343 个氨基酸长度。树的根是 monophyletic Archaea，来自由绿色植物、红藻、真菌和细菌形成了一个副系级序列。 在得到的树中，来自两个地衣藻类部的 T.decolorans 和 * asterochris sp.* 的分支放在了 20 种担子菌和子囊菌的姊妹组中。另外四个来自绿藻门的绿藻成员被定位为两个红藻门的姐妹（图 1），但这种关系仅在贝叶斯分析中得到了很好的支持（84%）。 ​ 在 GenBank 中的 Blastp 搜索中，与该序列最相似的是一个来自于 Dorhistroma septosporum 的序列，PCR 分析证实在 T. decolorans 和 T. impressa 存在该序列。然而，这一序列不能从 Dictyochloropsis symbiontica（共球藻纲）。 # I 类 nitrilase/cyanide 酶（CH） 分析 T. decolorans 中的 CH 蛋白序列，与细菌、古细菌和真核生物进行比对，并利用古细菌作为外群。除了一个真菌外，其他所有的真菌和 T. decolorans 在一个分支中 ​ 在 GenBank 中的 Blastp 搜索中，与该序列最相似的是一个来自于 Chaetomium globosum 的序列，PCR 分析证实在 T. decolorans 存在该序列。然而，这一序列不能从 Dictyochloropsis symbiontica 和 T. impressa 扩增出来。 # Oxidoreductase/retinol dehydrogenase ​ Trebouxia 的该片段长度有 145 个氨基酸，利用 100 个来自细菌和真核生物（绿色植物、真菌、变形虫、后生动物、隐藻门和单倍体）构建发育树。以单系细菌作为外群。Trebouxia 位于真菌分支中的基底部，真菌分支的姐妹分支由 Coccomyxa 和 Micromonas、11 个被子植物序列以及其他细菌序列和 2 个真核生物序列（变形虫和单胞菌科）组成。 在 GenBank 中的 Blastp 搜索中，与该序列最相似的是一个来自于 Verticillium dahlia 的序列，PCR 分析证实在 T. decolorans 存在该序列。然而，这一序列不能从 Dictyochloropsis symbiontica 和 T. impressa 扩增出来。 # 候选基因的真菌和藻类序列重组分析 为了测试 HGT 事件是否真的正确（即 Trebouxia 的分类位置是否正确），使用 RAT 分析了基因树的氨基酸序列。没有发现重组的迹象。只有在真菌序列之间才能检测到重组的证据。 # 讨论 ​ 不同有机体谱系间的水平基因转移通常是通过对一个基因的系统发生或系统基因组学分析来检测的，该基因显示出与其他分类群的不同关系，而不是基于这些分类群中该基因的其他副对数而预期的。这种异常模式只能（或最有可能）用罕见的水平基因转移来解释，而不是通常的垂直遗传，这种遗传是经过亿万年和 / 或几千年进化和物种形成的结果。值得注意的是，本研究系统基因组学结果是由于 HGT，以及原核生物之间以及（历史上）真核生物非常基础分支之间的基因交换。如前所述，HGT 在真核生物的衍生和现存分支中不太常见。转移的方向通常是从相关基因的近亲推断出来的，如果基因嵌套在一组分类学上未分类的有机体中，那么周围的类群很可能就是基因的起源。未来需要进行后续的分析，这些分析基于来自 Trebouxia 的扩展基因组数据集以及更广泛的分类单元采样，包括更多的绿藻、基础真菌群和地衣形成真菌。研究结果讲述了真菌和地衣藻类之间的三个古老 HGT 故事，* 期待着通过全世界科学家正在进行的基因组测序工作，在未来几年里，这些情景是如何发展的。","tags":"literature_reading hgt"},{"title":"文献导读:菌虫共生真菌测序","url":"/2020/07/27/2020-07-27-Symbiotic/","text":"# Amylostereum areolatum 基因组测序与分析：揭示菌虫共生的生物学基础 最近做的地衣共生没有什么头绪，找到的文献都是宏基因组相关，无奈，只好找了菌虫共生菌的基因组分析作为借鉴，看看能不能从中发掘出有用的方法。 这篇文献 2020 年 5 月发表在 ASM 上，主要对 Sirex noctilio 的真菌共生体 Amylostereum areolatum 进行基因组测序分析，与我进行的工作类似。 # 摘要 ​ Amylostereum areolatum 是一种全球入侵物种 - 欧亚树蜂 (Sirex noctilio) 的共生真菌，这种互惠共生关系与木蜂有关，可协助其昆虫伙伴的破坏过程，并为其提供营养。A. areolatum 的定植和生长对 S.noctilio 的发育和传播有重要影响，但两者之间相互作用的机制尚不清楚。在这项研究中，对这种共生真菌的第一个基因组进行了测序、组装和注释。首次组装了 A.areolatum 基因组为 57.5 Mb (54.51% GC 含量)，有 15611 个蛋白编码基因。鉴定了 580 个碳水化合物活性酶 (CAZymes)， 661 个基因与病原 - 宿主相互作用，以及 318 个基因编码转运蛋白。基因组注释揭示了 10 种萜类 / 植物烯合成酶，可分为三个亚类。第二类萜烯合成酶基因簇在整个红菇 (Russulales) 中保存良好。在这个簇中，编码甲羟戊酸激酶（MK）、EGR12（COG1557）和非植物萜环化酶（CD00687）的基因是已知的生物合成和调控基因。通过对该真菌基因组序列的分析，从分子水平上证明了 A.areolatum 挥发物对 S.noctilio 寄主选择的影响。进一步阐明了 A. areolatum 是一种严格的专性共生真菌。蜂在通过产卵将其引入合适的寄主基质前对其进行保护，同时为 S.noctilio 幼虫的生长提供适宜的环境和营养。 ​ Sirex noctilio 与一种共生真菌 A.areolatum 一起，对世界各地的松树物种造成了严重的危害。在我国，它导致蒙古松大面积死亡。木蜂与其真菌之间存在一定的依赖互惠关系。研究表明，真菌的生长速度会影响黄蜂的体型：较大的成虫会出现在真菌生长速度较高的地方。通过对该真菌的基因组序列分析，证明了 A.areolatum 挥发物在分子上影响 S. noctilio 寄主选择的可能性。进一步阐明了 A. areolatum 是一种严格的专性共生真菌，为 S. noctilio 幼虫的生长提供了适宜的环境和营养物质。这些结果将为我们理解这种菌虫共生的机理奠定基础。 # 引言 木蜂与真菌共生体间存在着严格的专性依赖互惠共生关系。S. noctilio 有一个专门的器官来储存共生真菌，贮菌器（mycangium）。首先，在真菌被引入合适的宿主基质之前，贮菌器可以保护真菌。 在产卵期间，雌性木蜂通过产卵器将其共生真菌和植物毒毒液黏液与卵接种到寄主树中。当成虫出现时，真菌从蛹腔壁被吸进囊膜。通过这种方式，雌性收集虫室中产生的虫卵，传播并接种到新树中。反过来，这种真菌也对 S. noctilio 的发育乃至繁殖潜力至关重要。A.areolatum 感染并干燥木材基质，为虫卵和幼虫提供更适合的微环境。此外，共生真菌的纤维素，半纤维素和果胶的降解酶含量较多也可能是对 S. noctilio 幼虫至关重要的一环。S. noctilio 的发育及其繁殖潜力与共生真菌的活力密切相关。研究表明，S. noctilio 幼虫在三龄或四龄时都以 A.areolatum 提供的降解物为食，然后以白色腐烂的木材为食。真菌的生长速度影响了 S. noctilio 的体型大小；较大的成虫出现在真菌生长率较高的地方。碳水化合物活性酶 (CAZymes) 和毒力相关基因在真菌定植和生长中起着重要作用。白腐真菌能有效地降解木质纤维素生物质，特别是从植物中提取的木质纤维素。许多已被研究的毒力相关基因被发现与操纵植物防御促进真菌感染有关。这些基因在防御机制、信号转导、碳水化合物运输和代谢、细胞内运输、分泌和囊泡运输等方面发挥重要作用。 ​ 挥发性成分在吸引雌胡蜂到植物寄主的过程中起着重要的作用。先前的研究表明 S. noctilio 对 A.areolatum 的挥发性成分的反应比对受袭树木的反应更强。这些真菌挥发物也能吸引 S. noctilio 到受 A.areolatum 感染的寄主那里。对 A.areolatum 及其他蒙古松内生真菌的挥发性有机化合物 (VOCs) 进行了分析，发现倍半萜类化合物对已交配的 S. noctilio 有吸引力，但对未交配的 S. noctilio 无吸引力。虽然萜类化合物可能在木蜂的空间聚集中发挥重要作用，但迄今为止在 A. areolatum 中尚未发现萜类生物合成酶，而且基因组测序方法是通过识别参与次生代谢物活性的基因来发现萜类化合物生物合成途径的常用方法。 ​ 在本研究中，作者完成了 A.areolatum 的基因组测序，分析了碳水化合物酶、毒力基因和次生代谢基因。这些发现将有助于解释这样一个假设，即在的 S. noctilio 生命周期中，有一种酶起着至关重要的作用，例如通过降解植物细胞壁为夜蛾幼虫的定殖和生长提供营养，以及通过产生倍半萜类化合物来吸引雌虫产卵。本研究结果为更好地了解 S. noctilio 和 A. areolatum 之间的互利共生机制奠定了基础。 # 结果 # 基因组特征 二代测序 (illumina) 与三代测序 (PacBio) 相结合，经过质量控制，得到 HiSeq 数据 6839 Mb (118 coverage) 和 PacBio 数据 4314 Mb (74 coverage)。 # 重复原件与转座酶 ​ 除了编码蛋白质的基因序列外，真菌基因组的一个重要部分是重复元件。在 A. areolatum 基因组中，鉴定了 14,513,406 bp (基因组序列的 25.21%) 的重复元件。串联重复序列占 1.1%，转座因子 (transposable elements, TEs) 占 24.11%。在 TEs 中，I 类元素和 II 类元素 (DNA) TEs 分别占基因组的 15.50% 和 1.36%。未知和其他重复元素占 8.17%。长末端重复序列 (LTRs) 是 I 类 TEs 中最丰富的 (占总基因组序列的 14.79%)，包括 Copia、Gypsy 和 BEL/Pao 逆转录转座子超家族。 # 种系发生 (Phylogeny) 利用 Orthofinder 鉴定出 56374 个基因簇，其中 913 个为所有真菌共有的基因。从这些共享的基因簇中，选择 41 个单拷贝基因，分析 A.areolatum 与其他 82 个伞菌纲的参考基因组的进化关系。最大似然（ML）分析在高支持率（70%）的情况下，确定了 15 种主要真菌分支的进化关系。 系统发育分析表明，该菌与其它红菇属植物群聚在一起，与植物病原真菌松果体菌（Peniophora sp.CONT）关系密切。 # 碳水化合物酶 在 A. areolatum 基因组中，鉴定出 580 种 CAZymes，包括 219 种糖苷水解酶（GHs）、67 种糖基转移酶（GTs）、16 种多糖裂解酶（PL）、60 种碳水化合物酯酶（CE）、58 种碳水化合物结合模块（CBM）和 160 种具有辅助活性的酶（AAs）。与传统真菌相比，A. areolatum 含有更多的 CAZymes，与森林病原菌（forest pathogens）类似。 在 A.areolatum 基因组中，编码 GHs 和 AAs 的基因比其他蛋白类型多。45 个 GH 基因家族中 GH3 (15 拷贝)、GH5 (18 拷贝) 和 GH18 (16 拷贝) 的数量尤其丰富。此外，还发现 2 个 GH6 和 8 个 GH7 成员与结晶纤维素的降解有关。AA 家族的分类显示，多数 AAs AA3 家族的成员 (62 拷贝), 包括亚科纤维二糖脱氢酶 (EC 1.1.99.18), 葡萄糖氧化酶 1 (EC 1.1.3.4)、芳基醇氧化酶 (EC 1.1.3.7)、酒精氧化酶 (EC 1.1.3.13) 和吡喃糖氧化酶 (EC 1.1.3.10)。 # 推测的毒性相关基因 ​ 总共有 661 个与病原体 - 宿主相互作用 (PHI) 相关的预测 A. areolatum 基因。毒力降低所占比例最高 (45.39%)，其次是未受影响的致病性 (23.45%)、失去致病性 (10.14%)、致死 (9.23%)、混合结果 (8.47%)、化学目标 (1.21%)、毒力增加 (高毒力)(1.66%) 和效应器 (植物无毒性决定因素)(0.45%)。此外，我们还注释了 47 个已报道为致病菌毒力因子 (VFs) 的基因 (致病菌毒力因子 [毒力因子数据库 VFDB])。根据这些基因在其他寄主物种的发病机制中所起的作用，这些基因可能是 A. areolatum 假定致病性因子。此外，还鉴定了 A. areolatum 中 83 个家族 318 种转运蛋白。在这些转运蛋白中，37 个基因编码 MFS 蛋白，18 个基因编码 ATP 结合盒蛋白；其他科中编码蛋白的基因较少。 # 倍半萜烯合酶集群 ​ AntiSMASH 分析表明 A. areolatum 次生代谢物基因的数量和类型与报道的其它红菇属植物相似，后者携带 19 个次生代谢基因簇，包括编码 8 个萜烯 / 植物烯合成酶的基因簇，2 个非核糖体肽合成酶（NRPS），1 个 I 型聚酮合酶（T1PKS）、一个铁载体合成酶和七个未知基因簇。值得一提的是，鉴定出的萜烯 / 植物烯合酶基因簇数量最多。这些酶可能参与了萜类化合物的生物合成，尽管还需要进一步的研究来确定这一点。 为了阐明萜烯生物合成簇的保守性和多样性结构，从 83 个伞菌纲基因组中获得了两个包含 5 个倍半萜合成酶（STS）基因的同源群。A. areolatum 基因组含有 10 个萜烯合成酶基因，与伞菌纲中这类酶的数量一致。系统发育树是利用三种合成酶（Cop3、Cop4 和 Cop5）的同源序列构建的，这三种合成酶是在 A. areolatum 基因组中鉴定出来的。萜合成酶基因与 Cop-STS 基因分为三大类，表明每个簇中的酶可能通过保守的环化途径产生相关的萜类化合物。 在真菌中，次生代谢产物生物合成基因通常位于相邻的簇中。有趣的是，第二类萜烯合成酶基因簇在整个红菇中保存得很好。A.areolatum、S. hirsutum 和 H. irregulare 之间的共线性表明，参与萜类化合物合成的基因具有良好的共线性，这表明红菇可能共享与萜烯代谢相关的保守核心基因。保守的基因簇包括甲羟戊酸激酶（MK）、EGR12（COG1557）、非植物萜烯环化酶（cd00687）、烯醇辅酶 A（enoyl-CoA）水合酶 / 异构酶和 P 激酶，其中一些基因已被证实与甲羟戊酸途径（合成萜类的途径之一）有关。除了参与倍半萜代谢的核心萜烯环化酶外，倍半萜簇中还存在 ABC 转运体 ATP 结合蛋白（CL0023）和 P450（PF00067）。这些酶可能在氧化和羟基化等修饰以及倍半萜的运输中发挥作用。 # 讨论 # 一般基因组特征和系统发育 A. areolatum 基因组组装约为 53mb，相当于红菇相关成员的组装体大小，从 26mb 到 122mb 不等。A. areolatum 基因组包含 15611 个编码基因。系统进化树表明，在进化上，A. areolatum 与植物病原真菌 Peniophora sp.CONT 的进化关系较近。 # 与降解植物细胞壁和角质层相关的蛋白家族 毒液和真菌共生体的存在会导致寄主的弱化和树脂压力的下降，为 S.noctilio 的卵孵化和幼虫发育提供了更为适宜的微环境。此外，S.noctilio 的行为和形态适应表明，S.noctilio 幼虫不摄取木质部，而是利用 A.areolatum 对难降解的木质纤维素化合物进行外部消化。A. areolatum 能分泌大量的纤维素酶、半纤维素和木质素酶，能有效降解植物细胞壁成分，提供营养物质（如葡萄糖、甘露糖、半乳糖、醋酸、木糖等）因此，A. areolatum 的成功定殖和生长对其发育起着至关重要的作用。真菌的解聚能力与其分泌一系列酶的能力成正比。在分析中，A. areolatum 的胞浆酶数量与森林病原菌相当，并且显著高于传统腐生蘑菇，这表明 A. areolatum 能够突破植物细胞壁，以类似于其他森林病原菌的方式成功建立感染。它可以通过破坏植物细胞的结构来削弱松树，并为 S.noctilio 幼虫的生长提供营养。 植物细胞壁含有丰富的纤维素。GHs 是降解纤维素、半纤维素和淀粉的常见酶。它们参与碳水化合物分子之间或内部糖苷键的水解。共有 219 个 GHs 被分为 45 个家系。编码 GH3 和 GH5 类酶的基因数量超过了编码其他 GH 酶的基因。这与树木腐烂真菌（白色、棕色和软腐真菌）GHs 的组成特征相似。此外，真菌基因组中发现了丰富的 GH18 基因编码，这些基因催化几丁质的分解。几丁质酶能降解真菌细胞壁，抑制孢子萌发、菌丝生长、芽管伸长等发育活动。因此，推测 GH18 可能对其它内生真菌如麦冬菌和球毛壳菌在蒙古松上的拮抗作用起了一定的作用。在 CAZy 数据库中，90% 的木质纤维素降解真菌含有编码裂解多糖单加氧酶（LPMOs）的基因。这些酶主要参与非碳水化合物结构组分（木质素）的解聚，或作为植物的主要细胞壁成分被发现（34，39）。在本研究中，我们分别检测到 62 个和 25 个 AA3 和 AA1 拷贝。AA3 家族（GMC 氧化还原酶 / 脱氢酶）主要存在于森林病原菌中，如 S. hirsutum（48 个 AA3 基因）和 Heterobasidion annosum（32 个 AA3 基因）。AA3 家族包含氧化还原酶的甘糖醇 - 胆碱（GMC）家族中的酶，该家族通过其反应产物协助其他 AA 家族酶的活性或支持糖苷水解酶在木质纤维素降解中的作用。它们通过产生过氧化氢和回收聚合物氧化攻击所需的电子给体和受体，促进木质纤维素的分解。 ​ Laccase 另一种重要的木质素降解酶，属于 AA1 家族。在真菌中 Laccase 有不同的角色，如介导真菌病原体和宿主植物之间的相互作用，大量的 AA3 和 AA1 基因导致松树的氧化降解，使 A. areolatum 具有强烈穿透植物细胞壁和降解木质素的能力。这不仅有利于真菌的定植和生长，也为 S.noctilio 幼虫提供了营养。 # 毒力相关基因 病原体 - 宿主相互作用数据库（PHI-base）收录了来自真菌、细菌和原生病原体的 2800 多个基因，并通过实验验证了致病性、毒性和效应基因。这些基因表达的失活或减少可以降低或消除致病能力。在对 PHI-base 数据库检索得到的所有预测基因中，与毒性降低、未受影响的致病性和致病性丧失相关的基因是最常见的。生理学实验表明，单独接种 A. areolatum 并不会显著降低树势，也不会影响树木的生长。本研究所描述的 A.areolatum 毒力相关基因的特征有助于解释这一现象。致死基因的缺失或低表达会导致真菌无法存活。基因组中只有 9.23% 的致死基因。这可能是因为 A.areolatum 是一种典型的共生真菌；在将其引入合适的宿主基质之前，S.noctilio 会保护真菌。 在真菌转运蛋白中，ATP 结合盒（ABC）转运蛋白和主要促进因子超家族（MFS）是最大的两个超家族。ABC 转运蛋白是多组分的，主要是活性转运蛋白，在 ATP 水解条件下，它既能运输小分子，也能运输大分子。它们能运输多种化合物，如多糖、药物、糖、重金属、寡肽、氨基酸和无机离子。研究表明，在所有测序真菌中，S.pombe 只含有 19 个 ABC 蛋白，这可能接近自由生命有机体的最小值。A. areolatum 中 ABC 蛋白的含量比 S.pombe 少，而且更显著的是，它缺乏 ABC-D 转运体，而 ABC-D 转运体在所有测序物种中都有发现，除了 Encephalitozoon cuniculi 和 S.pombe。从真菌中提取的 ABC 蛋白只有少数已被功能性鉴定，而 ABC-D 转运蛋白的缺乏还需要进一步的研究。 A. areolatum 含有大量的糖类酶基因，但毒力和转运基因较少。这与它们的共生关系是一致的；A. areolatum 通过分泌胞外酶为 S.noctilio 幼虫的生长提供营养，而 S.noctilio 通过将真菌带到一个特殊的器官 —— 贮菌器中，保护和转移真菌，然后将其引入一个新的合适的寄主基质。 # 倍半萜烯合酶集群 ​ 研究表明，与寄主植物相比，交配后的雌性 S.noctilio 对 A. areolatum 挥发性成分更具吸引力；倍半萜类化合物可能在这一过程中发挥作用。对红菇属真菌的序列分析表明，倍半萜合成酶同源基因在这些真菌中广泛存在。然而，尽管倍半萜合成酶同系物在真菌中占优势，但对其活性和生物学功能知之甚少。在大肠杆菌表达载体上克隆和鉴定了灰曲霉的倍半萜合成酶，结果表明在 Cop3 培养基中产生了 muurolene、elemene、muurolene、germacrene D 和 cadinene。在 Cop4 培养物中检测到了 Cadinene、cubebene、sativene、copaene 和 cubebol。因此推测，同样的化合物也出现在 A. areolatum 的挥发性成分中。 # 材料和方法 # 基因组组装 利用 Illumina 序列进行 k-mer 分析，并对 PacBio 组装进行校正。为了得到高质量的装配，使用 GATK 对序列错误进行了修正。然后，使用 SSPACE_Basic 工具将 contigs 合并成 scaffolds，使用 PBJELLY 封闭间隙。最后，基于成对序列相似度搜索，应用冗余管道来识别和去除杂合的 contigs 和 scaffolds。利用 BUSCO 和来自真菌谱系的数据集对候选 assembly 进行了评估。 # 基因预测与注释 ​ 结合从头预测和基于转录体的预测方法对编码蛋白的基因进行预测。初步预测采用 SNAP、Augustus 和 GeneMark ES 进行编码基因预测。然后，使用 Tophat 将转录组测序 (RNA-Seq) 数据 (未发表) 映射到 assembly 上，使用 Cufflinks 将转录组组装到基因模型上。最后，利用循证 emodeler (EVM) 将上述方法预测的所有基因模型组合成一个非冗余的基因结构集合。使用 tRNAscan-SE 检测 tRNA 区域和二级结构。使用 RNAmmer 软件分析小 rna，使用 Infernal 对 Rfam 数据库进行搜索，预测小 rna (sRNAs)。预测的基因模型通过 BLASTp 搜索、Swiss-Prot、TrEMBL、Orthologous、GO 和 KEGG 进行功能注释。 # 转座因子和串联重复序列的鉴定 本研究采用序列比对预测法和从头预测法来评估 A. areolatum 基因组中的 TEs。对于序列比对预测方法，使用 RepeatMasker，使用数据库 Repbase 搜索 TEs。优化的默认参数与 - lib 选项一起使用以查找重复项，-species 真菌选项用于单独的分析以查找真菌重复。RepeatProteinMasker 和与 RepeatMasker 相关的转座子蛋白文库也被用来鉴定 TEs。从头预测方法，利用 buildXDFDatabase 生成扩展数据库格式（XDF）。然后，使用 RepeatModeler 和 XDF 数据库建立 TE 模型，然后使用 RepeatMasker 对 TE 进行预测。串联重复序列用 RepeatMasker 进行评估。 # 系统发育分析 ​ 从 NCBI 数据库以 FASTA 格式下载 79 种蘑菇菌种的基因组序列。利用正交法获得了真菌基因组中的一组同源基因 (系统进化保守)。我们选择 41 个单拷贝同源基因构建系统发育树。使用 MAFFT 进行序列比对，使用 Gblocks 提取并连接保守位点。我们运行 ProtTest 以选择最合适的模型，并使用 RAxML 构建 ML 基因树，其中 - f a -x 12345 -p 12345 -m PROTGAMMAILGF -N 1000 选项。使用 Wallemia sebi 蛋白序列作为外组 # 碳水化合物酶分析 ​ 利用 BLAST 对 A. areolatum 和其他 10 种真菌中的 CAZymes 进行鉴定和注释，并使用 dbCAN 注释程序 HMMER 对 CAZy 数据库进行搜索。当 E 值小于 1e05 时，将结果进行汇总。II 类过氧化物酶和 DyPs 通过 BLAST 在过氧基数据库中的搜索得到了进一步证实。 # 毒力相关基因预测 候选毒力相关基因在 A. areolatum 基因组中使用 BLASTp 来搜索 PHI-base。对蛋白进行比对，以确定在 A. areolatum 中可能存在的毒力相关基因，其识别率超过 40%，查询覆盖率超过 70%。毒力因子 (VFs) 检索使用 BLAST 比对毒力因子数据库。运输分类数据库 (TCDB) 包含序列，分类，和结构，功能，和进化信息的运输系统从各种分类。基于转运体分类数据库的搜索，以 E 值阈值 1e-05 和识别值为 40% 确定了 A. areolatum 中的候选转运体。利用 MAFFT 对蘑菇真菌 ABC 转运蛋白进行序列比对，利用 FastTree 构建系统发育树 # 次生代谢基因预测 利用 AntiSMASH 对 A.areolatum、S.hirsutum、Peniophora sp. CONT 和 H. irregulare 的次级代谢生物合成基因和基因簇进行了预测。在两个同源类群中获得 83 个伞菌纲基因组的假定真菌萜烯合酶序列。还包括五个在 C.cinereus 中发现的倍半萜合酶同源物 (分别命名为 Cop1 和 Cop5)。在构建系统发育树时，要手动检查比对以排除注释错误的序列 (例如，序列似乎太短或太长)。在 MAFFT 中对 902 个萜烯合成酶基因进行序列比对，利用 FastTree 构建系统发育树。","tags":"literature_reading"},{"title":"R数据科学笔记:2","url":"/2020/07/25/2020-07-25-R4ds2/","text":"# 第二章 工作流：基础 # 2.1 代码基础 首先，我们可以将 R 当做计算器使用 &gt; 1 &#x2F; 200 * 30[1] 0.15&gt; (59 + 73 + 2) &#x2F; 3[1] 44.66667&gt; sin(pi &#x2F; 2)[1] 1使用 &lt;- 来创建新对象： x &lt;- 3 * 4创建对象的所有 R 语句（即赋值语句）都有同样的形式： object_name &lt;- value在阅读这行代码时，你可以在脑海中默念 “某个对象名得到了某个值”。如果你觉得 “&lt;-” 太繁琐你可以使用 RStudio 快捷键：Alt+-（Alt 加上减号）。 # 2.2 对象名称 对象名称必须以字母开头，并且只能包含字母、数字、_ 和.。如果想让对象名称具有描述性，那么就应该在使用多个单词时遵循某种命名惯例。我推荐使用 snake_case 命名法，也就是使用小写单词，并用_ 分隔： i_use_snake_caseotherPeopleUseCamelCasesome.people.use.periodsAnd_aFew.People_RENOUNCEconvention可以通过输入对象名称来查看这个对象： &gt; x[1] 12再进行一次赋值： r_rocks &lt;- 2 ^ 3## 查看一下这个对象r_rock#&gt; Error: object &#39;r_rock&#39; not foundR_rocks#&gt; Error: object &#39;R_rocks&#39; not found# 2.3 函数调用 R 中有大量内置函数。调用方式如下： function_name(arg1 &#x3D; val1, arg2 &#x3D; val2, ...)我们尝试使用 seq () 函数，输入参数 1, 10: &gt; seq(1,10) [1] 1 2 3 4 5 6 7 8 9 10输入以下代码，你会发现 RStudio 也会自动完成一对双引号以方便输入： x &lt;- &quot;hello world&quot;引号和括号必须一直成对出现。RStudio 会尽力帮助我们，但还是有出错并导致不匹配的可能。如果出现不匹配，R 会显示一个 + 号： &gt; x &lt;- &quot;hello++ 号表明 R 在等待继续输入；它认为你还没有完成输入。这通常意味着你漏掉了一个 &quot; 或者)。 如果进行了一次赋值，R 不会显示出赋值结果。你最好立刻检查一下： &gt; y &lt;- seq (1, 10, length.out &#x3D; 5)&gt; y[1] 1.00 3.25 5.50 7.75 10.00## 或者采取简化方式&gt; (y &lt;- seq (1, 10, length.out &#x3D; 5))[1] 1.00 3.25 5.50 7.75 10.00# 第三章 使用 dplyr 进行数据转换 # 3.1 简介 本章将用 dplyr 包来转换数据，并介绍一个新的数据集：2013 年从纽约市出发的航班信息。 # 3.1.1 准备工作 本章将重点讨论如何使用 tidyverse 中的另一个核心 R 包 ——dplyr 包。我们使用 nycflights13 包中的数据来说明 dplyr 包的核心理念，并使用 ggplot2 来帮助我们理解数据。 # 3.1.2 nycflights13 使用 nycflights13::flights。这个数据框包含了 2013 年从纽约市出发的所有 336 776 次航班的信息。该数据来自于美国交通统计局，可以使用？flights 查看其说明文档： &gt; flights# A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 2 2013 1 1 533 529 4 3 2013 1 1 542 540 2 4 2013 1 1 544 545 -1 5 2013 1 1 554 600 -6 6 2013 1 1 554 558 -4 7 2013 1 1 555 600 -5 8 2013 1 1 557 600 -3 9 2013 1 1 557 600 -310 2013 1 1 558 600 -2# ... with 336,766 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,# dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,# minute &lt;dbl&gt;, time_hour &lt;dttm&gt;列名下面有一行 3 个或 4 个字母的缩写。它们描述了每个变量的类型。 ・int 表示整数型变量。 ・dbl 表示双精度浮点数型变量，或称实数。 ・chr 表示字符向量，或称字符串。 ・dttm 表示日期时间（日期 + 时间）型变量。 还有另外 3 种常用的变量类型，虽然没有在这个数据集中出现，但很快就会在本书后面遇到。 ・lgl 表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。 ・fctr 表示因子，R 用其来表示具有固定数目的值的分类变量。 ・date 表示日期型变量。 # 3.1.3 dplyr 基础 5 个 dplyr 核心函数： ・按值筛选观测（filter ()）。 ・对行进行重新排序（arrange ()）。 ・按名称选取变量（select ()）。 ・使用现有变量的函数创建新变量（mutate ()）。 ・将多个值总结为一个摘要统计量（summarize ()）。 这些函数都可以和 group_by () 函数联合起来使用，group_by () 函数可以改变以上每个函数的作用范围，让其从在整个数据集上操作变为在每个分组上分别操作。这 6 个函数构成了数据处理语言的基本操作。 前面 5 个函数的工作方式都是相同的。 (1) 第一个参数是一个数据框。 (2) 随后的参数使用变量名称（不带引号）描述了在数据框上进行的操作。 (3) 输出结果是一个新数据框。 利用以上这些属性可以很轻松地将多个简单步骤链接起来，从而得到非常复杂的结果。接下来我们将深入了解，看看如何使用这些操作。 # 3.2 使用 filter () 筛选行 filter () 函数可以基于观测的值筛选出一个观测子集。第一个参数是数据框名称，第二个参数以及随后的参数是用来筛选数据框的表达式。例如，我们可以使用以下代码筛选出 1 月 1 日的所有航班： &gt; jan1 &lt;-filter(flights, month &#x3D;&#x3D; 1, day &#x3D;&#x3D; 1)&gt; jan1# A tibble: 842 x 19 year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 2 2013 1 1 533 529 4 3 2013 1 1 542 540 2 4 2013 1 1 544 545 -1 5 2013 1 1 554 600 -6 6 2013 1 1 554 558 -4 7 2013 1 1 555 600 -5 8 2013 1 1 557 600 -3 9 2013 1 1 557 600 -310 2013 1 1 558 600 -2# ... with 832 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,# dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,# minute &lt;dbl&gt;, time_hour &lt;dttm&gt;# 3.2.1 比较运算符 R 提供了一套标准的比较运算符：&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于）。当开始使用 R 时，最容易犯的错误就是使用 = 而不是 == 来测试是否相等。 在使用 == 进行比较时，你可能还会遇到另一个常见问题：浮点数。 &gt; sqrt(2)^2&#x3D;&#x3D;2[1] FALSE&gt; 1&#x2F;49*49&#x3D;&#x3D;1[1] FALSE# 3.2.2 逻辑运算符 filter () 中的多个参数是由 “与” 组合起来的：每个表达式都必须为真才能让一行观测包 含在输出中。如果要实现其他类型的组合，你需要使用布尔运算符：&amp; 表示 “与”、| 表示 “或”、! 表示 “非”。 以下代码可以找出 11 月或 12 月出发的所有航班： filter(flights, month &#x3D;&#x3D; 11 | month &#x3D;&#x3D; 12)不能写成 filter (flights, month == 11 |12) 这种形式。这种形式的文字翻译确实是 “找出 11 月或 12 月出发的所有航班”，但在代码中则不是这个意思，代码中的含义是找出所有出发月份为 11 | 12 的航班。11 | 12 这个逻辑表达式的值为 TRUE，在数字语境中（如本例），TRUE 就是 1，所以这段代码找出的不是 11 月或 12 月出发的航班，而是 1 月出发的所有航班。 这种问题有一个有用的简写形式：x % in% y。这会选取出 x 是 y 中的一个值时的所有行。 我们可以使用这种形式重写上面的代码： nov_dec &lt;- filter(flights, month %in% c(11, 12))可以使用德摩根定律将复杂的筛选条件进行简化：!(x &amp; y) 等价于！x | !y、!(x |y) 等价于！x &amp; !y。例如，如果想要找出延误时间（到达或出发）不多于 2 小时的航班，那么使用以下两种筛选方式均可： filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120))filter(flights, arr_delay &lt;&#x3D; 120, dep_delay &lt;&#x3D; 120)filter () 函数中使用的是复杂的、包含多个部分的表达式，就需要考虑用一个明确的变量来代替它。这样检查代码会容易很多。我们很快就会介绍如何创建新变量。 # 3.2.3 缺失值 R 的一个重要特征使得比较运算更加复杂，这个特征就是缺失值，或称 NA（not available，不可用）。如果运算中包含了未知值，那么运算结果一般来说也是个未知值： &gt; NA + 10[1] NA&gt; NA &#x2F; 2[1] NA如果想要确定一个值是否为缺失值，可以使用 is.na () 函数： &gt; x &lt;- NA&gt; is.na(x)[1] TRUEfilter () 只能筛选出条件为 TRUE 的行；它会排除那些条件为 FALSE 和 NA 的行。如果想保留缺失值，可以明确指出： &gt; df &lt;- tibble(x &#x3D; c(1, NA, 3))&gt; filter(df, x &gt; 1)# A tibble: 1 x 1 x &lt;dbl&gt;1 3&gt; filter(df, is.na(x) | x &gt; 1)# A tibble: 2 x 1 x &lt;dbl&gt;1 NA2 3# 3.3 使用 arrange () 排列行 arrange () 函数的工作方式与 filter () 函数非常相似，但前者不是选择行，而是改变行的顺序。它接受一个数据框和一组作为排序依据的列名（或者更复杂的表达式）作为参数。如果列名不只一个，那么就使用后面的列在前面排序的基础上继续排序： &gt; arrange(flights, year, month, day)# A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 2 2013 1 1 533 529 4 3 2013 1 1 542 540 2 4 2013 1 1 544 545 -1 5 2013 1 1 554 600 -6 6 2013 1 1 554 558 -4 7 2013 1 1 555 600 -5 8 2013 1 1 557 600 -3 9 2013 1 1 557 600 -310 2013 1 1 558 600 -2# ... with 336,766 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,# dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,# minute &lt;dbl&gt;, time_hour &lt;dttm&gt;使用 desc () 可以按列进行降序排序： &gt; arrange(flights, desc(arr_delay))# A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 9 641 900 1301 2 2013 6 15 1432 1935 1137 3 2013 1 10 1121 1635 1126 4 2013 9 20 1139 1845 1014 5 2013 7 22 845 1600 1005 6 2013 4 10 1100 1900 960 7 2013 3 17 2321 810 911 8 2013 7 22 2257 759 898 9 2013 12 5 756 1700 89610 2013 5 3 1133 2055 878# ... with 336,766 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,# dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,# minute &lt;dbl&gt;, time_hour &lt;dttm&gt;缺失值总是排在最后： &gt; df &lt;- tibble(x &#x3D; c(5, 2, NA))&gt; arrange(df, x)# A tibble: 3 x 1 x &lt;dbl&gt;1 22 53 NA# 3.4 使用 select () 选择列 如今，数据集有几百甚至几千个变量已经司空见惯。这种情况下，如何找出真正感兴趣的那些变量经常是我们面临的第一个挑战。通过基于变量名的操作，select () 函数可以让你快速生成一个有用的变量子集。 # 按名称选择列&gt; select (flights, year, month, day)# A tibble: 336,776 x 3 year month day &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 2 2013 1 1 3 2013 1 1 4 2013 1 1 5 2013 1 1 6 2013 1 1 7 2013 1 1 8 2013 1 1 9 2013 1 110 2013 1 1# ... with 336,766 more rows# 选择 “year” 和 “day” 之间的所有列&gt; select (flights, year:day)# A tibble: 336,776 x 3 year month day &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 2 2013 1 1 3 2013 1 1 4 2013 1 1 5 2013 1 1 6 2013 1 1 7 2013 1 1 8 2013 1 1 9 2013 1 110 2013 1 1# ... with 336,766 more rows# 选择不在 “year” 和 “day” 之间的列&gt; select (flights, -(year:day))# A tibble: 336,776 x 16 dep_time sched_dep_time dep_delay arr_time sched_arr_time &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 517 515 2 830 819 2 533 529 4 850 830 3 542 540 2 923 850 4 544 545 -1 1004 1022 5 554 600 -6 812 837 6 554 558 -4 740 728 7 555 600 -5 913 854 8 557 600 -3 709 723 9 557 600 -3 838 84610 558 600 -2 753 745# ... with 336,766 more rows, and 11 more variables:# arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,# tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,# distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,# time_hour &lt;dttm&gt;还可以在 select () 函数中使用一些辅助函数。 ・starts_with (&quot;abc&quot;)：匹配以 “abc” 开头的名称。 ・ends_with (&quot;xyz&quot;)：匹配以 “xyz” 结尾的名称。 ・contains (&quot;ijk&quot;)：匹配包含 “ijk” 的名称。 ・matches (&quot;(.)\\1&quot;)：选择匹配正则表达式的那些变量。这个正则表达式会匹配名称中有重复字符的变量。你将在第 10 章中学习到更多关于正则表达式的知识。 ・num_range (&quot;x&quot;, 1:3)：匹配 x1、x2 和 x3。 使用 select () 函数的变体 rename () 函数来重命名变量，以保留所有未明确提及的变量： &gt; rename(flights, tail_num &#x3D; tailnum)# A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 2 2013 1 1 533 529 4 3 2013 1 1 542 540 2 4 2013 1 1 544 545 -1 5 2013 1 1 554 600 -6 6 2013 1 1 554 558 -4 7 2013 1 1 555 600 -5 8 2013 1 1 557 600 -3 9 2013 1 1 557 600 -310 2013 1 1 558 600 -2# ... with 336,766 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tail_num &lt;chr&gt;,# origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,# hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;另一种用法是将 select () 函数和 everything () 辅助函数结合起来使用。当想要将几个变量移到数据框开头时，这种用法非常奏效 &gt; select(flights, time_hour, air_time, everything())# A tibble: 336,776 x 19 time_hour air_time year month day dep_time &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013-01-01 05:00:00 227 2013 1 1 517 2 2013-01-01 05:00:00 227 2013 1 1 533 3 2013-01-01 05:00:00 160 2013 1 1 542 4 2013-01-01 05:00:00 183 2013 1 1 544 5 2013-01-01 06:00:00 116 2013 1 1 554 6 2013-01-01 05:00:00 150 2013 1 1 554 7 2013-01-01 06:00:00 158 2013 1 1 555 8 2013-01-01 06:00:00 53 2013 1 1 557 9 2013-01-01 06:00:00 140 2013 1 1 55710 2013-01-01 06:00:00 138 2013 1 1 558# ... with 336,766 more rows, and 13 more variables:# sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;,# sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,# flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,# distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;# 3.5 使用 mutate () 添加新变量 除了选择现有的列，我们还经常需要添加新列，新列是现有列的函数。这就是 mutate () 函数的作用。 mutate () 总是将新列添加在数据集的最后，因此我们需要先创建一个更狭窄的数据集，以便能够看到新变量。记住，当使用 RStudio 时，查看所有列的最简单的方法就是使用 View () 函数： flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time)mutate(flights_sml, gain &#x3D; arr_delay - dep_delay, speed &#x3D; distance &#x2F; air_time * 60)# A tibble: 336,776 x 9 year month day dep_delay arr_delay distance air_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2013 1 1 2 11 1400 227 2 2013 1 1 4 20 1416 227 3 2013 1 1 2 33 1089 160 4 2013 1 1 -1 -18 1576 183 5 2013 1 1 -6 -25 762 116 6 2013 1 1 -4 12 719 150 7 2013 1 1 -5 19 1065 158 8 2013 1 1 -3 -14 229 53 9 2013 1 1 -3 -8 944 14010 2013 1 1 -2 8 733 138# ... with 336,766 more rows, and 2 more variables:# gain &lt;dbl&gt;, speed &lt;dbl&gt;一旦创建，新列就可以立即使用： &gt; mutate(flights_sml,+ gain &#x3D; arr_delay - dep_delay,+ hours &#x3D; air_time &#x2F; 60,+ gain_per_hour &#x3D; gain &#x2F; hours+ )# A tibble: 336,776 x 10 year month day dep_delay arr_delay distance air_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2013 1 1 2 11 1400 227 2 2013 1 1 4 20 1416 227 3 2013 1 1 2 33 1089 160 4 2013 1 1 -1 -18 1576 183 5 2013 1 1 -6 -25 762 116 6 2013 1 1 -4 12 719 150 7 2013 1 1 -5 19 1065 158 8 2013 1 1 -3 -14 229 53 9 2013 1 1 -3 -8 944 14010 2013 1 1 -2 8 733 138# ... with 336,766 more rows, and 3 more variables:# gain &lt;dbl&gt;, hours &lt;dbl&gt;, gain_per_hour &lt;dbl&gt;如果只想保留新变量，可以使用 transmute () 函数： &gt; transmute(flights,+ gain &#x3D; arr_delay - dep_delay,+ hours &#x3D; air_time &#x2F; 60,+ gain_per_hour &#x3D; gain &#x2F; hours+ )# A tibble: 336,776 x 3 gain hours gain_per_hour &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 9 3.78 2.38 2 16 3.78 4.23 3 31 2.67 11.6 4 -17 3.05 -5.57 5 -19 1.93 -9.83 6 16 2.5 6.4 7 24 2.63 9.11 8 -11 0.883 -12.5 9 -5 2.33 -2.1410 10 2.3 4.35# ... with 336,766 more rows# 3.5.1 常用创建函数 创建新变量的多种函数可供你同 mutate () 一同使用。最重要的一点是，这种函数必须是向量化的：它必须接受一个向量作为输入，并返回一个向量作为输出，而且输入向量与输出向量具有同样数目的分量。我们无法列出所有可能用到的创建函数，但可以介绍一下那些比较常用的。 算术运算符：+、-、*、/、^ 它们都是向量化的，使用所谓的 “循环法则”。如果一个参数比另一个参数短，那么前者会自动扩展到同样的长度。当某个参数是单个数值时，这种方式是最有效的：air_time / 60、hours * 60 + minute 等。 算术运算符的另一用途是与我们后面将很快学到的聚集函数结合起来使用。例如，x /sum (x) 可以计算出各个分量在总数中的比例，y – mean (y) 可以计算出分量与均值之间的差值。 模运算符：%/% 和 %% %/%（整数除法）和 %%（求余）满足 x == y * (x %/% y) + (x %% y)。模运算非常好用，因为它可以拆分整数。例如，在航班数据集中，你可以根据 dep_time 计算出 hour 和 minute： &gt; transmute(flights,+ dep_time,+ hour &#x3D; dep_time %&#x2F;% 100,+ minute &#x3D; dep_time %% 100+ )# A tibble: 336,776 x 3 dep_time hour minute &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 517 5 17 2 533 5 33 3 542 5 42 4 544 5 44 5 554 5 54 6 554 5 54 7 555 5 55 8 557 5 57 9 557 5 5710 558 5 58# ... with 336,766 more rows对数函数：log ()、log2 () 和 log10 () ​ 在处理取值范围横跨多个数量级的数据时，对数是特别有用的一种转换方式。它还可以将乘法转换成加法，我们将在本书的第四部分中介绍这个功能。 ​ 其他条件相同的情况下，我推荐使用 log2 () 函数，因为很容易对其进行解释：对数标度的数值增加 1 个单位，意味着初始数值加倍；减少 1 个单位，则意味着初始数值减半。 偏移函数 ​ lead () 和 lag () 函数可以返回一个序列的领先值和滞后值。它们可以计算出序列的移动差值（如 x – lag (x)）或发现序列何时发生了变化（x != lag (x)）。它们与 group_by () 组合使用时特别有用，你很快就会学到 group_by () 这个函数： &gt; (x &lt;- 1:10) [1] 1 2 3 4 5 6 7 8 9 10&gt; lag(x) [1] NA 1 2 3 4 5 6 7 8 9&gt; lead(x) [1] 2 3 4 5 6 7 8 9 10 NA** 累加和滚动聚合 ** R 提供了计算累加和、累加积、累加最小值和累加最大值的函数：cumsum ()、cumprod ()、commin () 和 cummax ()；dplyr 还提供了 cummean () 函数以计算累加均值。 &gt; x [1] 1 2 3 4 5 6 7 8 9 10&gt; cumsum(x) [1] 1 3 6 10 15 21 28 36 45 55&gt; cummean(x) [1] 1.000000 1.000000 1.333333 1.750000 2.200000 2.666667 [7] 3.142857 3.625000 4.111111 4.600000逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和！= 如果需要进行一系列复杂的逻辑运算，那么最好将中间结果保存在新变量中，这样就可以检查是否每一步都符合预期。 排秩 排秩函数有很多，但你应该从 min_rank () 函数开始，它可以完成最常用的排秩任务（如第一、第二、第三、第四）。默认的排秩方式是，最小的值获得最前面的名次，使用 desc (x) 可以让最大的值获得最前面的名次 &gt; y &lt;- c(1, 2, 2, NA, 3, 4)&gt; min_rank(y)[1] 1 2 2 NA 4 5&gt; min_rank(desc(y))[1] 5 3 3 NA 2 1如果 min_rank () 无法满足需要，那么可以看一下其变体 row_number ()、dense_rank ()、percent_rank ()、cume_dist () 和 ntile ()。 &gt; row_number(y)[1] 1 2 3 NA 4 5&gt; dense_rank(y)[1] 1 2 2 NA 3 4&gt; percent_rank(y)[1] 0.00 0.25 0.25 NA 0.75 1.00&gt; cume_dist(y)[1] 0.2 0.6 0.6 NA 0.8 1.0# 3.6 使用 summarize () 进行分组摘要 最后一个核心函数是 summarize ()，它可以将数据框折叠成一行。group_by () 可以将分析单位从整个数据集更改为单个分组。接下来，在分组后的数据框上使用 dplyr 函数时，它们会自动地应用到每个分组。例如，如果对按日期分组的一个数据框应用与上面完全相同的代码，那么我们就可以得到每日平均延误时间： &gt; by_day &lt;- group_by(flights, year, month, day)&gt; summarize(by_day, delay &#x3D; mean(dep_delay, na.rm &#x3D; TRUE))&#96;summarise()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 11.5 2 2013 1 2 13.9 3 2013 1 3 11.0 4 2013 1 4 8.95 5 2013 1 5 5.73 6 2013 1 6 7.15 7 2013 1 7 5.42 8 2013 1 8 2.55 9 2013 1 9 2.2810 2013 1 10 2.84# ... with 355 more rows# 3.6.1 使用管道组合多种操作 假设我们想要研究每个目的地的距离和平均延误时间之间的关系。使用已经了解的 dplyr 包功能，你可能会写出以下代码： by_dest &lt;- group_by(flights, dest)delay &lt;- summarize(by_dest,count &#x3D; n(),dist &#x3D; mean(distance, na.rm &#x3D; TRUE),delay &#x3D; mean(arr_delay, na.rm &#x3D; TRUE))delay &lt;- filter(delay, count &gt; 20, dest !&#x3D; &quot;HNL&quot;)这样做不得不对每个中间数据框命名，会影响我们的分析速度。解决这个问题的另一种方法是使用管道，%&gt;% delays &lt;- flights %&gt;%group_by(dest) %&gt;%summarize(count &#x3D; n(),dist &#x3D; mean(distance, na.rm &#x3D; TRUE),delay &#x3D; mean(arr_delay, na.rm &#x3D; TRUE)) %&gt;%filter(count &gt; 20, dest !&#x3D; &quot;HNL&quot;)使用这种方法时，x %&gt;% f (y) 会转换为 f (x, y)，x %&gt;% f (y) %&gt;% g (z) 会转换为 g (f (x,y), z)，以此类推。你可以使用管道重写多种操作，将其变为能够从左到右或从上到下阅读。 # 3.6.2 缺失值 在前面使用了参数 na.rm, 如果没有设置这个参数，会发生什么情况呢？ &gt;by_day &lt;- group_by (flights, year, month, day)&gt;summarize (by_day, delay &#x3D; mean (dep_delay))## 使用管道&gt; flights %&gt;%+ group_by (year, month, day) %&gt;%+ summarize (mean &#x3D; mean (dep_delay))&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day mean &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 NA 2 2013 1 2 NA 3 2013 1 3 NA 4 2013 1 4 NA 5 2013 1 5 NA 6 2013 1 6 NA 7 2013 1 7 NA 8 2013 1 8 NA 9 2013 1 9 NA10 2013 1 10 NA# ... with 355 more rows这是因为聚合函数遵循缺失值的一般规则：如果输入中有缺失值，那么输出也会是缺失值。好在所有聚合函数都有一个 na.rm 参数，它可以在计算前除去缺失值： &gt; flights %&gt;%+ group_by(year, month, day) %&gt;%+ summarize(mean &#x3D; mean(dep_delay,na.rm&#x3D; TRUE))&#96;summarise()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day mean &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 11.5 2 2013 1 2 13.9 3 2013 1 3 11.0 4 2013 1 4 8.95 5 2013 1 5 5.73 6 2013 1 6 7.15 7 2013 1 7 5.42 8 2013 1 8 2.55 9 2013 1 9 2.2810 2013 1 10 2.84# ... with 355 more rows在这个示例中，缺失值表示取消的航班，我们也可以通过先去除取消的航班来解决缺失值 问题。保存这个数据集，以便我们可以在接下来的几个示例中继续使用： not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay))&gt; not_cancelled %&gt;%+ group_by(year, month, day) %&gt;%+ summarize(mean &#x3D; mean(dep_delay))&#96;summarise()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day mean &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 11.4 2 2013 1 2 13.7 3 2013 1 3 10.9 4 2013 1 4 8.97 5 2013 1 5 5.73 6 2013 1 6 7.15 7 2013 1 7 5.42 8 2013 1 8 2.56 9 2013 1 9 2.3010 2013 1 10 2.84# ... with 355 more rows# 3.6.3 计数 聚合操作中包括一个计数（n ()）或非缺失值的计数（sum (!is_na ())）是个好主意。这样你就可以检查一下，以确保自己没有基于非常少量的数据作出结论。例如，我们查看一下具有最长平均延误时间的飞机（通过机尾编号进行识别）： delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarize( delay &#x3D; mean(arr_delay) )ggplot(data &#x3D; delays, mapping &#x3D; aes(x &#x3D; delay)) + geom_freqpoly(binwidth &#x3D; 10) 接下来，画一张航班数量和平均延误时间的散点图，以便获得更深刻的理解： delays &lt;- not_cancelled %&gt;% group_by (tailnum) %&gt;% #-- 根据 tailnum 对 not_cancelled 分组 summarize ( delay &#x3D; mean (arr_delay, na.rm &#x3D; TRUE), n &#x3D; n () #-- 根据每个组求 arr_delay 的平均值并计数 )# A tibble: 4,037 x 3 tailnum delay n &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 D942DN 31.5 4 2 N0EGMQ 9.98 352 3 N10156 12.7 145 4 N102UW 2.94 48 5 N103US -6.93 46 6 N104UW 1.80 46 7 N10575 20.7 269 8 N105UW -0.267 45 9 N107US -5.73 4110 N108UW -1.25 60# ... with 4,027 more rowsggplot (data &#x3D; delays, mapping &#x3D; aes (x &#x3D; n, y &#x3D; delay)) + geom_point (alpha &#x3D; 1&#x2F;10) 当航班数量非常少时，平均延误时间的变动特别大。这张图的形状非常能够说明问题：当绘制均值（或其他摘要统计量）和分组规模的关系时，你总能看到随着样本量的增加，变动在不断减小。 查看此类图形时，通常应该筛选掉那些观测数量非常少的分组，这样你就可以避免受到特 别小的分组中的极端变动的影响，进而更好地发现数据模式。 &gt; delays %&gt;%+ filter(n &gt; 25) %&gt;%+ ggplot(mapping &#x3D; aes(x &#x3D; n, y &#x3D; delay)) ++ geom_point(alpha &#x3D; 1&#x2F;10) # 3.6.4 常用的摘要函数 只使用均值、计数和求和是远远不够的，R 中还提供了很多其他的常用的摘要函数。 位置度量 我们已经使用过 mean (x)，但 median (x) 也非常有用。均值是总数除以个数；中位数则 是这样一个值：50% 的 x 大于它，同时 50% 的 x 小于它。 &gt; not_cancelled %&gt;%+ group_by (year, month, day) %&gt;%+ summarize (+ # 平均延误时间：+ avg_delay1 &#x3D; mean (arr_delay),+ # 平均正延误时间：+ avg_delay2 &#x3D; mean (arr_delay [arr_delay &gt; 0])+ )&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 5# Groups: year, month [12] year month day avg_delay1 avg_delay2 &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2013 1 1 12.7 32.5 2 2013 1 2 12.7 32.0 3 2013 1 3 5.73 27.7 4 2013 1 4 -1.93 28.3 5 2013 1 5 -1.53 22.6 6 2013 1 6 4.24 24.4 7 2013 1 7 -4.95 27.8 8 2013 1 8 -3.23 20.8 9 2013 1 9 -0.264 25.610 2013 1 10 -5.90 27.3# ... with 355 more rows分散程度度量：sd (x)、IQR (x) 和 mad (x) 均方误差（又称标准误差，standard deviation，sd）是分散程度的标准度量方式。四分位距 IQR () 和绝对中位差 mad (x) 基本等价，更适合有离群点的情况： &gt; # 为什么到某些目的地的距离比到其他目的地更多变？&gt; not_cancelled %&gt;%+ group_by (dest) %&gt;%+ summarize (distance_sd &#x3D; sd (distance)) %&gt;%+ arrange (desc (distance_sd))&#96;summarise ()&#96; ungrouping output (override with &#96;.groups&#96; argument)# A tibble: 104 x 2 dest distance_sd &lt;chr&gt; &lt;dbl&gt; 1 EGE 10.5 2 SAN 10.4 3 SFO 10.2 4 HNL 10.0 5 SEA 9.98 6 LAS 9.91 7 PDX 9.87 8 PHX 9.86 9 LAX 9.6610 IND 9.46# ... with 94 more rows秩的度量：min (x)、quantile (x, 0.25) 和 max (x) 分位数是中位数的扩展。例如，quantile (x, 0.25) 会找出 x 中按从小到大顺序大于前 25% 而小于后 75% 的值： &gt; # 每天最早和最晚的航班何时出发？&gt; not_cancelled %&gt;%+ group_by (year, month, day) %&gt;%+ summarize (+ first &#x3D; min (dep_time),+ last &#x3D; max (dep_time)+ )&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 5# Groups: year, month [12] year month day first last &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 517 2356 2 2013 1 2 42 2354 3 2013 1 3 32 2349 4 2013 1 4 25 2358 5 2013 1 5 14 2357 6 2013 1 6 16 2355 7 2013 1 7 49 2359 8 2013 1 8 454 2351 9 2013 1 9 2 225210 2013 1 10 3 2320# ... with 355 more rows定位度量：first (x)、nth (x, 2) 和 last (x) 这几个函数的作用与 x [1]、x [2] 和 x [length (x)] 相同，只是当定位不存在时（比如尝试从只有两个元素的分组中得到第三个元素），前者允许你设置一个默认值。例如，我们可以找出每天最早和最晚出发的航班： &gt; not_cancelled %&gt;%+ group_by(year, month, day) %&gt;%+ summarize(+ first_dep &#x3D; first(dep_time),+ last_dep &#x3D; last(dep_time)+ )&#96;summarise()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 5# Groups: year, month [12] year month day first_dep last_dep &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 517 2356 2 2013 1 2 42 2354 3 2013 1 3 32 2349 4 2013 1 4 25 2358 5 2013 1 5 14 2357 6 2013 1 6 16 2355 7 2013 1 7 49 2359 8 2013 1 8 454 2351 9 2013 1 9 2 225210 2013 1 10 3 2320# ... with 355 more rows计数 已经使用过 n ()，它不需要任何参数，并返回当前分组的大小。如果想要计算出非缺失值的数量，可以使用 sum (!is.na (x))。要想计算出唯一值的数量，可以使用 n_distinct (x)： &gt; # 哪个目的地具有最多的航空公司？&gt; not_cancelled %&gt;%+ group_by (dest) %&gt;%+ summarize (carriers &#x3D; n_distinct (carrier)) %&gt;%+ arrange (desc (carriers))&#96;summarise ()&#96; ungrouping output (override with &#96;.groups&#96; argument)# A tibble: 104 x 2 dest carriers &lt;chr&gt; &lt;int&gt; 1 ATL 7 2 BOS 7 3 CLT 7 4 ORD 7 5 TPA 7 6 AUS 6 7 DCA 6 8 DTW 6 9 IAD 610 MSP 6# ... with 94 more rows因为计数太常用了，所以 dplyr 提供了一个简单的辅助函数，用于只需要计数的情况： &gt; not_cancelled %&gt;%+ count(dest)# A tibble: 104 x 2 dest n &lt;chr&gt; &lt;int&gt; 1 ABQ 254 2 ACK 264 3 ALB 418 4 ANC 8 5 ATL 16837 6 AUS 2411 7 AVL 261 8 BDL 412 9 BGR 35810 BHM 269# ... with 94 more rows还可以选择提供一个加权变量。例如，你可以使用以下代码算出每架飞机飞行的总里程数（实际上就是求和）： &gt; not_cancelled %&gt;%+ count(tailnum, wt &#x3D; distance)# A tibble: 4,037 x 2 tailnum n &lt;chr&gt; &lt;dbl&gt; 1 D942DN 3418 2 N0EGMQ 239143 3 N10156 109664 4 N102UW 25722 5 N103US 24619 6 N104UW 24616 7 N10575 139903 8 N105UW 23618 9 N107US 2167710 N108UW 32070# ... with 4,027 more rows逻辑值的计数和比例：sum (x&gt; 10) 和 mean (y == 0) 当与数值型函数一同使用时，TRUE 会转换为 1，FALSE 会转换为 0。这使得 sum () 和 mean () 非常适用于逻辑值：sum (x) 可以找出 x 中 TRUE 的数量，mean (x) 则可以找出比例。 &gt; # 多少架航班是在早上 5 点前出发的？（这通常表明前一天延误的航班数量）&gt; not_cancelled %&gt;%+ group_by (year, month, day) %&gt;%+ summarize (n_early &#x3D; sum (dep_time &lt; 500))&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day n_early &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 0 2 2013 1 2 3 3 2013 1 3 4 4 2013 1 4 3 5 2013 1 5 3 6 2013 1 6 2 7 2013 1 7 2 8 2013 1 8 1 9 2013 1 9 310 2013 1 10 3# ... with 355 more rows&gt; # 延误超过 1 小时的航班比例是多少？&gt; not_cancelled %&gt;%+ group_by (year, month, day) %&gt;%+ summarize (hour_perc &#x3D; mean (arr_delay &gt; 60))&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day hour_perc &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 0.0722 2 2013 1 2 0.0851 3 2013 1 3 0.0567 4 2013 1 4 0.0396 5 2013 1 5 0.0349 6 2013 1 6 0.0470 7 2013 1 7 0.0333 8 2013 1 8 0.0213 9 2013 1 9 0.020210 2013 1 10 0.0183# ... with 355 more rows# 3.6.5 按多个变量分组 当使用多个变量进行分组时，每次的摘要统计会用掉一个分组变量。这样就可以轻松地对数据集进行循序渐进的分析 &gt; daily &lt;- group_by (flights, year, month, day)&gt; (per_day &lt;- summarize (daily, flights &#x3D; n ()))&#96;summarise ()&#96; regrouping output by &#39;year&#39;, &#39;month&#39; (override with &#96;.groups&#96; argument)# A tibble: 365 x 4# Groups: year, month [12] year month day flights &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 842 2 2013 1 2 943 3 2013 1 3 914 4 2013 1 4 915 5 2013 1 5 720 6 2013 1 6 832 7 2013 1 7 933 8 2013 1 8 899 9 2013 1 9 90210 2013 1 10 932# ... with 355 more rows&gt; (per_month &lt;- summarize (per_day, flights &#x3D; sum (flights)))&#96;summarise ()&#96; regrouping output by &#39;year&#39; (override with &#96;.groups&#96; argument)# A tibble: 12 x 3# Groups: year [1] year month flights &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 27004 2 2013 2 24951 3 2013 3 28834 4 2013 4 28330 5 2013 5 28796 6 2013 6 28243 7 2013 7 29425 8 2013 8 29327 9 2013 9 2757410 2013 10 2888911 2013 11 2726812 2013 12 28135# 可以发现 day 分组已经消失# 3.6.6 取消分组 如果想要取消分组，并回到未分组的数据继续操作，那么可以使用 ungroup () 函数： &gt; daily %&gt;%+ ungroup () %&gt;% # 不再按日期分组+ summarize (flights &#x3D; n ()) # 所有航班# A tibble: 1 x 1 flights &lt;int&gt;1 336776# 3.7 分组新变量 虽然与 summarize () 函数结合起来使用是最有效的，但分组也可以与 mutate () 和 filter () 函数结合，以完成非常便捷的操作。 找出每个分组中最差的成员： &gt; flights_sml %&gt;%+ group_by(year, month, day) %&gt;%+ filter(rank(desc(arr_delay)) &lt; 10)# A tibble: 3,306 x 7# Groups: year, month, day [365] year month day dep_delay arr_delay distance air_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2013 1 1 853 851 184 41 2 2013 1 1 290 338 1134 213 3 2013 1 1 260 263 266 46 4 2013 1 1 157 174 213 60 5 2013 1 1 216 222 708 121 6 2013 1 1 255 250 589 115 7 2013 1 1 285 246 1085 146 8 2013 1 1 192 191 199 44 9 2013 1 1 379 456 1092 22210 2013 1 2 224 207 550 94# ... with 3,296 more rows找出大于某个阈值的所有分组： &gt; popular_dests &lt;- flights %&gt;%+ group_by(dest) %&gt;%+ filter(n() &gt; 365)&gt; popular_dests# A tibble: 332,577 x 19# Groups: dest [77] year month day dep_time sched_dep_time dep_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 2 2013 1 1 533 529 4 3 2013 1 1 542 540 2 4 2013 1 1 544 545 -1 5 2013 1 1 554 600 -6 6 2013 1 1 554 558 -4 7 2013 1 1 555 600 -5 8 2013 1 1 557 600 -3 9 2013 1 1 557 600 -310 2013 1 1 558 600 -2# ... with 332,567 more rows, and 13 more variables:# arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,# carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,# dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,# minute &lt;dbl&gt;, time_hour &lt;dttm&gt;对数据进行标准化以计算分组指标： &gt; popular_dests %&gt;%+ filter(arr_delay &gt; 0) %&gt;%+ mutate(prop_delay &#x3D; arr_delay &#x2F; sum(arr_delay)) %&gt;%+ select(year:day, dest, arr_delay, prop_delay)# A tibble: 131,106 x 6# Groups: dest [77] year month day dest arr_delay prop_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2013 1 1 IAH 11 0.000111 2 2013 1 1 IAH 20 0.000201 3 2013 1 1 MIA 33 0.000235 4 2013 1 1 ORD 12 0.0000424 5 2013 1 1 FLL 19 0.0000938 6 2013 1 1 ORD 8 0.0000283 7 2013 1 1 LAX 7 0.0000344 8 2013 1 1 DFW 31 0.000282 9 2013 1 1 ATL 12 0.000040010 2013 1 1 DTW 16 0.000116# ... with 131,096 more rows","tags":"r_study r_for_data_science"},{"title":"R数据科学笔记：1","url":"/2020/07/22/2020-07-22-R4ds1/","text":"最近把之前的《R 数据科学》的笔记整理一下，大概每篇文章整理 2-3 章，这本书有中英文两版，不知道为什么中文版比英文版少了一章，而且一些关键内容也有所删减，所以大家学习这本书的时候以英文版为准。 电子书下载地址：《R4ds》 源代码地址：https://github.com/hadley/r4ds # 作者简介： 哈德利・威克姆（Hadley Wickham） RStudio 首席科学家，统计学家，斯坦福大学、奥克兰大学、莱斯大学兼职统计学教授。已被下载数百万次的 ggplot2 等多款知名 R 包的开发者，一直致力于让普罗大众更容易上手数据分析，被 R 社区誉为 “改变了 R 的人”。另著有《R 包开发》等书。 加勒特・格罗勒芒德（Garrett Grolemund） RStudio 数据科学家，知名 R 培训师，曾受邀在 Google、eBay 等诸多公司讲授 R 语言和数据科学，在 DataCamp 开授的 R 相关课程备受 R 开发者喜爱。另著有《R 语言入门与实践》。 # 第一章：使用 ggplot2 进行数据可视化 # 1.1 简介 准备工作 本章重点讨论 tidyverse 的一个核心 R 包 ——ggplot2。为了访问本章用到的数据集、帮助页面和函数，需要先运行以下代码来加载 tidyverse install.packages(&quot;tidyverse&quot;)library(tidyverse)# 1.2 第一步 我们使用第一张图来回答问题：大引擎汽车比小引擎汽车更耗油吗？你可能已经有了答案，但应该努力让答案更精确一些。引擎大小与燃油效率之间是什么关系？是正相关，还是负相关？是线性关系，还是非线性关系？ # 1.2.1 mpg 数据框 你可以使用 ggplot2 包中的 mpg 数据框（即 ggplot2::mpg）来检验自己的答案。数据框是变量（列）和观测（行）的矩形集合。mpg 包含了由美国环境保护协会收集的 38 种车型的观测数据。 &gt; mpg# A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto~ f 18 29 p 2 audi a4 1.8 1999 4 manu~ f 21 29 p 3 audi a4 2 2008 4 manu~ f 20 31 p 4 audi a4 2 2008 4 auto~ f 21 30 p 5 audi a4 2.8 1999 6 auto~ f 16 26 p 6 audi a4 2.8 1999 6 manu~ f 18 26 p 7 audi a4 3.1 2008 6 auto~ f 18 27 p 8 audi a4 q~ 1.8 1999 4 manu~ 4 18 26 p 9 audi a4 q~ 1.8 1999 4 auto~ 4 16 25 p 10 audi a4 q~ 2 2008 4 manu~ 4 20 28 p # ... with 224 more rows, and 1 more variable: class &lt;chr&gt;mpg 中包括如下变量。 ・displ：引擎大小，单位为升。 ・hwy：汽车在高速公路上行驶时的燃油效率，单位为英里 / 加仑（mpg）。与燃油效率高的汽车相比，燃油效率低的汽车在行驶相同距离时要消耗更多燃油。要想了解更多关于 mpg 的信息，可以使用？mpg 命令打开其帮助页面。 # 1.2.2 创建 ggplot 图形 为了绘制 mpg 的图形，运行以下代码将 displ 放在 x 轴，hwy 放在 y 轴： ggplot(data &#x3D; mpg) +geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) 上图显示出引擎大小（displ）和燃油效率（hwy）之间是负相关关系。换句话说，大引擎汽车更耗油。 在 ggplot2 中，你可以使用 ggplot () 函数开始绘图。ggplot () 创建了一个坐标系，你可以在它上面添加图层。ggplot () 的第一个参数是要在图中使用的数据集。ggplot (data = mpg) 会创建一张空白图，因为这张图没什么意思，所以就不在这里展示了。 函数 geom_point () 向图中添加一个点层，这样就可以创建一张散点图。ggplot2 中包含了多种几何对象函数，每种函数都可以向图中添加不同类型的图层。 ggplot2 中的每个几何对象函数都有一个 mapping 参数。这个参数定义了如何将数据集中的变量映射为图形属性。mapping 参数总是与 aes () 函数成对出现，aes () 函数的 x 参数和 y 参数分别指定了映射到 x 轴的变量与映射到 y 轴的变量。ggplot2 在 data 参数中寻找映射变量，本例中就是 mpg。 # 1.2.3 绘图模板 将上面的代码转换为一个可重用的 ggplot2 绘图模板。要想生成一张图，将以下代码中的尖括号部分替换为数据集、几何对象函数或映射集合即可： ggplot(data &#x3D; &lt;DATA&gt;) +&lt;GEOM_FUNCTION&gt;(mapping &#x3D; aes(&lt;MAPPINGS&gt;))# 1.2.4 练习 (1) 运行 ggplot (data = mpg)，你会看到什么？ 一片空白 (2) 数据集 mpg 中有多少行？多少列？ 234 行 11 列 (3) 变量 drv 的意义是什么？使用？mpg 命令阅读帮助文件以找出答案。 传动系的类型，其中 f = 前轮驱动，r = 后轮驱动，4 = 4wd (4) 使用 hwy 和 cyl 绘制一张散点图。 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; cyl, y &#x3D; hwy)) (5) 如果使用 class 和 drv 绘制散点图，会发生什么情况？为什么这张图没什么用处？ ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; class, y &#x3D;drv)) 车的类型与驱动类型之间没有对应关系，或者说两者无法发生关系。 # 1.3 图形属性映射 The greatest value of a picture is when it forces us to notice what we never expected to see. —John Tukey 下图中有一组点（显示为红色）似乎位于线性趋势之外。这些汽车比预期具有更高的里程数。 假设这些汽车是混合动力车。检验这种假设的一个方法是查看每辆汽车的 class 值。mpg 数据集中的 class 变量对汽车进行了分类，比如小型、中型和 SUV。如果那些离群点是混合动力车，那么它们应该分类为小型车，也可能是微型车（注意，这份数据是在混合动力车和 SUV 流行前收集的）。 可以向二维散点图中添加第三个变量，比如 class，方式是将它映射为图形属性。图形属性是图中对象的可视化属性，其中包括数据点的大小、形状和颜色。通过改变图形属性的值，可以用不同的方式来显示数据点（如下图所示）。因为已经使用 “value” 这个词来表示数据的值，所以下面使用 “level”（水平）这个词来表示图形属性的值。我们来改变一个点的大小、形状和颜色来反映不同属性。 通过将图中的图形属性映射为数据集中的变量，可以传达出数据的相关信息。例如，可以将点的颜色映射为变量 class，从而揭示每辆汽车的类型： 要想将图形属性映射为变量，需要在函数 aes () 中将图形属性名称和变量名称关联起来。ggplot2 会自动为每个变量值分配唯一的图形属性水平（本例中是唯一的颜色），这个过程称为标度变换。ggplot2 还会添加一个图例，以表示图形属性水平和变量值之间的对应关系。 也可以用同样的方式将其映射为点的大小。在下面的示例中，每个点的实际大小表示其所属的类别。这里我们收到一条警告信息，因为将无序变量（class）映射为有序图形属性（size）可不是好主意。 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, size &#x3D; class))Warning message:Using size for a discrete variable is not advised. 或者我们也可以将 class 映射为控制数据点透明度的 alpha 图形属性，还可以将其映射为点的形状。 # 上图ggplot (data &#x3D; mpg) + geom_point (mapping &#x3D; aes (x &#x3D; displ, y &#x3D; hwy, alpha &#x3D; class))# 下图ggplot (data &#x3D; mpg) + geom_point (mapping &#x3D; aes (x &#x3D; displ, y &#x3D; hwy, shape &#x3D; class)) SUV 怎么了？ ggplot2 只能同时使用 6 种形状。默认情况下，当使用这种图形属性时，多出的变量值将不会出现在图中。 一旦映射了图形属性，ggplot2 会处理好其余的事情。它会为图形属性选择一个合适的标度，并创建图例来表示图形属性水平和变量值之间的映射关系。ggplot2 不会为 x 和 y 这两个图形属性创建图例，而会创建带有刻度标记和标签的坐标轴。坐标轴就相当于图例，可以体现出位置和变量值之间的映射关系。 还可以手动为几何对象设置图形属性。例如，我们可以让图中的所有点都为蓝色： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) 此时颜色不会传达关于变量的信息，只是改变图的外观。要想手动设置图形属性，需要按名称进行设置，将其作为几何对象函数的一个参数。这也就是说，需要在函数 aes () 的外部进行设置。此外，还需要为这个图形属性选择一个有意义的值。 ・颜色名称是一个字符串。 ・点的大小用毫米表示。 ・点的形状是一个数值，如图 1-1 所示。有些形状相同，比如 0、15 和 22 都是正方形。 形状之间的区别在于 color 和 fill 这两个图形属性。空心形状（0~14）的边界颜色由 color 决定；实心形状（15~20）的填充颜色由 color 决定；填充形状（21~24）的边界颜色由 color 决定，填充颜色由 fill 决定。 &lt;center&gt; 用数值进行标识的 R 的 25 种内置形状 &lt;/center&gt; # 练习 (1) 以下这段代码有什么错误？为什么点不是蓝色的？ ggplot(data &#x3D; mpg) +geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, color &#x3D; &quot;blue&quot;))color 在 mapping 的括号里面，成为了图形属性映射 (2) mpg 中的哪些变量是分类变量？哪些变量是连续变量？（提示：输入？mpg 来阅读这个数据集的文档。）当调用 mpg 时，如何才能看到这些信息？ 在每一列的下方有 &lt;chr&gt; 和 &lt; int &gt; 两个属性，其中 &lt; chr &gt; 是分类变量，&lt;int &gt; 是连续变量 (3) 将一个连续变量映射为 color、size 和 shape。对分类变量和连续变量来说，这些图形属性的表现有什么不同？ ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, color &#x3D; hwy)) 颜色是一个渐变色，大小也是渐变，形状会报错 (4) 如果将同一个变量映射为多个图形属性，会发生什么情况？ 两种属性会结合，例如颜色和大小 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, size &#x3D; class, color&#x3D;class)) (5) stroke 这个图形属性的作用是什么？它适用于哪些形状？（提示：使用？geom_point 命令。） 改变形状的边框的大小 (6) 如果将图形属性映射为非变量名对象，比如 aes (color = displ &lt; 5)，会发生什么情况？ Error: geom_point requires the following missing aesthetics: x and y # 1.4 常见问题 当开始运行 R 代码时，你很可能会遇到问题。不用担心，每个人都会遇到问题。首先，将你需要运行的代码与书中的代码进行仔细对比。R 极其挑剔，即使一个字母放错了位置，也可能会造成问题。确保每个 (都有一个) 与之匹配，并且每个 &quot;后面都跟着另一个&quot;。有时运行了代码却什么也没有发生。检查一下控制台左侧：如果有一个 + 号，那么说明 R 认为你没有输入完整的表达式，正在等待你完成输入。这种情况下，按 Esc 键中止当前执行的命令就可以重新开始。 创建 ggplot2 图形时的一个常见问题是将 + 号放错了位置：+ 必须放在一行代码的末尾，而不是开头。 # 1.5 分面 添加额外变量的一种方法是使用图形属性。另一种方法是将图分割成多个分面，即可以显示数据子集的子图。这种方法特别适合添加分类变量。 要想通过单个变量对图进行分面，可以使用函数 facet_wrap ()。其第一个参数是一个公式，创建公式的方式是在～符号后面加一个变量名（这里所说的 “公式” 是 R 中的一种数据结构，不是数学意义上的公式）。传递给 facet_wrap () 的变量应该是离散型的。 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy),stroke&#x3D;1.5) + facet_wrap(~ class, nrow &#x3D; 2)要想通过两个变量对图进行分面，需要在绘图命令中加入函数 facet_grid ()。这个函数的第一个参数也是一个公式，但该公式包含由～隔开的两个变量名。 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) + facet_grid(drv ~ cyl) 如果不想在行或列的维度进行分面，你可以使用。来代替变量名，例如 + facet_grid (. ~cyl)。 # 练习 (1) 如果使用连续变量进行分面，会发生什么情况？ ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) + facet_grid(~ cty) (2) 在使用 facet_grid (drv ~ cyl) 生成的图中，空白单元的意义是什么？它们和以下代码生成的图有什么关系？ 虽然空白单元没有数据，但也代表了一种组合 ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; drv, y &#x3D; cyl))这张图生成的是没有意义的图，每个点代表每种组合，facet_grid (drv ~ cyl) 生成的图则将每个组合中 displ 和 hwy 之间的关系表现了出来。 (3) 以下代码会绘制出什么图？ . 的作用是什么？ ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) + facet_grid(drv ~ .) ggplot(data &#x3D; mpg) +geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) +facet_grid(. ~ cyl) . 的作用决定了分布方向，如果前面出现、纵向分布，反之为横向分布 (4) 查看本节的第一个分面图： ggplot(data &#x3D; mpg) +geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) +facet_wrap(~ class, nrow &#x3D; 2)与使用图形属性相比，使用分面的优势和劣势分别是什么？如果有一个更大的数据集， 你将如何权衡这两种方法的优劣？ 使用分面能更好的体现出每个类别 displ 与 hwy 的关系，但是没办法比较不同类别之间的区别 使用属性能更好的体现整体的关系，但是个体差异不明显 # 1.6 几何对象 两张图有同样的 x 变量和 y 变量，而且描述的是同样的数据。但这两张图并不一样，它们各自使用不同的可视化对象来表示数据。在 ggplot2 语法中，我们称它们使用了不同的几何对象。 几何对象是图中用来表示数据的几何图形对象。我们经常根据图中使用的几何对象类型来描述相应的图。例如，条形图使用了条形几何对象，折线图使用了直线几何对象，箱线图使用了矩形和直线几何对象。散点图打破了这种趋势，它们使用点几何对象。如上面的两幅图所示，我们可以使用不同的几何对象来表示同样的数据。左侧的图使用了点几何对象，右侧的图使用了平滑曲线几何对象，以一条平滑曲线来拟合数据。要想改变图中的几何对象，需要修改添加在 ggplot () 函数中的几何对象函数。举例来说，要想绘制出上图，你可以使用以下代码： # 左图ggplot (data &#x3D; mpg) +geom_point (mapping &#x3D; aes (x &#x3D; displ, y &#x3D; hwy))# 右图ggplot (data &#x3D; mpg) +geom_smooth (mapping &#x3D; aes (x &#x3D; displ, y &#x3D; hwy))ggplot2 中的每个几何对象函数都有一个 mapping 参数。但是，不是每种图形属性都适合每种几何对象。你可以设置点的形状，但不能设置线的 “形状”，而可以设置线的线型。geom_smooth () 函数可以按照不同的线型绘制出不同的曲线，每条曲线对应映射到线型的变量的一个唯一值： ggplot(data &#x3D; mpg) +geom_smooth(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, linetype &#x3D; drv)) 根据表示汽车驱动系统的 drv 变量的值，这里的 geom_smooth () 函数分别用 3 条曲线来表示汽车。一条线表示 drv 值为 4 的所有汽车，一条线表示 drv 值为 f 的所有汽车，另一条线表示 drv 值为 r 的所有汽车。其中 4 表示四轮驱动，f 表示前轮驱动，r 表示后轮驱动。如果你觉得这有些难以理解，我们可以将这些曲线覆盖在原始数据上，并按照 drv 值对所有的点和线进行着色，这样你就能看得更清楚一些了。 要想在同一张图中显示多个几何对象，可以向 ggplot () 函数中添加多个几何对象函数： ggplot(data &#x3D; mpg) + geom_point(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) + geom_smooth(mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) 但是，这样代码就产生了一些重复。假如你想将 y 轴上的变量从 hwy 改成 cty，那么就要在两个地方修改这个变量，但你或许会漏掉一处。避免这种重复的方法是将一组映射传递给 ggplot () 函数。ggplot2 会将这些映射作为全局映射应用到图中的每个几何对象中。 ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) +geom_point() +geom_smooth()如果将映射放在几何对象函数中，那么 ggplot2 会将其看作这个图层的局部映射，它将使用这些映射扩展或覆盖全局映射，但仅对该图层有效。这样一来，我们就可以在不同的图层中显示不同的图形属性： ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) +geom_point(mapping &#x3D; aes(color &#x3D; class)) +geom_smooth() 同理，你也可以为不同的图层指定不同的数据。下图中的平滑曲线表示的只是 mpg 数据集的一个子集，即微型车。geom_smooth () 函数中的局部数据参数覆盖了 ggplot () 函数中的全局数据参数，当然仅对这个图层有效： ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) +geom_point(mapping &#x3D; aes(color &#x3D; class)) +geom_smooth(data &#x3D; filter(mpg, class &#x3D;&#x3D; &quot;subcompact&quot;),se &#x3D; FALSE) # 练习 (1) 在绘制折线图、箱线图、直方图和分区图时，应该分别使用哪种几何对象？ 折线图使用了直线几何对象，箱线图使用了矩形和直线几何图像、直方图使用了使用了矩形几何对象 (2) 在脑海中运行以下代码，并预测会有何种输出。接着在 R 中运行代码，并检查你的预测是否正确。 ggplot( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy, color &#x3D; drv)) + geom_point() + geom_smooth(se &#x3D; FALSE) (3) show.legend = FALSE 的作用是什么？删除它会发生什么情况？你觉得我为什么要在本章前面的示例中使用这句代码？ sohw.legend=FLASE 去掉图例 (4) geom_smooth () 函数中的 se 参数的作用是什么？ se 如果设定为 TRUE，则会为曲线设定置信区间，FLASE 则没有置信区间 (6) 自己编写 R 代码来生成以下各图。 #######1ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy)) + geom_point() + geom_smooth(se&#x3D;FALSE)#######2ggplot() + geom_point( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy) ) + geom_smooth( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,group&#x3D;drv),se&#x3D;FALSE)#######3ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,color&#x3D;drv)) + geom_point() + geom_smooth(se &#x3D; FALSE)#######4ggplot() + geom_point( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,color&#x3D;drv) ) + geom_smooth( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy),se&#x3D;FALSE)######5ggplot() + geom_point( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,color&#x3D;drv) ) + geom_smooth( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,linetype&#x3D;drv),se&#x3D;FALSE)######6ggplot() + geom_point( data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; displ, y &#x3D; hwy,color&#x3D;drv))# 1.7 统计变换 接下来我们看一下条形图。条形图虽然简单，但很有意思，因为它可以揭示出图形中的一些微妙信息。我们看一下用 geom_bar () 函数就可以绘制的基本条形图。下面的条形图显示了 diamonds 数据集中按照 cut 变量分组的各种钻石的总数量。diamonds 数据集是 ggplot2 的内置数据集，包含大约 54 000 颗钻石的信息，每颗钻石具有 price、carat、color、clarity 和 cut 变量。条形图显示，高质量切割钻石的数量要比低质量切割钻石的数量多： ggplot(data &#x3D; diamonds) + geom_bar(mapping &#x3D; aes(x &#x3D; cut)) 条形图 x 轴显示的是 cut，这是 diamonds 数据集中的一个变量。y 轴显示的是 count，但 count 不是 diamonds 中的变量！那么 count 来自哪里呢？很多图形绘制的是数据集的原始数据，比如散点图。另外一些图形则可以绘制那些计算出的新数据，比如条形图。 ・条形图、直方图和频率多边形图可以对数据进行分箱，然后绘制出分箱数量和落在每个分箱的数据点的数量。 ・平滑曲线会为数据拟合一个模型，然后绘制出模型预测值。 ・箱线图可以计算出数据分布的多种摘要统计量，并显示一个特殊形式的箱体。 绘图时用来计算新数据的算法称为 stat（statistical transformation，统计变换）。下图描述了 geom_bar () 函数的统计变换过程。 通常来说，几何对象函数和统计变换函数可以互换使用。例如，你可以使用 stat_count () 替换 geom_bar () 来重新生成前面那张图： ggplot(data &#x3D; diamonds) +stat_count(mapping &#x3D; aes(x &#x3D; cut))你可能想要覆盖从统计变换生成的变量到图形属性的默认映射。例如，你或许想显示一张表示比例（而不是计数）的条形图： ggplot(data &#x3D; diamonds) +geom_bar(mapping &#x3D; aes(x &#x3D; cut, y &#x3D; ..prop.., group &#x3D; 1)) 你可能想要在代码中强调统计变换。例如，你可以使用 stat_summary () 函数将人们的注意力吸引到你计算出的那些摘要统计量上。stat_summary () 函数为 x 的每个唯一值计算 y 值的摘要统计： ggplot2 提供了 20 多个统计变换以供你使用。每个统计变换都是一个函数，因此你可以按照通用方式获得帮助，例如？stat_bin。如果想要查看全部的统计变换，可以使用 ggplot2 速查表。 # 练习 (1) stat_summary () 函数的默认几何对象是什么？不使用统计变换函数的话，如何使用几何对象函数重新生成以上的图？ geom_pointrange， (2) geom_col () 函数的功能是什么？它和 geom_bar () 函数有何不同？ 直方图，其中柱状图的高度表示数据中的值，geom_col () 的默认统计变换为 identity ()，geom_bar () 默认为 count () # 1.8 位置调整 可以使用 color 或者 fill（这个更有用）图形属性来为条形图上色： ggplot(data &#x3D; diamonds) +geom_bar(mapping &#x3D; aes(x &#x3D; cut, color &#x3D; cut))ggplot(data &#x3D; diamonds) +geom_bar(mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; cut)) 如果将 fill 图形属性映射到另一个变量（如 clarity），那么条形会自动分块堆叠起来。每个彩色矩形表示 cut 和 clarity 的一种组合。 ggplot(data &#x3D; diamonds) +geom_bar(mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; clarity)) 这种堆叠是由 position 参数设定的位置调整功能自动完成的。如果不想生成堆叠式条形图，你还可以使用以下 3 种选项之一：&quot;identity&quot;、&quot;fill&quot; 和 &quot;dodge&quot;。 ・position = &quot;identity&quot; 将每个对象直接显示在图中。这种方式不太适合条形图，因为条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置 alpha 参数为一个较小的数，从而使得条形略微透明；或者设定 fill = NA，让条形完全透明： ggplot( data &#x3D; diamonds, mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; clarity)) + geom_bar(alpha &#x3D; 1&#x2F;5, position &#x3D; &quot;identity&quot;)ggplot( data &#x3D; diamonds, mapping &#x3D; aes(x &#x3D; cut, color &#x3D; clarity)) + geom_bar(fill &#x3D; NA, position &#x3D; &quot;identity&quot;) ・position = &quot;fill&quot; 的效果与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例： ggplot(data &#x3D; diamonds) + geom_bar( mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; clarity), position &#x3D; &quot;fill&quot; ) ・position = &quot;dodge&quot; 将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形表示的具体数值： ggplot(data &#x3D; diamonds) + geom_bar( mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; clarity), position &#x3D; &quot;dodge&quot; ) 回忆一下我们的第一张散点图。你是否发现，虽然数据集中有 234 个观测值，但散点图中只显示了 126 个点？ 因为 hwy 和 displ 的值都进行了舍入取整，所以这些点显示在一个网格上时，很多点彼此重叠了。这个问题称为过绘制。点的这种排列方式很难看出数据的聚集模式。数据点是均匀地分布在图中，还是存在 hwy 和 displ 的特殊组合，其中包括了 109 个点？ 通过将位置调整方式设为 “抖动”，可以避免这种网格化排列。position = &quot;jitter&quot; 为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来，因为不可能有两个点会收到同样的随机扰动： 添加随机性来改善图形似乎是一种奇怪的方式，然而尽管这种方式会损失图形的精确性，但可以大大提高图形的启发性。因为这种操作的用处非常大，所以 ggplot2 提供了 geom_point (position = &quot;jitter&quot;) 的一种快速实现方式：geom_jitter ()。 # 1.9 坐标系 坐标系可能是 ggplot2 中最复杂的部分。默认的坐标系是笛卡儿直角坐标系，可以通过其独立作用的 x 坐标和 y 坐标找到每个数据点。偶尔也会用到一些其他类型的坐标系。 ・coord_flip () 函数可以交换 x 轴和 y 轴。当想要绘制水平箱线图时，这非常有用。它也非常适合使用长标签，但要想在 x 轴上不重叠地安排好它们是非常困难的： ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; class, y &#x3D; hwy)) +geom_boxplot()ggplot(data &#x3D; mpg, mapping &#x3D; aes(x &#x3D; class, y &#x3D; hwy)) +geom_boxplot() +coord_flip() ・coord_polar () 函数使用极坐标系。极坐标系可以揭示出条形图和鸡冠花图间的一种有趣联系： bar &lt;- ggplot(data &#x3D; diamonds) + geom_bar( mapping &#x3D; aes(x &#x3D; cut, fill &#x3D; cut), show.legend &#x3D; FALSE, width &#x3D; 1 ) + theme(aspect.ratio &#x3D; 1) + labs(x &#x3D; NULL, y &#x3D; NULL)p1&lt;-bar + coord_flip()p2&lt;-bar + coord_polar()ggarrange(p1, p2) # 1.10 图形分层语法 在前面几节中，你学到的绝不仅仅是如何绘制散点图、条形图和箱线图，而是使用 ggplot2 绘制任何类型图形的基础知识。为了说明这一点，我们向前面的代码模板中添加位置调整、统计变换、坐标系和分面： ggplot(data &#x3D; &lt;DATA&gt;) +&lt;GEOM_FUNCTION&gt;(mapping &#x3D; aes(&lt;MAPPINGS&gt;),stat &#x3D; &lt;STAT&gt;,position &#x3D; &lt;POSITION&gt;) +&lt;COORDINATE_FUNCTION&gt; +&lt;FACET_FUNCTION&gt;为了说明图形语法的工作方式，我们看一下如何从头开始构建一个基本图形：首先需要有一个数据集，然后（通过统计变换）将其转换为想要显示的信息。 接下来，你可以选择一个几何对象来表示转换后的数据中的每个观测值，然后选择几何对象的图形属性来表示数据中的变量，这会将每个变量的值映射为图形属性的水平。 下一步是选择放置几何对象的坐标系。你可以使用对象位置（对象本身的一个图形属性）来显示 x 变量和 y 变量的值。这样就生成了一张完整的图。但你还可以进一步调整几何对象在坐标系中的位置（位置调整），或者将图划分为多个子图（分面）。你还可以通过添加一个或多个附加图层对图进行扩展，其中每个附加图层都使用一个数据集、一个几何对象、一个映射集合、一个统计变换和一个位置调整。 转载请注明周小钊的博客 &gt;&gt;R4ds1","tags":"r_study r_for_data_science"},{"title":"文献导读：真菌进化","url":"/2020/07/20/2020-07-20-fungi/","text":"最近在做地衣（真菌与藻类的共生体）的相关课题，对于真菌理解的较少，于是选择 2019 年发表在 Biological Reviews 上的文献进行阅读，文献比较长，耗费很长时间看完，而且在阅读过程中主要侧重于植物方面 # 摘要 真菌是一种高度多样化的异养真核生物，其特征是没有吞噬营养（phagotrophy）和有几丁质（chitinous）细胞壁。虽然单细胞（unicellular）真菌非常常见，但该群体进化成功的部分原因在于它们能够无限期地生长为圆柱形多核细胞（hypha）。有了这些形态特征和极高的代谢多样性，真菌已经征服了许多生态位，并形成了一个与其他生物相互作用的世界。本篇文献主要调查了主导真菌多样性的主要进化和生态过程。首先回顾孢子谱系的生态学和进化以及陆生化（terrestrialization）的过程，作为这个王国的主要进化转变之一。对于真菌的陆生化，已经提出了几个可行的设想，在本次研究中提出了一个新的设想，即把冰环境看作是水和陆地之间的一个过渡的小生境。然后，将重点探讨真菌与其他生物体 (其他真菌、原生动物、动物和植物) 的主要生态关系，以及适应群体内特定生态位（地衣、黑真菌和酵母）的起源。在这篇综述中，使用进化和比较基因组学的观点来理解真菌的生态多样性。最后，我们强调了基因组推断（genome-enabled inferences）的重要性，为重要的转变设想合理的叙述和场景。 # Ⅰ: 引言 真菌界是一个高度多样化的真核生物分支，几乎存在于所有环境中，特别是在陆地生态系统中。真菌在营养循环中起着关键作用，可以充当无数其他生物的捕食者、病原体和寄生物，并且可以与植物、藻类、动物和其他生物共生。一些重要的真菌类群（主要是蘑菇和地衣）产生的肉眼可见的（macroscopic）结构一直是形态学、细胞学和生物化学研究的重点。除这些之外大多数真菌是通过基于培养的微生物学技术或通过评估它们在宿主或共生伙伴身上产生的症状和特殊结构来进行研究的。在过去的二十年里，基因组革命对真菌学领域产生了积极的影响，基因组和转录组测序的出现使几乎所有真菌类群的研究成为可能，这反映在一个爆炸性的研究中，涵盖了越来越多来自不同谱系的真菌物种，同时环境测序研究揭示了真菌生物学的一个新维度。在过去的二十年里，基于条形码的方法被用于研究环境真菌群落的特殊成分的多样性，例如外生菌根真菌；或者评估特定环境中的真菌成分。真菌学已经开始接受单细胞技术的使用，尽管暂时由于丝状生长与细胞分类方法不兼容。每一种方法都有其特定的局限性，但它们共同提供了一个关于真菌在哪里，它们是谁，以及它们是如何变成现在这个样子的一个新画面。 大多数真菌以菌丝体的形式生活。真菌一般通过固体基质生长，利用胞外酶和蛮力挖掘基质，开发其周围的资源。此外，它们通过分泌有毒化合物杀死其他微生物来控制自己的领地。真菌有一个发育良好的分泌体（secretome），使它们能够从高度聚合且通常非常疏水的化合物中提取营养物质，例如纤维素或木质素（cellulose or lignin），这对其他微生物来说非常困难。在这篇综述中，综合了目前关于真菌主要的生态适应和进化转变的知识。把进化的转变定义为在一个新的，完全不同于以前的状态的生活方式谱系中的获得。这类转变的例子包括从自由生活的祖先那里获得寄生的生活方式，建立共生关系（例如地衣）。如果可能的话，将这种转变置于一个进化的框架内，解释游动孢子（zoosporic）真菌是如何从能动的真核寄生物（motile eukaryvorous parasitoids）进化到霉菌（moulds）的，以及不同的真菌群体如何从这两种生活方式中形成与其他生物群的关系，并适应新的生态环境。综述将着重描述每种生态生活方式的表型和基因组概貌、分类学多样性、进化趋势和与文化无关的环境信息。 # Ⅱ:in the beginning，早期真菌进化 推测最后的共同真菌祖先 (last common fungal ancestor ：LCFA) 的潜在生活方式是具有挑战性的。根据宏基因组研究，真菌的姊妹类群核仁类是海洋环境中常见的是变形原生动物，核菌纲。在大多数分子年代测定分析中，真菌的年龄比陆地生物的化石证据还要早，表明真菌可能起源于海洋。然而，所有已知的现存真菌谱系显然主要是大陆的，要么是真正的陆地的，要么是与非海洋水体相关的。原始真菌必须主要是水生的，然而，因为所有陆生真菌都形成了一个明显的单系分支，并且可以推断鞭毛（flagellum）的单一缺失。因此，要么真菌起源于大陆水体，要么失去了关键的海洋血统。根据环境研究，早期分支谱系 Aphelida、Rozellida 和壶菌 (Chytridiomycota) 在海洋环境中表现出高度的多样性，而一些高度多样化的海洋壶菌谱系似乎是最早出现分化的，这表明我们可能接近于找到缺失的一环。然而，需要注意的是，壶菌系统发育和它在真菌生命树中的位置仍然没有很好地解决。 从生态学角度讲，寄生生物的生活方式将后孢菌（Opisthosporidia）, 壶菌门（Chytridiomycota） 和 Blastocladiomycota 结合在一起（图 1）。这表明所有真菌的祖先可能是微藻的寄生体，具有吞噬能力，同时具有变形虫和鞭毛的运动性，至少在某些生命阶段具有几丁质细胞壁，这一套适应性进化将真菌从剩余的菌物总界（Holomycota）分支中分离出来。在这一前提下，早期的 Aphelidea 和 Rozellida 可能与不同的藻类和原生动物群有关，而其他同时代谱系的祖先可能大多生活在绿藻门（Chlorophyta）的寄生生物中。真菌可能涉及碳水化合物活性酶（CAZy）的发展，这是大多数真菌谱系的特征，穿透固体表面和消化纤维素和其他生物聚合物的能力促进了生活方式从寄生到腐生的转变，具有寄生生物生活方式的特征则很少使用，所以这使得它们保存在化石记录中的可能性降低。然而，新元古代（neoproterozoic）真核生物的间接证据已经被发现，与动孢子（zoosporic ）真菌拟寄生的生活方式相一致，所以未来对动孢子菌及其变形虫姊妹谱系的基因组比较分析可能会为这一时期的真菌进化提供新的见解。 # Ⅲ:down to earth，真菌的陆地化 真菌最明确的进化特性性是对陆地环境的适应（陆地化），包括菌丝生长的发育和鞭毛的丧失（图 1）。菌丝的发育对感染更大有机体和在腐生生活方式中增加接触面积是必要的。分泌消化酶和优先在菌丝顶端表达丰富的膜转运蛋白的能力，可以理解为生物体祖先掠夺生活方式的直接结果，这种掠夺生活方式必须闯入其他生物结构以获取营养。在这方面，真菌表现出的钙代谢与外界介质的没有联系，可以解释为一种适应，可以打入其他细胞，那里游离 Ca2 + 浓度太低，不足以构成可靠的来源。对于其他的细胞内寄生虫，如利什曼原虫、弓形虫和疟原虫，也有专门的 Ca2 + 稳态适应。 大多数丝状真菌的菌丝是围绕着一个叫做 Spitzenk orper（SPK）的细胞器组织起来的。SPK 由高尔基体中的一系列小泡组成，这些小泡含有合成膜和细胞壁所需的酶、脂类和多糖。围绕 SPK 的是极性体和外囊。极性体是一系列蛋白质，它们组织细胞骨架成分并调节细胞骨架介导的囊泡运输。这些结构对于维持菌丝生长的方向性，调节 SPK 组分的胞吐，调节 Ca2 + 信号和重塑细胞壁有重要作用。菌丝生长研究揭示了这一分子机制在整个双核亚界（担子菌与子囊菌的祖先）（Dikarya）中的守恒性，但这些群体之外的信息非常有限。例如，大多数合子真菌表现出一种不太有组织特性的小泡聚集，称为新月形顶端小泡（ apical vesicle crescent (AVC)）。SPK 似乎存在于 Basidiobolus 和 Conidiobolus 中，它们是虫霉门（Entomophthoromycota）中早期分化的谱系。芽生枝菌门 (Blastocladiomycota) 的成员也具有形态上可识别的 SPK。SPK 在这些谱系中的存在表明，所有陆地真菌的共同祖先可能有一个 SPK 在合子真菌中丢失或修饰成 AVC，不排除 SPK 在这些谱系中的独立起源的可能性。 几种可能的进化情景可以解释真菌是如何在陆地上定居的，这反过来又触发了真菌的爆炸性多样化。要解决这个问题，就需要提高我们对早期土壤微生物组成的认识，更精确地测定关键事件的年代，如陆地植物多样化和陆生真菌的辐射。将这些替代假设称为真菌陆地化的绿色、棕色和白色情景，分别以植物、土壤和冰为重点（图 2）。 绿色场景：真菌必须作为维管植物的寄生虫存在，才能在陆地的早期阶段抵抗缺水。设想是真菌与陆生植物的祖先共同进化，它们以绿藻中的寄生虫的身份从淡水水体中来到河流和湖泊的边缘，随着植物对陆地环境的适应而征服了陆地世界。这很可能伴随着复杂性的增加（首先是类根，后来是菌丝生长），因为多细胞性在链状植物中变得普遍。陆地植物和单细胞绿藻 Trebouxia 基因组中包含了一些推测真菌起源的古代水平基因转移的证据；与真菌共生所需的基因在绿藻中也显示出同源性。在某些情况下，这些转移的基因在功能上与适应旱地有关。虽然这意味着当绿藻开始在陆地上定居时，真菌就出现了，但这并不能说明它们是一起陆地化的。 棕色场景：出现的土地可能有微生物的群落主宰着整个景观，包括细菌，可能还有真核藻类和原生动物。在这种情况下，真菌会在这些原生质土壤中定居，迅速分裂为与链型植物（Streptophyta） 相关的一个谱系（毛霉亚门，球囊菌门（glomeromycota）和双核亚界）和一个原生动物的寄生虫相关的谱系（捕虫霉亚门）。值得注意的是，目前生活在包括土壤在内的许多环境中的有壳变形虫的微体化石可追溯到元古代。因此，可想而知的是，捕虫霉亚门（Zoopagomycotina）的某些种已经是这种变形虫的寄生虫，尽管还没有找到令人信服的化石证据来证实这一点。埃迪卡拉纪的化石被认为是代表微生物的化石，与已知的某些现代真菌群落相似。很多人声称这些化石来自地衣和黏菌，这表明陆地微生物生态系统已经很发达。 白色场景：在本篇综述中新提出的假设，涉及到冰川环境作为真菌从水环境过渡到陆地环境的促进者。由于冰川环境是由非生物因素形成的，因此可以肯定地认为它们在陆生真菌分化之前就已经存在。在这种环境中，主要的挑战似乎是液态水的限制，与水环境相比，冰环境的异质性和不稳定性要高得多，这是土壤的共同特征。冰环境中的某些微冰，如高盐盐水通道和冰晶中排除溶质而形成的冰锥，具有相当高的微生物多样性。通过对南极麦克默多山谷 5 个冰封湖泊的 18s 核糖体 RNA（rRNA）序列分析，在一个以壶菌门和 Rozellidea（隐菌门的一个纲）为主的群落中，共发现 1313 个真菌操作分类学单位（operational taxonomic units （OTUs）），还包括子囊菌纲、担子菌纲、芽枝菌类和 zygomycetous。对两个南极大陆盐水中的 6 个重复进行分析，发现 600 个 OTU 聚集在两个明显不同的群落中，几乎没有重叠。这表明冰环境可能具有巨大的空间异质性。冰团中含有重要的雪藻群落，它们可能是陆生真菌动孢菌祖先的寄主，动孢菌可以很容易地通过半融化的冰表面繁殖，甚至现代的冰环境（如冰缘土壤或北冰洋）也包含着出乎意料的丰富多样的动孢菌谱系。 真菌陆生谱系的发生估计日期与前寒武纪冰期重叠，这一时期也被称为冰河世纪。这一时期还见证了至少两个非链藻纲陆生藻类（树藻科和沟藻门）的发生。根据上述证据，提出了真菌陆地化的以下过程：（i）冰河环境创造了微生物生态位的多样化。（ii）真菌作为藻类的游动孢子捕食者到达冰层环境。（iii）其他生物坏死物的积累有利于菌丝生长和渗透（iv）间歇条件有利于抗性休眠孢子的发育。在冰川作用的情况下，这些条件会持续更长时间。鞭毛运动丧失。（v） 真菌适应于在寒冷环境中的水限制条件下生存，然后能够在土壤环境中定居。 综上所述，真菌陆地化起源的三种假设情景集中在不同的生物或非生物因素上，这些因素可能是顺序或组合作用的。由于缺乏清晰的化石记录，支持每一种情况的证据都是间接证据，但所有这三种情况的一个共同因素是真菌的陆生化过程必须与其他真核生物群体（变形虫、藻类或植物）的陆生化过程同步。在陆地化之后，与其他生物群的关系将影响主要陆生谱系的辐射，其中捕虫霉亚门主要与其他微生物和后生动物联系在一起，而球囊菌门、毛霉门和双核亚界主要与植物有关。 # IV. 真菌和其他微小的真核生物 # 1. 真菌斑狼疮（Fungus fungo lupus）: 真菌中的真菌寄生症 真菌能够攻击和消化几乎任何一种生命结构，包括其他真菌。在最古老的真菌化石中，已经发现了真菌寄生的联系，这种生活方式可能出现得更早，因为真菌寄生在早期分化的真菌中很普遍（图 3）。最近通过使用单细胞测序技术获得了其中几种生物营养型寄生菌的基因组，鉴于它们通常是小菌体，这是必要的。这些生物中的许多都失去了重要代谢途径的基因，如生物素、多胺、同化硫酸盐或三羧酸循环。真菌可以感染植物，藻类和其他真菌的生物营养，寄生或坏死营养两种方式相互作用。坏死营养型寄生菌具有很强的攻击性，通常有广泛的宿主。其中一些似乎能够作为内生菌在植物组织中定殖（图 4），在那里它们为宿主提供了一种有效的抵御真菌病原体的机制，这推动了对这种真菌生态位的大量研究。木霉具有显著的几丁质酶基因扩增，以及多种次级代谢酶。然而，实验证据表明，这些酶的功能专一性是有限的，即使在属内，营养策略也是可变的。在肉座菌目（Hypocreales）中，有基因组信息的其他重要的真菌寄生属有 Olypocladium 属、Clonostachys 属和 Escovopsis 属。对这些真菌的基因组比较表明，分枝营养化是通过不同的策略独立进化而来的。但生物营养的寄生在实验上不易控制，而且它们在较窄的宿主范围内产生较轻的表型。 从进化的观点来看，支原体和无脊椎动物的病原体之间似乎存在某种关系（图 4）。例如，blastoclad Catenaria、Orbiliomycetes Arthrobotrys 和肉座菌目 Trichoderma 和 Clonostachys，已被报道为支原体和线虫寄生虫。在几乎所有腐生物中，真菌寄生物种的几个重要特征必然存在：为了攻击其他真菌，它们需要几丁质降解酶，还必须保护自己不受酶降解的影响。生产有毒化合物是一种有效的、非常常见的保卫的策略，但也很容易用于进攻目的。支原体可以作为水平基因转移（HGT）的供体和促进者，通过直接向宿主供体或去除宿主细胞壁，从而获取 DNA，从理论上讲，各种各样的寄生菌甚至可以从宿主那里获得基因，然后将它们捐赠给另一个宿主，从而有效地充当载体。 # 2. 真菌和原生动物 真菌和原虫变形虫之间的关系很大程度上是未被探索的。一些原生生物可以早于真菌菌丝和孢子，似乎是控制真菌种群的重要因素。相反的情况是，真菌以变形虫为食，变形虫真菌通常遵循两种策略：内寄生和诱捕。在内寄生虫病中，真菌通常以孢子的形式进入细胞，然后在寄主体内形成叶状体。这已经在罗兹菌属（Nucleophaga, Paramicrosporidium）和动孢子属（Cochlonemataceae）中被描述过（图 1）。另一方面，捕捉变形虫的真菌产生的结构，可以像孢子一样简单，附着在变形虫上，产生一个菌丝体，穿透微生物，以其细胞质内容物为食。这种策略在捕虫霉亚门，子囊菌亚门和伞菌纲（图 1 和图 3）中是已知的。 第一批嗜阿米巴真菌基因组于 2019 年初公布，全部来自于捕虫霉亚门，不过由于难以将样本与宿主分离，样本代表了宏基因组（metagenomes）。这种真菌在自然环境中的生物量非常低，即使用分子方法检测，通常也很难将序列与其生态位联系起来。大多数嗜阿米巴真菌的捕虫霉亚门具有异常长的内部转录间隔区（internal transcribed spacer（ITS）），这阻碍了它们在典型环境条形码研究中的检测。这限制了我们对关键领域真菌的理解。首先，罗兹菌与微孢子虫的关系以及后者的进化起源需要更多的罗兹菌属成员的描述，这一任务近年来由于变形虫寄生虫的研究而有所进展。 其次，所有种类的阿米巴诱捕真菌也都含有捕食线虫的物种（图 4）。事实上，陆生真菌（Zoopagomycota）最早的辐射传统上与无脊椎动物寄生有关，变形虫在这些生物的祖先多样化中所起的作用应该认真考虑。 # Ⅵ. 真菌和动物 # 1.Overview 与植物提供的纤维素相比，几丁质更易于消化，含氮量更高这些特性使微生物真菌成为土壤无脊椎动物如节肢动物、环节动物、软体动物或线虫的重要食物来源。某些种类的白蚁、蚂蚁或甲虫，以及某些蜗牛，都可以培养真菌生物量并将其作为主要的食物来源。许多肉眼可见的子实体和地衣壳可食用，是包括人类在内的动物的重要食物来源。 许多真菌系与动物关系密切 (图 1 和图 3)。大多数研究集中在脊椎动物、昆虫或线虫的真菌寄生虫上，但至少在软体动物、环节动物、轮虫、足爪动物、扁腹动物和刺胞动物中，真菌病原体是已知的。尽管自然界存在着巨大的动物多样性，但几乎所有动物对真菌的免疫反应都非常相似，主要依赖于吞噬性免疫细胞和细胞外陷阱的产生。 # 2. 动物专性寄生 后生动物的专性真菌寄生虫具有基因组和代谢减少的特征，是高度专业化的寄生虫的典型特征。 微孢子虫是已知的许多后生动物谱系，包括几个海洋类群。微孢子虫的特点是基因组极度减少，许多重要的代谢途径丧失，以及线粒体衍生的有丝分裂体的存在。它们的姊妹类群，Rozellida，已经被证明含有寄生于变形虫的微孢子虫样细胞内生活方式的物种。基于此，微孢子虫很可能已经是后生动物单细胞祖先的寄生虫。 # 3. 动物兼性寄生 许多自由生存的真菌能够感染不同种类的动物 (图 1 和图 3)。这些寄生关系通常非常具体，与植物坏死病原体的关系类似。在寄主特异性寄生虫中，真菌可能表现出高度复杂的致病机制，包括但不限于：免疫逃避、毒素、结构成分水解酶的分泌，甚至诱导寄主行为改变的能力。与专性寄生不同，兼性病原体的致病性通常很高，而且在很大程度上与寄主的密度无关。 节肢动物是迄今为止真菌丰富的陆地环境中种类最多的动物门。由动孢菌和担子菌纲引起的节肢动物真菌病是已知的，但它们是相当罕见的（图 1 和图 3）。昆虫的寄生真菌主要在子囊菌亚门【腔菌目 (Podonectria), 多腔菌目 (Myriangium), 肉座菌目】中独立进化了好几次。其中一些肉座菌目（如冬虫夏草、白僵菌、蛇床子属）具有很强的寄主特异性，有些种类能够影响寄主神经系统并改变寄主行为，以帮助传播孢子。另一方面，昆虫可以利用巨噬细胞、抗菌肽、黑色素和活性氧物种来保护自己，也可以采取某些行为，例如消除受感染的群体成员或将自己暴露在更高的温度下。综合上述情况，这种真菌在杀死昆虫后能够在昆虫身体上生长，并且很可能在环境中以活跃的菌丝体形式存在，而不依赖于宿主。值得注意的是，节肢动物寄生物必须能够利用海藻糖作为碳源，海藻糖在这些动物的组织中含量非常丰富。 微型无脊椎动物是土壤、沉积物和其他环境中生物量的重要组成部分，一些真菌已经获得了感染它们的能力（图 1 和图 3）。线虫是微型无脊椎动物群落中研究得最好的部分，因为它们与农业生产力相关，而食线虫真菌也因其作为控制剂的潜力而被研究。线虫寄生真菌可见于捕虫霉亚门，粪壳菌纲，圆盘菌纲，散囊菌纲 (Pezizomycotina) , 伞菌纲 (Agaricomycotina)，被孢霉纲，虫霉纲，甚至在芽枝菌门中。许多食线虫真菌的行为类似于规则的丝状腐生菌，但容易攻击卵和其他静息结构，例如某些植物寄生线虫中不活动的雌性。几种食线虫真菌的基因组分析表明它们往往产生几丁质降解酶和蛋白酶家族的基因扩展。此外，线虫捕食往往拥有一个发育良好的纤维素降解代谢，但很少有传统的植物致病相关基因，这表明其具有腐殖质祖先（图 4）。这些适应与在昆虫病原真菌和寄生真菌中发现的非常相似，而且这些不同生活方式之间的相互转换似乎在肉座菌目（Pezizomycotina）中很常见。许多食线虫真菌是已知的植物内生菌或木材分解者（图 4）。在这些寄生性的生活方式中，无花果是一种很常见的寄生性和寄生性的寄生性真菌（寄生性真菌和寄生性真菌之间的共生关系）。 脊椎动物与其他动物群体相比有几个重要的特点。首先，脊椎动物体型大，身体微绒毛相当多样。其次，它们缺乏几丁质结构。第三，它们都拥有一个完善的基于抗体的免疫系统，这对试图在它们内部生长的任何微生物都构成了严重的挑战。脊椎动物（鸟类和哺乳动物）的一部分是温血生物，其内部温度对微生物构成了另一个重要的屏障。 但只要引发真菌感染，就会造成严重的疾病，三个具体的例子说明了这一点：两个壶菌种（Batrachochytrium endrobatidis 和 B. salamandrivoransare）会对两栖动物造成致命的皮肤损伤，并威胁到全球人口。第二个是假裸囊菌属（Pseudogymnoascus destructans），它在北美造成了大量蝙蝠死亡。这种高毒力菌株来自欧洲，那里的本地蝙蝠种群对它有抵抗力。腐皮镰刀菌（Fusarium solani）是一种对海龟造成极大伤害的真菌，因为它在这些爬行动物的卵上定居和破坏。这是一个特别有趣的案例，因为镰刀菌是一个传统的植物致病属（图 4）。 人类的真菌感染是引起重大公共卫生关注的一个原因。最常见的真菌感染是皮肤病，很少危及生命，但影响外貌，并且较难治愈。大多数引起皮肤感染的真菌是黑色真菌（腔菌目和刺盾炱目）这些真菌已经进化到在高度疏水性和辐照环境下定居，这可以类似地代表沙漠岩石或人的指甲。与这些无关但也会引起皮肤感染的是马色拉菌（黑粉菌亚门）的成员。除此之外，散囊菌目的一些成员已经获得了在皮肤和其他身体环境中生长的能力，特别是在肺部，这是一种与黑真菌有关的生物，专门降解角质化组织。主要病原菌有组织胞浆菌属、芽生菌属和球孢子菌属。这些属真菌的黑色素化程度很高，这使得它们能够在高氧化条件下生存。第二类最常见的人类病原体是酵母菌属，特别是假丝酵母属和 Nakaseomyces 的酵母菌，它们既能引起粘膜表面感染，又能引起系统性血流感染，死亡率高。最后，其他丝状真菌（曲霉属、青霉属、拟青霉属、顶孢霉属、镰刀菌属、木霉属、孢子丝菌属、假丝酵母属）、假丝酵母属（红酵母属）、粘霉属（根霉属、地衣菌属、毛霉属）和虫霉属（担子菌属）中的其他丝状真菌，分生孢子虫）在软体组织中产生高度侵袭性感染。这些真菌通常是空气和土壤传播的腐生物，能够快速生长，不会受到高温的过度抑制（图 4）。这些疾病的病程变化很大。有些会产生结节，可能导致器官损伤，或者至少严重毁容。另一些则发展为慢性感染，对器官造成持续损害。肺曲霉菌病是这些疾病中最常见的，引起广泛的呼吸系统问题。最后，有些真菌毒性很强，通过软组织迅速生长，这可能导致严重的致残和器官损伤。人们一直致力于研究机会性病原体是如何产生的。虽然其机制是高度可变的，但通常病原体在某些战略蛋白家族中表现出基因扩增（如细胞粘附、蛋白酶、脂酶、活性氧清除）。许多人类真菌病原菌具有高度杂合子甚至不稳定的基因组，具有常见的非整倍体、多倍体和杂交事件。完全有可能这些事件在其他真菌中也很常见。然而，非整倍体与获得抗真菌耐药性有关，杂交与某些物种复合体中新的毒性菌株的出现有关。 # 4. 动物 - 真菌的共生 酵母菌中的酵母菌是昆虫和脊椎动物黏液中肠道菌群的常见成分。甚至有人认为昆虫的肠道可能是酵母菌属（图 4）和一些属的进化的重要环境，例如最近描述的 Suhomyces (syn. Saccharomyces tanzawaensis) 似乎优先发现在这样的生态位昆虫以树液或水果为食，其饮食中含有极为丰富的单糖。共生真菌（木素菌）的成员被描述为与几种甲虫有关，它们似乎帮助宿主解毒植物有毒化合物。除此之外，有些物种是健康脊椎动物粘液的常见成员。由于白色念珠菌与人类病原体的相关性，它已被广泛研究。除此之外，担子菌中的其他酵母样形式是哺乳动物皮肤和粘膜的重要共生体。 真菌脊椎动物共生体的一个重要而常被忽视的群落是心丽鞭毛菌门的成员。事实上，还没有研究解决这些奇异真菌如何与宿主免疫系统相互作用的问题。作为真菌最早的分化谱系之一，它们的分化一定比它们现在的脊椎动物宿主的出现要早得多。第一种可能性是，这些真菌最近通过与脊椎动物宿主的联系，形成了自己特有的生活方式。第二种可能是这些真菌是与其他可能已经灭绝的谱系联合进化而来的。第三种可能是这个谱系的成员可能生活在尚未开发的环境中，从那里他们可以进入脊椎动物宿主并建立起重要的共生体。 # Ⅵ : 真菌 - 植物生物群落：植物与真菌的相互作用 # 1.overview 真菌和陆地植物在生物圈中有着持续时间最长、最亲密的关系。真菌界是造成植物病害的主要原因，也是植物坏死物质的主要分解者。另一方面，植物有无数的真菌以共生体和 / 或共生体的形式与其组织紧密结合。菌根是一种共生真菌，与植物的根相联系，帮助植物获得养分和水分。大约 90% 的植物物种存在内菌根联合体。此外，内生真菌是真菌共生体，生活在植物组织内，不会对植物造成伤害。内生真菌并没有像菌根那样受到关注，因此对其丰度、相关性和多样性的精确估计仍然缺乏。这些真菌的存在似乎通过刺激植物的防御和作为生态位竞争对手来保护植物免受致病真菌的侵害。其中一些真菌是其他有机体的寄生虫，如其他真菌、昆虫或线虫，产生次级代谢物，帮助植物对抗食草动物，或促进植物生长。研究更少的是生活在植物表面的真菌（附生植物），形成所谓的叶面群落。这些群落具有高度多样性，与内生菌一样，可以影响寄主植物的生理学。它们代表着一个尚未开发的生物多样性池，在保护工作中经常被忽视。 # 2. 菌根和共生植物 菌根组合出现在球囊菌门、毛霉门（内生殖腺）、伞菌纲和几种子囊菌纲中。其中，最重要的类群是球囊菌门，其中几乎所有的物种都形成丛枝菌根。化石证据表明，在 4 亿年前的 Rhynie Chert 化石中存在菌根联合体，这意味着真菌的相互作用对植物的陆地化至关重要。 Geosiphon 和 Densospora 是目前解决菌根进化难题的关键。 有可能是由与蓝藻或陆生植物祖先的类似地衣管属进化而来的。然而，Geosiphon 被放置在一组分解良好的菌根形成菌群中，这使得这种关联很可能是二次进化的。另一方面，如果 Densopora 是毛霉科的一员，也许是内囊门目的一员，它可能会对毛霉科菌根的进化提供更深入的了解，并可能暗示整个门的菌根起源。一些研究指出，球囊菌门和第一批陆地植物之间存在关联。优良的内生菌与传统上被认为是丛枝菌根真菌的一种，在形态上形成了一种独特的组合。 除了内囊门目外，外生菌根真菌似乎是最近才独立地在几个类群中产生的，只有一小部分植物形成这种菌根组合，大多数是树木，这意味着外生菌根在森林环境中具有重要作用。与有限的植物种类形成鲜明对比的是，外生菌根真菌表现出高度的多样性。这种多样性得到了很好的描述，因为大多数真菌产生宏观的子实体。最后，兰科植物是一个高度多样化的分支，它与真菌的多样性形成高度特异的菌根组合。与球囊菌门和内囊门目不同，这些真菌对其植物寄主的依赖性相对较低。 # Ⅶ. 地衣真菌 共生是两个或两个以上有机体之间互利的结合。地衣是由真菌起源的组织形成的宏观结构，即真菌生物，它包裹着一种光营养的蓝藻或绿藻，即光生物。它们可以在所有陆地生物群落中找到，并且在对其他光合生命体不利的环境中特别丰富和多样，例如高海拔山脉、冻土带和沙漠。这种真菌对光照和干燥有很强的抵抗力，不需要底物，能够从光生物中获得碳，有时是氮，为其提供了一个保护环境。地球约 6.8% 的陆地表面被地衣覆盖，地衣在全球生物地球化学中扮演着重要角色。 地衣主要在子囊菌亚门（图 3），占总数的近一半（约 20000 种）。 地衣在六个类群中都有代表性，其中茶渍纲和星裂菌纲两个种类是最丰富的地衣形成分支。地衣含有多种多样的微生物，包括其他真菌。有人提出，内生生活方式可能代表腐生和内生之间的中间步骤。其中一些相关的微生物是寄生虫，包括寄生在叶状体上并慢慢取代叶状体的地衣物种。内生真菌可能对整个叶状体产生表型效应。 地衣化石的记录非常古老，至少可以追溯到泥盆纪，尽管一些 Ediacaran 化石和类似地衣的化石可能是最早的陆生真菌之一。Winfrenatia reticulata 是泥盆纪早期的化石，被认为是 zygomycetous 地衣。现代地衣主要的谱系至少早在石炭纪就多样化了。目前还不清楚地衣生活方式在子囊菌纲中出现了多少次。一些早期的研究提出了一个单一的事件，然后是多个独立的转变为腐殖质的习性。多重起源是目前最受欢迎的观点，尽管对于转变的数量还没有达成共识支持这一点的是，有些物种既可以被发现为地衣，也可以是自由生活的腐生物，这意味着生活方式之间的转变是可能的。考虑到地衣真菌与光生生物和其他微生物的紧密联系，地衣真菌是接收外源基因的主要候选物种，并且有证据表明地衣特有的几种次级代谢物已从细菌水平转移。地衣也可以将基因捐赠给它们的光生生物。 在基因组研究方面，地衣真菌的一些特性意味着它们落后于其他真菌。地衣是复合生物，需要单独培养或使用类宏基因组方法。独立培养限制了对共生体本身的研究，在实验室条件下维持真菌活性存在一系列挑战。宏基因组学的方法在实验和计算上都要复杂得多，并且可能导致碎片化的装配和污染问题。基因组测序和比较分析揭示了一些可能与共生相关的特征。它的基因组只有一个很小的分泌体，糖转运蛋白的数量也减少了，但是在编码氮和镁转运蛋白、细胞信号传导途径和防止干燥的蛋白质的基因家族中却经历了扩张。增强氮转运在地衣化过程中似乎很重要，至少在光生伴侣不能固氮的真菌中是如此，基因复制和 HGT 似乎都在这种基因扩展中发挥作用。尽管目前还没有发表比较研究报告，但几种地衣形成真菌的基因组已具备不同程度的完整性和质量。 # Ⅷ. 结论 (1) 最早的真菌是其他单细胞真核生物的动孢菌。如今，这种生活方式可以在后孢菌、壶菌门和芽枝菌门中找到。 (2) 有两种主要假设可以解释真菌的陆生化过程。棕色场景假设真菌在沉积物中进化出腐殖质习性，它们在土壤中繁衍。绿色情景假设真菌的陆生化与绿藻和链霉菌的陆生化密切相关。在这里，提出了第三个白色的场景，真菌在适应冰冻环境后殖民了陆地环境。 (3) 真菌和其他微生物真核生物之间关系的进化意义一直被忽视。在陆地化的早期阶段，真菌一定与其他真菌和原生动物有过相互作用。这些生物体的寄生可能是动物寄生进化的第一步。 (4) 几种真菌已经获得了一种必须的寄生生活方式，并表现出许多寄生虫常见的典型特征。真菌是脊椎动物和无脊椎动物的重要寄生物，尽管这两类动物之间的机制差异很大。无脊椎动物寄生物与支原体和嗜线虫菌有关，利用其几丁质降解能力攻击宿主。脊椎动物寄生必须能够克服宿主的免疫反应。这些谱系的发病机制似乎来自共生，通常是兼性病原体。 (5) 真菌和植物之间的关系非常古老，Glomeromycota 化石是陆地真菌生活的第一个直接证据。Endophytism 是一种未被充分探索的真菌生态位，拥有令人印象深刻的生物多样性。寄生在植物中主要有两种策略：生物饲养和坏死饲养。这些策略带来了完全不同的进化压力，这反映在它们的基因组特征上。最后，值得一提的是伞菌纲中有一组，他们发展了独特的酶降解木质素的能力。这种能力的获得与它们形成高度复杂子实体的能力有关，赋予它们巨大的进化和生态成功。 (6) 与其他真菌相比，地衣在基因组研究方面一直落后于其他真菌。地衣的生活方式可能是陆生过程中的关键，在子囊菌中被认为是非常古老的，许多腐殖质谱系是派生的状态。","tags":"literature_reading"},{"title":"利用orthofinder寻找单拷贝基因构建系统发育树","url":"/2020/07/18/2020-07-18-orthofinder/","text":"# 1.orthofinder 介绍 OrthoFinder 是一种快速、准确和全面的比较基因组学分析工具。它可以找到直系和正群，为所有的正群推断基因树，并为所分析的物种推断一个有根的物种树。OrthoFinder 还为比较基因组分析提供全面的统计数据。OrthoFinder 使用简单，只需运行一组 FASTA 格式的蛋白质序列文件（每个物种一个）。 # 2. 基础知识介绍 Orthologue（直系同源基因）指的是来自两个物种的基因。Orthologue 是由两个物种的最后共同祖先 (LCA) 上的单个基因进化而来的成对基因 (图 1A 和 B)。正群是同源概念在物种群中的自然延伸。一个 Orthogroup（正交群）是由一个物种的 LCA 中的单个基因进化而来的一组基因 (图 1A)。当观察基因树时，一个邻位群体中基因的第一次分化是一个物种形成事件，对同源基因来说也是如此。 作为基因复制事件的结果，当观察直系同源基因和正交群时，可能会有来自同一物种的多个基因。在这个例子中 (图 1A 和 B)，人类和老鼠的 HuA 基因是鸡中 ChA1 和 ChA2 的同源基因。再看一下正交群，我们发现有两个鸡的基因 (图 1A)，但是只有一个来自老鼠和人类的基因。一些作者将 ChA1 和 ChA2 基因作为 HuA 的共同源基因，以强调存在多个同源基因的事实。由于基因重复和丢失在进化中经常发生，一对一的直系同源物很少见，通过分析正交群所有直系同源的情况（一对一，多对一，多对多），我们可以分析数据的所有情况。 paralogues (旁系同源基因) 是指在基因复制事件中从单个基因中分离出来的成对基因，鸡的两个基因 ChA1 和 ChA2 是旁系同源基因 (图 1C)。来自不同物种的两个基因如果在基因重复事件中彼此分离，也可能是同源的。由于基因树中所有的分支事件要么是物种形成事件 (产生直系同源基因)，要么是重复事件 (产生旁系同源基因)，因此同一正交群中任何不是直系同源基因的基因必然是旁系同源基因。 直系同源物是同源性基因，是物种形成事件的结果。Paralogs（旁系同源物) 是同源基因，是重复事件的结果。可以看到 (图 2)，不同物种间的 α-chain gene 互为 Orthologs (直系同源物)。正交群用来形容自一组物种的 LCA 中的单个基因的基因组（α-chain gene）。然后同一物种间 α 和 β chain gene 互为 Paralogs (旁系同源物)。最后所有这些关系都可以由 OrthoFinder 来识别。 # 3. 安装 在这里推荐大家使用 conda 来安装，简单明了，不用担心其他 Dependencies 的安装 $conda install orthofinder# 4. 运行 orthofinder 运行 Orthofinder，相当简单的操作，&quot;-f&quot; 输入目录，里面包含你需要运行的蛋白质 fasta 文件，“-t” 所用到的 CPU 数目，“-S” 选择的比对模式（默认 diamod，可选 blast）。 我使用的物种有九个：大豆（G.max）、菠萝（A.comosus）、柑橘（C.sinensis）、无油樟（A.trichopoda）、拟南芥（A.thaliana）、黄瓜（C.sativus）、水稻（O.sativa）、小立碗藓（P.patens）、江南卷柏（S.moellendorffii） 将所有物种的蛋白文件放到 Angiospermae 文件夹下 $nohup orthofinder -t 16 -f Angiospermae&#x2F; -S blast &amp;生成的结果会存储于 Orthofinder/Results_XXX 文件中，现在简单看看里面有啥。 Citation.txt OrthologuesComparative_Genomics_Statistics Phylogenetically_Misplaced_GenesGene_Duplication_Events Putative_XenologsGene_Trees Resolved_Gene_TreesLog.txt Single_Copy_Orthologue_SequencesOrthogroups Species_TreeOrthogroup_Sequences WorkingDirectory我们主要使用 Orthoogroups 查看正交群的基因和使用 Single_Copy_Orthologue_Sequences 里的单拷贝基因构建系统发育树 WorkingDirectory 其中包含运算过程的中间文件，例如 blast 结果，如果我们想去掉某一物种，在 SpeciesIDs.txt 中将该物种注释掉 $vi SpeciesIDs.txt#0: Acomosus.pro.fa1: Athaliana.pro.fa2: Atrichopoda.pro.fa3: Csativus.pro.fa4: Csinensis.pro.fa5: Gmax.pro.fa6: Osativa.pro.fa7: Ppatens.pro.fa8: Smoellendorffii.pro.fa~$nohup orthofinder -b WorkingDirectory如果我们想增加额外的物种进行分析，可以按照如下方式运行 $nohup orthofinder -b WorkingDirectory -f new_fasta_directory# 5. 利用单拷贝基因构建系统发育树 Orthofinder 的 Single_Copy_Orthologue_Sequences 下存放着单拷贝同源基因的序列，我们可以利用这些序列构建系统发育树 # 5.1. 多序列比对 多序列比对推荐使用 muscle $wget http:&#x2F;&#x2F;www.drive5.com&#x2F;muscle&#x2F;downloads3.8.31&#x2F;muscle3.8.31_i86linux64.tar.gz$tar xzvf muscle3.8.31_i86linux64.tar.gz$chmod +x muscle将 muscle 添加至环境变量单拷贝的序列较多，所以使用 shell 批量运行 $vi bash.shfor i in *.fado muscle -in $i -out $i.1done$sh bash.sh# 5.2. 提取保守序列 .1 文件是比对好的序列文件，接下来使用 Gblocks 提取保守序列 $wget http:&#x2F;&#x2F;molevol.cmima.csic.es&#x2F;castresana&#x2F;Gblocks&#x2F;Gblocks_Linux64_0.91b.tar.Z$tar Zxf Gblocks_Linux64_0.91b.tar.Z添加至环境变量$vi bash2.shfor i in *.1do Gblocks $i -b4&#x3D;5 -b5&#x3D;h -t&#x3D;p -e&#x3D;.2done$sh bash2.sh-t= default:p 设置序列的类型，可选的值是 p,d,c 分别代表 protein， DNA， Codons 。 -b1= default:（ 序列条数的 50% + 1 ）, 设定保守性位点必须有 &gt;= 该值的序列数。该参数后接一个 integer 数，默认下比序列条数的 50% 大 1. -b2= default: 序列条数的 85%, 确定保守位点的侧翼位点时，其位点必须有 &gt;= 该值的序列数。该值必须要比 -b1 的值要大。 -b3= default: 8, 最大连续非保守位点的长度。 -b4= default: 10, 保守位点区块的最小长度。该值必须 &gt;=2 。 -b5= default: n, 设置允许含有 Gap 位点。可选的值有 n,h,a 分别代表 None, With Half, All 。 当为 h 时，表示 - e= default: .2, 设置输出结果的后缀。 # 5.3. 序列合并 比对好之后我们需要将所有文件合并，在合并之前，需要对每个序列文件进行排序，并将多行序列转换为一行序列，此时用到的工具是 seqkit $conda install seqkit$vi bash3.shfor i in *.2do seqkit sort $i &gt;$i.3seqkit seq $i.3 -w 0 &gt; $i.3.4done$sh bash3.sh$mkdir new$mv *.4 new&#x2F;$cd new$paste -d &quot; &quot; *.4 &gt; all.fa$sed -i &quot;s\\ \\\\g&quot; all.fa此时我们已经把所有的单拷贝序列合并，接下来使用 notepad++ 把所有的 ID 更改 # 5.4. 选择合适的替代模型 修改结束后选择合适的氨基酸替代模型准备构建系统发育树，在这里我使用 prottest 预测合适的模型，prottest 使用 phy 格式文件，所以用 python 脚本先将 fa 文件转换为 phy 文件， import rewith open(&#39;all.fa&#39;, &#39;r&#39;) as fin: sequences &#x3D; [(m.group(1), &#39;&#39;.join(m.group(2).split())) for m in re.finditer(r&#39;(?m)^&gt;([^ \\n]+)[^\\n]*([^&gt;]*)&#39;, fin.read())]with open(&#39;all.phy&#39;, &#39;w&#39;) as fout: fout.write(&#39;%d %d\\n&#39; % (len(sequences), len(sequences[0][1]))) for item in sequences: fout.write(&#39;%-20s %s\\n&#39; % item)从 [] 官网上](https://www.softpedia.com/dyn-postdownload.php/cc45406e35260b47bfa4132e67f8c446/5f13ff63/286c7/4/1) 下载 prottest $ tar zxf prottest-3.4-20140123.tar.gz$java -jar &#x2F;opt&#x2F;biosoft&#x2F;prottest-3.4-20140123&#x2F;prottest-3.4.jar -i all.phy -all-distributions -F -AIC -BIC -tc 0.5 -threads 24 -o prottest.out在 prottest.out 中可以看到最佳模型 # 5.5. 构建系统发育树 使用 raxml 构建系统发育树 $wget https:&#x2F;&#x2F;github.com&#x2F;stamatak&#x2F;standard-RAxML&#x2F;archive&#x2F;master.zip$unzip master.zip$cd standard-RAxML$make -f Makefile.SSE3.gcc$make -f Makefile.SSE3.PTHREADS.gcc$make -f Makefile.SSE3.MPI.gcc$make -f Makefile.SSE3.HYBRID.gcc添加至环境变量选择 JTT+I+G+F 模型构建发育树，外群选择江南卷柏和小立碗藓 $nohup raxmlHPC-PTHREADS-SSE3 -T 16 -f a -x 123 -p 123 -N 1000 -m PROTGAMMAJTT -k -O -o Smoellendorffii,Ppatens &#x2F; -n all.tre -s all.fa &amp;运行结束后使用 figtree 打开 RAxML_bipartitions.all.tre，对进化树进行修改。 至此，利用单拷贝基因构建系统进化已经完成 # 参考链接 https://www.jianshu.com/p/16e0bbb2ba19 http://www.chenlianfu.com/?p=2217 https://github.com/stamatak/standard-RAxML https://github.com/davidemms/OrthoFinder 转载请注明周小钊的博客 &gt;&gt; 利用 orthofinder 寻找单拷贝基因构建系统发育树","tags":"bioinformatics comparative_genomics"},{"title":"利用Github+Jekyll构建自己的博客","url":"/2020/07/09/2020-07-09-github+jekyll/","text":"我们知道，一个网站要能够在任何地方都能够被访问，那么需要部署到服务器上，但是对于我们来说，构建服务器的花销是巨大的。幸运的是，github 就提供了这样的功能，只要按照 github 格式要求，新建一个仓库，把你的网站代码上传到里面，你就有一个自己的免费网站了。 废话不多说，让我们利用 jekyll 和 github 来构建自己的博客吧！！ # 一：软件下载 jekyll 支持 mac、linux、windows 等，鉴于大部分童鞋使用的是 windows 系统，那我就用 windows 构建 # 1. 下载安装 ruby installer https://rubyinstaller.org/ ，点击相应的版本进入下载页面即可下载 # 2. 下载 rubygems https://rubygems.org/pages/download ，可以选择相应版本下载 下载完成后解压到你想放的位置，比如我放在了 “D:/soft/rubygems3-1.4” 下，打开 cmd 用命令执行 D:cd soft&#x2F;rubygems3-1.4ruby setup.rbgem install jekyll # 二：网站构建 软件下载有点耗时，在此期间我们可以挑选一个自己喜欢的主题来构建自己的博客 首先你要到 GitHub 上注册一个账号，例如 jungleblack007（用户名可以在设置里改），创建完成后可以去 jekyll 主题网站选择自己喜欢的主题，然后在这个主题基础上修改到满足自己需求的博客. 我选择的是潘柏信的博客主题，因为这个主题有中文说明，而且有个 B 站 up 主对该主题进行了详细的操作，适合我们入门，先让我们看一下该博客的外貌！ 我们找到作者的源代码块，点击右上角的 fork 可以将它拷到我们自己的 github 中，顺便 star 一下支持作者 拷到自己的 github 后，我们点击 setting，先进行改名，推荐：你的用户名.github.io 然后下拉找到 GitHub Pages，source 选择 master branch，我已经点了所以看不到，然后上方出现一个网址，这个就是你的域名了，可以先看看和原博客有没有区别 # 三：运行 jekyll 生成静态网页 把别人的主题 fork 以后，我们可以利用 atom 把主题代码转到自己的电脑上 打开 atom，按 ctrl+shift+p，输入 github clone，选择要克隆的网址和要保存的路径。点 clone 即可 clone 完成后，就会有如下界面 修改_config.xml, 把一些信息修改为自己的 图像也可以换，根据 img 的文件夹的图片名称可以换成你想要的，名字要一致，img/posts 主要放置的是笔记中的图片，可以删掉，以后写笔记的时候想插入图片需要把图片路径设置成 img/posts/XXXX。赞赏功能的图片在 paying 里，需要赞赏就改成自己的二维码，不需要赞赏就删掉 new-old.html 里的所有内容 此时，我们可以用 jekyll 来生成一个静态网页查看 Dcd data&#x2F;gitbundler installbundle exec jekyll servehttp://127.0.0.1:4000 这是我们生成的一个静态页面，浏览器输入即可查看 可以看到背景和个人信息都已经改为了自己的，说明修改成功！ # 四，写一篇自己的博客 jekyll 比较好的一点是可以识别笔记文件，我们可以把写好的文件放到_post 文件夹下，然后在 md 文件前面加一串代码。 写好后可以再运行 bundle exec jekyll serve 查看自己写的博客是否已经能在静态网页上查看 # 五：添加网站统计功能 我们可以给自己的网站添加统计功能，在这个主题中也支持该功能，推荐使用百度统计，首先注册账号 注册结束后添加新的域名统计 添加结束后点击管理 — 代码获取，会看到一串代码， &lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?60e2d4433f4c77b3ae5db5cac1b62829&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;? 后面的 60e2d4433f4c77b3ae5db5cac1b62829 可以粘贴替换掉_config.yml 文件中的百度统计 这样统计功能就添加上了 # 六：添加评论功能 评论功能也可以根据自己的喜好添加，我添加评论功能使用的是来必力 注册账号后添加网页，与百度统计类似，添加结束后点击管理界面 - 代码管理，可以看到一串代码 &lt;!-- 来必力 City 版安装代码 --&gt;&lt;div id&#x3D;&quot;lv-container&quot; data-id&#x3D;&quot;city&quot; data-uid&#x3D;&quot;MTAyMC81MDkzOC8yNzQyMA&#x3D;&#x3D;&quot;&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; (function (d, s) &#123; var j, e &#x3D; d.getElementsByTagName (s)[0]; if (typeof LivereTower &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; return; &#125; j &#x3D; d.createElement (s); j.src &#x3D; &#39;https:&#x2F;&#x2F;cdn-city.livere.com&#x2F;js&#x2F;embed.dist.js&#39;; j.async &#x3D; true; e.parentNode.insertBefore (j, e); &#125;)(document, &#39;script&#39;);&lt;&#x2F;script&gt;&lt;noscript &gt; 为正常使用来必力评论功能请激活 JavaScript&lt;&#x2F;noscript&gt;&lt;&#x2F;div&gt;&lt;!-- City 版安装代码已完成 --&gt;将该代码复制，替换掉_include/comments.html 中的全部内容即可（这里的 bioinformatics-rookie.github.io 是我自己的博客，文中出现的 jungleblack007.github.io 是我用来做试验的账号） # 七：上传到 github 所有内容修改完成后可以将自己的代码上传到 github，atom 也提供此功能。 当你所有的内容修改完毕后，atom 右侧 unstaged changes 会显示你修改了什么内容，点击 stage all, 所有的会移动到下方的 staged changes. 在 commit message 中随便写点东西点击下方按钮，在 push 出会出现一个待上传的指令 ctrl + 左键点击 push，使用 force push 功能可以将自己修改过的内容传到 github 服务器上，这样输入你的 github 域名就可以打开自己的网页了，后续的更改同样采取此操作。 # 参考链接 https://github.com/leopardpan/leopardpan.github.io https://www.jianshu.com/p/9f71e260925d https://www.bilibili.com/video/BV14x411t7ZU?t=537 转载请注明转载请注明：周小钊的博客 - 利用 github 和 jekyll 构建个人博客","tags":"blog"},{"title":"RepeatModeler+RepeatMasker的安装与使用","url":"/2020/07/08/2020-07-08-repeat/","text":"在基因组注释中第一步就是重复序列的屏蔽，目前常用的从头注释 pipeline 就是 RepeatModeler + RepeatMasker。 # 一：RepeatMasker 安装 # 1.TRF trf 下载地址：[https://tandem.bu.edu/trf/trf409.linux64.download.html] bashmv trf409.linux64 trfchmod a+x trf。# 2.RMblast 推荐使用 2.9.0 版本 使用 conda 安装 bashconda install RMblast&#x3D;2.9.0# 3.RepeatMasker bashwget -c http:&#x2F;&#x2F;www.repeatmasker.org&#x2F;RepeatMasker-4.1.0.tar.gztar xzvf RepeatMasker-4.1.0.tar.gzchmod 755 *.&#x2F;configure“./configure” 执行后，根据提示信息进行 1.perl 环境，系统会默认自动检测 2.TRF，默认自动检测，不过我没有使用 conda 安装也没有加入环境变量需要自己输入 3. 序列搜索引擎，在这里使用的是 RMblast，默认检测 最后配置环境变量 bashvi ~&#x2F;.bashrc输入 export PATH&#x3D;&quot;&#x2F;datadisk02&#x2F;soft&#x2F;RepeatMaker:$PATH&quot;source ~&#x2F;.bashrc# 二：RepeatModeler 安装 # 1.RepeatMasker、TRF、RMblast（已安装，不再赘述） # 2. RECON bashwget -c http:&#x2F;&#x2F;eddylab.org&#x2F;software&#x2F;recon&#x2F;RECON1.05.tar.gz也可以使用 conda 安装 # 3.RepeatScout bashwget -c http:&#x2F;&#x2F;www.repeatmasker.org&#x2F;RepeatScout-1.0.6.tar.gz# 4. 可选软件，运行 LTR 结构搜索必须软件，也可以不安装 # LtrHarvest LtrHarvest 程序是 GenomeTools 套件的一部分。安装 genometools 即可，但安装时老报错，还好有万能的 conda bashconda install genometools-genometools# Ltr_retriever bashhttps:&#x2F;&#x2F;github.com&#x2F;oushujun&#x2F;LTR_retriever&#x2F;archive&#x2F;master.zipunzip LTR_retriever-master添加至环境变量# MAFFT bashwget http:&#x2F;&#x2F;mafft.cbrc.jp&#x2F;alignment&#x2F;software&#x2F;mafft-7.158-without-extensions-src.tgzperl -p -i -e&#39;s#PREFIX &#x3D;.*#PREFIX &#x3D; &#x2F;opt&#x2F;biosoft&#x2F;mafft#&#39; Makefileperl -p -i -e&#39;s#BINDIR &#x3D;.*#BINDIR &#x3D; &#x2F;opt&#x2F;biosoft&#x2F;mafft&#x2F;bin&#x2F;#&#39; Makefilemakemake install添加环境变量# CD-HIT bashwget https:&#x2F;&#x2F;github.com&#x2F;weizhongli&#x2F;cdhit&#x2F;archive&#x2F;master.zipunzip cdhit-master.zip &amp;&amp; cd cdhit-master&#x2F;sudo make添加至环境变量# Ninja bashwget https:&#x2F;&#x2F;github.com&#x2F;TravisWheelerLab&#x2F;NINJA&#x2F;archive&#x2F;master.zip解压后安装Ninja 安装非常让人头疼 bashsudo makeg++-7 命令未找到查看 Makefile 后发现该问题 该软件需要 c11 (4.8.1) 以上的编译器，首先查看自己的 gcc 以及 g 版本，4.8.1 版本以上 bashsudo gcc -vsudo g++ -vg++-7 这个命令是没有的，我们需要在 Makefile 里找到 g++-7 并把它改为 g++，然后 make 安装结束后打开 NINJA 文件夹 看到有 Ninja 出现 bash.&#x2F;Ninja缺失 libstdc++.so.6: version’GLIBCXX_3.4.20’又 tm 报错，都快要崩溃了，去网上搜解决方案呗，后来发现是 libstdc++.so.6 的版本过低造成的，自己服务器上的 libstdc++.so.6 是一个软链接，它链接到了实际的动态库文件：libstdc++.so.6.0.19；由于该问题已解决，我的软连接改为了 libstdc++.so.6.0.24 bashsudo cp &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libstdc++.so.6.0.24 &#x2F;usr&#x2F;lib64cd &#x2F;usr&#x2F;lib64sudo rm libstdc++.so.6ln libstdc++.so.6.0.20 libstdc++.so.6这时候回到 NINJA 下运行成功，添加到环境变量 # 5.RepeatModeler 安装 如果前几步都添加了环境变量，软件会自动检测，只需要敲回车即可 bashcd RepeatModelerperl .&#x2F;configure终于成功，开心 # 三：重复序列的屏蔽 无 library 直接使用 RepeatMasker 中的 RepBase 数据库来计算重复序列，若 RepBase 数据库对目标物种的覆盖不好，则很可能只找到较少的重复序列。此时，使用 RepeatModeler 构建 library 就很有必要。 无 library 的构建方法在 RepeatMasker 官网上有个流程，http://www.repeatmasker.org/RepeatModeler/，根据 example run 的来就行 # 1. 构建数据库 bashBuildDatabase -name hud Lichenomphalia_hudsoniana_LH.genome.fasta# 2. 构建 library bashnohup RepeatModeler -pa 10 -database hud -LTRStruct &gt;&amp; run.out &amp;运行成功完成后，将生成两个文件，还有一个文件夹 bashhud-families.fahud-families.stk让我们看一下这两个文件都是啥 bashless hud-families.fa 这是一个 fa 文件，在 id 上会注明这个序列是什么结构，比如这条序列就是 LTR, 再看一下所有的 ID bashgrep &quot;&gt;&quot; hud-families.fa 可以发现在 repeatmodeler 运行完就已经把基因组的所有序列进行了标识 bashless hud-families.stk 这个文件看的我有点懵，没见过的格式啊，后来去官网查了一下这是 Dfam 兼容的 Stockholm 格式，可以通过将数据提交到 help@dfam.org 上传到 Dfam 数据库。 不过咱们也别纠结这个问题，下一步用到的只有 xxx-families.fa # 3. 运行 RepeatMasker bashnohup RepeatMasker -e rmblast -lib hud-families.fa -pa 16 Lichenomphalia_hudsoniana_LH.genome.fasta &amp;运行速度很快，结果生成三个文件 bashLichenomphalia_hudsoniana_LH.genome.fasta.maskedLichenomphalia_hudsoniana_LH.genome.fasta.outLichenomphalia_hudsoniana_LH.genome.fasta.tbl Lichenomphalia_hudsoniana_LH.genome.fasta.out：这个文件主要记录了基因组重复的位置信息以及类型 Lichenomphalia_hudsoniana_LH.genome.fasta.tbl，对各个重复进行了归类并汇总基因组重复信息， 逆转录因子 ：SINEs，短散在重复序列。 LINEs，长散在重复序列。LTR，长末端重复序列。 DNA 转座子 Lichenomphalia_hudsoniana_LH.genome.fasta.masked：这个就我们要的最终文件，把重复序列替换为 N 的基因组序列文件，利用这文件就可以进行下一步注释了 # 参考链接 https://blog.csdn.net/libaineu2004/article/details/77100132?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase http://www.repeatmasker.org/ https://www.jianshu.com/p/50ce4bcd1972 各个软件的链接都在 http://www.repeatmasker.org/，我就不整理在这了","tags":"bioinformatics gene_annotion"},{"title":"AI学习书签","url":"/webstack/index.html","text":"# 概述 此界面主要是分享自己在学习 AI 的过程收藏的书签，目前 AI 绘画和 ChatGPT 进步飞速，感觉不学一点就要跟不上时代了 # AI 绘画 # 安装方法 目前 AI 绘画有很多平台可以使用，推荐 stable-diffusion-webui。 然后我们下载秋葉 aaaki 制作的一键端启动。将其复制到 webui 的根目录下启动即可。 # 模型下载 推荐两个网址 civitai huggingface 推荐先下载 ChilloutMix 和 Anything V3，比较泛用的三次元和二次元模型，都可以在 civiltai 上下载的 controlnet 的模型可以在 huggingface 中找到 # 初步尝试 首先生成一张二次元 (Anything V3) 图片，界面左上角为模型选择 具体参数 提示词 (((extremely detailed CG))), (((8k wallpaper))),(((masterpiece))),((best quality)),((best resolution illustration)),&#123;(solo)&#125;,hyper detailed,highres,&#123;solo&#125;,&#123;1 extremely detailed girl&#125;,beautiful detailed glow,((beautiful detailed blue eyes)),&#123;elaina (majo no tabitabi) &#125;, black robe, silver hair, long hair, braid, smile,&#123;&#123;black skirt&#125;&#125;, [white shirt], frilled shirt,witch,black witch hat,(yellow ribbon), purple eyes , atelier(series),(white pantyhose),(no shoes),&#123;(Surrounded by Purple vine)&#125;,&#123;(beautiful detailed garden)&#125;,crossed legs+from bottom, 负面提示词 Inverted mountain, low-quality, distorted mountain, distorted light, low-quality light, low-quality mountain,multiple breasts, (mutated hands and fingers:1.5 ), (long body :1.3), (mutation, poorly drawn :1.2) , black-white, bad anatomy, liquid body, liquid tongue, disfigured, malformed, mutated, anatomical nonsense, text font ui, error, (((malformed hands))), (((long neck))), blurred, lowers, lowres, bad anatomy, bad proportions, bad shadow, (((uncoordinated body))),(((unnatural body))), fused breasts, bad breasts, huge breasts, poorly drawn breasts, extra breasts, liquid breasts, heavy breasts, missing breasts, huge haunch, huge thighs, huge calf,bad hands, fused hand, missing hand, disappearing arms, disappearing thigh, disappearing calf, disappearing legs, fused ears, bad ears, poorly drawn ears, extra ears, liquid ears, heavy ears, missing ears, fused animal ears, bad animal ears, poorly drawn animal ears, extra animal ears, liquid animal ears, heavy animal ears, missing animal ears, text, ui, error, (((uncoordinated hands))),(((unnatural hands))),(((missing fingers))), (((missing limb))), (((fused fingers))), (((one hand with more than 5 fingers))), (((one hand with less than 5 fingers))), (((one hand with more than 5 digit))), (((one hand with less than 5 digit))), (((extra digit))), (((fewer digits))), (((fused digit))), (((missing digit))), (((bad digit))), (((liquid digit))), colorful tongue, black tongue, cropped, watermark, username, blurry, JPEG artifacts, signature, 3D, 3D game, 3D game scene, 3D character, malformed feet, extra feet, bad feet, poorly drawn feet, fused feet, missing feet, extra shoes, bad shoes, fused shoes, more than two shoes, poorly drawn shoes, bad gloves, poorly drawn gloves, fused gloves, bad cum, poorly drawn cum, fused cum, (((bad hairs))), (((poorly drawn hairs))), (((fused hairs))), big muscles, ugly, bad face, fused face, poorly drawn face, cloned face, big face, long face, bad eyes, fused eyes poorly drawn eyes, extra eyes, malformed limbs, more than 2 nipples, missing nipples, different nipples, fused nipples, bad nipples, poorly drawn nipples, black nipples, colorful nipples, gross proportions. short arm, (((missing arms))), missing thighs, missing calf, missing legs, mutation, duplicate, morbid, mutilated, (((poorly drawn hands))), (((more than 1 left hand))), (((more than 1 right hand))), deformed, (blurry), disfigured, missing legs, (((uncoordinated arms))),(((unnatural arms))),(((bad arms))),(((liquid arms))),(((strong arms))),(((extra arms))),(((more than 2 arms))), extra thighs, more than 2 thighs, extra calf, fused calf, extra legs, bad knee, extra knee, more than 2 legs, bad tails, bad mouth, fused mouth, poorly drawn mouth, bad tongue, tongue within mouth, too long tongue, black tongue, big mouth, cracked mouth, bad mouth, dirty face, dirty teeth, dirty pantie, fused pantie, poorly drawn pantie, fused cloth, poorly drawn cloth, bad pantie, yellow teeth, thick lips, bad cameltoe, colorful cameltoe, bad asshole, poorly drawn asshole, fused asshole, missing asshole, bad anus, bad pussy, bad crotch, bad crotch seam, fused anus, fused pussy, fused anus, fused crotch, poorly drawn crotch, fused seam, poorly drawn anus, poorly drawn pussy, poorly drawn crotch, poorly drawn crotch seam, bad thigh gap, missing thigh gap, fused thigh gap, liquid thigh gap, poorly drawn thigh gap, poorly drawn anus, bad collarbone, fused collarbone, missing collarbone, liquid collarbone, strong girl, obesity, worst quality, low quality, normal quality, liquid tentacles, bad tentacles, poorly drawn tentacles, split tentacles, fused tentacles, missing clit, bad clit, fused clit, colorful clit, black clit, liquid clit, QR code, bar code, censored, safety panties, safety knickers, beard, furry ,pony, pubic hair, mosaic, excrement, faeces, shit, futa, testis 其他参数 Steps: 20, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 1724776434, Size: 984x512, Model hash: 812cd9f9d9, Model: anythingV3_fp16 换成三次元模型 基本常识就到这了，其他的具体探索移步到 AI 绘画界面 # 网站推荐 下面是我自己整理的 AI 绘画网站，希望对大家有所帮助 https://novelai.dev/ novel ai 搭建教程 作品存档 傻瓜式教程 可用关键词一览 元素法典 鳖哲法典 tag 在线生成器 tag 词典 NovelAI 法术解析 NovelAI 资源整合 标签超市 googleNovelAI 法术书 naifu (google 云盘) 模型总结","tags":""},{"title":"AI绘画","url":"/AIpainting/index.html","text":"# 前言 本页面基本就是相当于我的学习日记，在 AI 学习页面中安装了 webUI 一些模型，接下来就是自己的慢慢探索 # 扩展安装 点击 “Extensions”, 可以安装一些扩展 目前我已安装了如下扩展，可以将这些网址分别复制点击从网址安装，主要包括了 controlnet，汉化，中文 tag 补齐，UP scale (画质优化) https://jihulab.com/hunter0725/a1111-sd-webui-tagcomplete https://jihulab.com/hunter0725/sd-webui-additional-networks.git https://ghproxy.com/https://github.com/journey-ad/sd-webui-bilingual-localization.git https://ghproxy.com/https://github.com/Mikubill/sd-webui-controlnet.git https://jihulab.com/hunter0725/stable-diffusion-webui-localization-zh_CN https://ghproxy.com/https://github.com/Coyote-A/ultimate-upscale-for-automatic1111.git # 模型相关研究 本节主要是不同模型的探讨 # 初步试验 本小节主要是看一下不同模型之间的区别 在指令之前，需要改一个地方 webUI 的 tag 权重是 (), 代表强化 1.1，naifu 的是 {}, 强化 1.05，所以我们在其他网站找到了现成指令有的时候是 (), 有的时候是 {}, 那么我们可以修改 modules/sd_hijack_clip.py, 加上 {} 的权重 我们可以在 https://huggingface.co/ 和 https://civitai.com/ 下载想要的模型，需要注意，一般模型的大小都会大于 1G 左右，大小不够的一般是 Lora 了，下载好的模型放到 models/Stable-diffusion 下即可加载 首先让我们试一下元素法典的冰系改 正面 tag (((masterpiece))),best quality, illustration,(beautiful detailed girl),beautiful detailed glow,detailed ice,beautiful detailed water,(beautiful detailed eyes),expressionless,beautiful detailed white gloves, (floating palaces:1.2),azure hair,disheveled hair,long bangs, hairs between eyes, (skyblue dress),black ribbon,white bowties,midriff,&#123;&#123;&#123;half closed eyes&#125;&#125;&#125;,,big forhead,blank stare,flower,large top sleeves,(((ice crystal texture wings))),&#123;&#123;&#123;&#123;&#123;&#123;&#123;Iridescence and rainbow hair:2.5&#125;&#125;&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;&#123;detailed cute anime face&#125;&#125;&#125;&#125;&#125;&#125;,&#123;&#123;loli&#125;&#125;,&#123;&#123;&#123;&#123;watercolor_(medium)&#125;&#125;&#125;&#125;,(((masterpiece))) 反面 tag： &#123;&#123;&#123;ugly&#125;&#125;&#125;,&#123;&#123;&#123;duplicate&#125;&#125;&#125;,&#123;&#123;morbid&#125;&#125;,&#123;&#123;mutilated&#125;&#125;,&#123;&#123;&#123;tranny&#125;&#125;&#125;,mutated hands,&#123;&#123;&#123;poorly drawn hands&#125;&#125;&#125;,blurry,&#123;&#123;bad anatomy&#125;&#125;,&#123;&#123;&#123;bad proportions&#125;&#125;&#125;,extra limbs,cloned face,&#123;&#123;&#123;disfigured&#125;&#125;&#125;,&#123;&#123;&#123;more than 2 nipples&#125;&#125;&#125;,&#123;&#123;&#123;&#123;missing arms&#125;&#125;&#125;&#125;,&#123;&#123;&#123;extra legs&#125;&#125;&#125;,mutated hands,&#123;&#123;&#123;&#123;&#123;fused fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;too many fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;unclear eyes&#125;&#125;&#125;,lowers,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,bad 使用 anythingV4.5 (动漫类) anythingV3 (动漫类) AOM3A3 (油画 + 动漫) Basil_mix_fixxed(2.5D) chilloutmixNI(3D) 个人感觉二次元画风 AnythingV3 的看起来最舒服 # Lora 使用方法 LoRA 是一种微调模型，可以让我们生成某些特定角色，非常实用，一般后缀为 pt (或者 safetensors)，一般为几十 M 或者一两百 M 首先我们在 https://civitai.com/ 上下载想要的模型，还有个最常用的 koreanDollLikeness 下载好的模型文献放到 models/Lora 文件夹下，在 generate 下方有个红色按钮点击之后即可使用，就会看到正面 tag 出现一个 &lt;&gt; 的关键词，lora:yaeMikoRealistic_yaemikoMixed:1， 这个 1 代表的是权重，可以从 0 开始 然后我们可以用 webui 的图片信息查看功能将网站上的图片拖进去查看关键词以及模型 或者可以试试我这边的右图 也可以多个 Lora 模型一起使用，下图是加了 0.3 权重的 koreanDollLikeness","tags":""},{"title":"AI图包","url":"/AIfile/index.html","text":"# 使用方法 本页面是整理的自我感觉效果不错的成品 (4K) 画质，解压密码是我博客主页下面的一行小字 (也可以在‘关于’界面看到)，解压后的原图可以直接用 WebUI 识别所有 tag # 图包 # 链接在这→所有图包←链接在这，目前更新的图包见下图 ++ 链接炸了请及时留言反馈 ++ 鼠标悬停到相应图片即可查看名称 目前已上传：次生银翼，洛琪希，雪乃深冬 # 废话 # 大家可以在博客评论区和 B 站交流，我主要还是以学业为主，AI 绘画属于业余爱好，只会点基础的东西","tags":""},{"title":"AIbookmark","url":"/AIbookmark/index.html","text":"","tags":""},{"title":"links","url":"/links/index.html","text":"可以申请友链，评论区提供如下格式 - site: #网站的名字 owner: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片 color: #方块颜色 Mushroom Monkey 蘑菇摄影骨灰粉，喜欢帮大家鉴定蘑菇图片，要是有标本就更好了","tags":""},{"title":"关于我","url":"/about/index.html","text":"# Hello, 我是周小钊，目前在昆明植物研究所学习，一位快要秃头的研究生，生信小菜鸟，主要分享一些自己的学习过程，预防遗忘，也欢迎大家一起来学习交流。 # 闲暇喜欢看动漫，制作面食 (作为一个北方人感觉昆明的馒头太软，不如自己做)，目前博客和简书是我的主战场，大家可以在这两个地方找到我。 # # 联系方式 邮箱：zhoushizhao@mail.kib.ac.cn QQ：443001574 微信：keyancaijizhousz 地址：昆明市盘龙区蓝黑路 132 号中国科学院昆明植物研究所 解压密码：前天是小兔子，昨天是小鹿，今天是你 # 如果有生信或者搭建博客技术的问题可以一起讨论.","tags":""},{"title":"search","url":"/search/index.html","text":"","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""}]}