<!-- build time:Wed Feb 01 2023 16:39:25 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="小钊の笔记" href="https://www.zhouxiaozhao.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="小钊の笔记" href="https://www.zhouxiaozhao.cn/atom.xml"><link rel="alternate" type="application/json" title="小钊の笔记" href="https://www.zhouxiaozhao.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="R_study,R_For_Data_science"><link rel="canonical" href="https://www.zhouxiaozhao.cn/2020/07/25/2020-07-25-R4ds2/"><title>R 数据科学笔记：2 - R | Zhou Xiaozhao = 小钊の笔记 = 前天是小兔子，昨天是小鹿，今天是你</title><meta name="generator" content="Hexo 5.4.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">R 数据科学笔记：2</h1><div class="meta"><span class="item" title="创建时间：2020-07-25 18:38:45"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-07-25T18:38:45+08:00">2020-07-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>23k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>21 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Zhou Xiaozhao</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/udJuerr1.jpg"></li><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/y8HR7QqH.jpg"></li><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/hfj9YBy8.jpg"></li><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/ljlU8tAi.jpg"></li><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/VQ55dxFh.jpg"></li><li class="item" data-background-image="https://img1.imgtp.com/2023/02/01/ky7B2xxW.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/R/" itemprop="item" rel="index" title="分类于 R"><span itemprop="name">R</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zhouxiaozhao.cn/2020/07/25/2020-07-25-R4ds2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="amane"><meta itemprop="description" content="前天是小兔子，昨天是小鹿，今天是你, 生物学在读博士"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小钊の笔记"></span><div class="body md" itemprop="articleBody"><h1 id="第二章-工作流基础"><a class="anchor" href="#第二章-工作流基础">#</a> 第二章 工作流：基础</h1><h2 id="21-代码基础"><a class="anchor" href="#21-代码基础">#</a> 2.1 代码基础</h2><p>首先，我们可以将 R 当做计算器使用</p><pre><code>&gt; 1 / 200 * 30
[1] 0.15
&gt; (59 + 73 + 2) / 3
[1] 44.66667
&gt; sin(pi / 2)
[1] 1
</code></pre><p>使用 &lt;- 来创建新对象：</p><pre><code>x &lt;- 3 * 4
</code></pre><p>创建对象的所有 R 语句（即赋值语句）都有同样的形式：</p><pre><code>object_name &lt;- value
</code></pre><p>在阅读这行代码时，你可以在脑海中默念 “某个对象名得到了某个值”。如果你觉得 “&lt;-” 太繁琐你可以使用 RStudio 快捷键：Alt+-（Alt 加上减号）。</p><h2 id="22-对象名称"><a class="anchor" href="#22-对象名称">#</a> 2.2 对象名称</h2><p>对象名称必须以字母开头，并且只能包含字母、数字、_ 和.。如果想让对象名称具有描述性，那么就应该在使用多个单词时遵循某种命名惯例。我推荐使用 snake_case 命名法，也就是使用小写单词，并用_ 分隔：</p><pre><code>i_use_snake_case
otherPeopleUseCamelCase
some.people.use.periods
And_aFew.People_RENOUNCEconvention
</code></pre><p>可以通过输入对象名称来查看这个对象：</p><pre><code>&gt; x
[1] 12
</code></pre><p>再进行一次赋值：</p><pre><code>r_rocks &lt;- 2 ^ 3
## 查看一下这个对象
r_rock
#&gt; Error: object 'r_rock' not found
R_rocks
#&gt; Error: object 'R_rocks' not found
</code></pre><h2 id="23-函数调用"><a class="anchor" href="#23-函数调用">#</a> 2.3　函数调用</h2><p>R 中有大量内置函数。调用方式如下：</p><pre><code>function_name(arg1 = val1, arg2 = val2, ...)
</code></pre><p>我们尝试使用 seq () 函数，输入参数 1, 10:</p><pre><code>&gt; seq(1,10)
 [1]  1  2  3  4  5  6  7  8  9 10
</code></pre><p>输入以下代码，你会发现 RStudio 也会自动完成一对双引号以方便输入：</p><pre><code>x &lt;- &quot;hello world&quot;
</code></pre><p>引号和括号必须一直成对出现。RStudio 会尽力帮助我们，但还是有出错并导致不匹配的可能。如果出现不匹配，R 会显示一个 + 号：</p><pre><code>&gt; x &lt;- &quot;hello
+
</code></pre><p>+ 号表明 R 在等待继续输入；它认为你还没有完成输入。这通常意味着你漏掉了一个 &quot; 或者)。</p><p>如果进行了一次赋值，R 不会显示出赋值结果。你最好立刻检查一下：</p><pre><code>&gt; y &lt;- seq(1, 10, length.out = 5)
&gt; y
[1]  1.00  3.25  5.50  7.75 10.00
## 或者采取简化方式
&gt; (y &lt;- seq(1, 10, length.out = 5))
[1]  1.00  3.25  5.50  7.75 10.00
</code></pre><h1 id="第三章-使用dplyr进行数据转换"><a class="anchor" href="#第三章-使用dplyr进行数据转换">#</a> 第三章 使用 dplyr 进行数据转换</h1><h2 id="31-简介"><a class="anchor" href="#31-简介">#</a> 3.1 简介</h2><p>本章将用 dplyr 包来转换数据，并介绍一个新的数据集：2013 年从纽约市出发的航班信息。</p><h3 id="311-准备工作"><a class="anchor" href="#311-准备工作">#</a> 3.1.1 准备工作</h3><p>本章将重点讨论如何使用 tidyverse 中的另一个核心 R 包 ——dplyr 包。我们使用 nycflights13 包中的数据来说明 dplyr 包的核心理念，并使用 ggplot2 来帮助我们理解数据。</p><h3 id="312-nycflights13"><a class="anchor" href="#312-nycflights13">#</a> 3.1.2 nycflights13</h3><p>使用 nycflights13::flights。这个数据框包含了 2013 年从纽约市出发的所有 336 776 次航班的信息。该数据来自于美国交通统计局，可以使用？flights 查看其说明文档：</p><pre><code>&gt; flights
# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1      517            515         2
 2  2013     1     1      533            529         4
 3  2013     1     1      542            540         2
 4  2013     1     1      544            545        -1
 5  2013     1     1      554            600        -6
 6  2013     1     1      554            558        -4
 7  2013     1     1      555            600        -5
 8  2013     1     1      557            600        -3
 9  2013     1     1      557            600        -3
10  2013     1     1      558            600        -2
# ... with 336,766 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
#   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
#   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><p>列名下面有一行 3 个或 4 个字母的缩写。它们描述了每个变量的类型。</p><p>・int 表示整数型变量。<br>・dbl 表示双精度浮点数型变量，或称实数。<br>・chr 表示字符向量，或称字符串。<br>・dttm 表示日期时间（日期 + 时间）型变量。</p><p>还有另外 3 种常用的变量类型，虽然没有在这个数据集中出现，但很快就会在本书后面遇到。<br>・lgl 表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。<br>・fctr 表示因子，R 用其来表示具有固定数目的值的分类变量。<br>・date 表示日期型变量。</p><h3 id="313-dplyr基础"><a class="anchor" href="#313-dplyr基础">#</a> 3.1.3 dplyr 基础</h3><p>5 个 dplyr 核心函数：</p><p>・按值筛选观测（filter ()）。<br>・对行进行重新排序（arrange ()）。<br>・按名称选取变量（select ()）。<br>・使用现有变量的函数创建新变量（mutate ()）。<br>・将多个值总结为一个摘要统计量（summarize ()）。</p><p>这些函数都可以和 group_by () 函数联合起来使用，group_by () 函数可以改变以上每个函数的作用范围，让其从在整个数据集上操作变为在每个分组上分别操作。这 6 个函数构成了数据处理语言的基本操作。</p><p>前面 5 个函数的工作方式都是相同的。<br>(1) 第一个参数是一个数据框。<br>(2) 随后的参数使用变量名称（不带引号）描述了在数据框上进行的操作。<br>(3) 输出结果是一个新数据框。<br>利用以上这些属性可以很轻松地将多个简单步骤链接起来，从而得到非常复杂的结果。接下来我们将深入了解，看看如何使用这些操作。</p><h2 id="32-使用filter筛选行"><a class="anchor" href="#32-使用filter筛选行">#</a> 3.2　使用 filter () 筛选行</h2><p>filter () 函数可以基于观测的值筛选出一个观测子集。第一个参数是数据框名称，第二个参数以及随后的参数是用来筛选数据框的表达式。例如，我们可以使用以下代码筛选出 1 月 1 日的所有航班：</p><pre><code>&gt; jan1 &lt;-filter(flights, month == 1, day == 1)
&gt; jan1
# A tibble: 842 x 19
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1      517            515         2
 2  2013     1     1      533            529         4
 3  2013     1     1      542            540         2
 4  2013     1     1      544            545        -1
 5  2013     1     1      554            600        -6
 6  2013     1     1      554            558        -4
 7  2013     1     1      555            600        -5
 8  2013     1     1      557            600        -3
 9  2013     1     1      557            600        -3
10  2013     1     1      558            600        -2
# ... with 832 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
#   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
#   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><h3 id="321-比较运算符"><a class="anchor" href="#321-比较运算符">#</a> 3.2.1 比较运算符</h3><p>R 提供了一套标准的比较运算符：&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于）。当开始使用 R 时，最容易犯的错误就是使用 = 而不是 == 来测试是否相等。</p><p>在使用 == 进行比较时，你可能还会遇到另一个常见问题：浮点数。</p><pre><code>&gt; sqrt(2)^2==2
[1] FALSE
&gt; 1/49*49==1
[1] FALSE
</code></pre><h3 id="322-逻辑运算符"><a class="anchor" href="#322-逻辑运算符">#</a> 3.2.2 逻辑运算符</h3><p>filter () 中的多个参数是由 “与” 组合起来的：每个表达式都必须为真才能让一行观测包<br>含在输出中。如果要实现其他类型的组合，你需要使用布尔运算符：&amp; 表示 “与”、| 表示<br>“或”、! 表示 “非”。</p><p><img data-src="/img/posts/7.25/image-20200728161522039.png" alt="image-20200728161522039"></p><p>以下代码可以找出 11 月或 12 月出发的所有航班：</p><pre><code>filter(flights, month == 11 | month == 12)
</code></pre><p>不能写成 filter (flights, month == 11 |12) 这种形式。这种形式的文字翻译确实是 “找出 11 月或 12 月出发的所有航班”，但在代码中则不是这个意思，代码中的含义是找出所有出发月份为 11 | 12 的航班。11 | 12 这个逻辑表达式的值为 TRUE，在数字语境中（如本例），TRUE 就是 1，所以这段代码找出的不是 11 月或 12 月出发的航班，而是 1 月出发的所有航班。</p><p>这种问题有一个有用的简写形式：x % in% y。这会选取出 x 是 y 中的一个值时的所有行。<br>我们可以使用这种形式重写上面的代码：</p><pre><code>nov_dec &lt;- filter(flights, month %in% c(11, 12))
</code></pre><p>可以使用德摩根定律将复杂的筛选条件进行简化：!(x &amp; y) 等价于！x | !y、!(x |y) 等价于！x &amp; !y。例如，如果想要找出延误时间（到达或出发）不多于 2 小时的航班，那么使用以下两种筛选方式均可：</p><pre><code>filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120))
filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120)
</code></pre><p>filter () 函数中使用的是复杂的、包含多个部分的表达式，就需要考虑用一个明确的变量来代替它。这样检查代码会容易很多。我们很快就会介绍如何创建新变量。</p><h3 id="323-缺失值"><a class="anchor" href="#323-缺失值">#</a> 3.2.3 缺失值</h3><p>R 的一个重要特征使得比较运算更加复杂，这个特征就是缺失值，或称 NA（not available，不可用）。如果运算中包含了未知值，那么运算结果一般来说也是个未知值：</p><pre><code>&gt; NA + 10
[1] NA
&gt; NA / 2
[1] NA
</code></pre><p>如果想要确定一个值是否为缺失值，<span class="exturl" data-url="aHR0cDovL3huLS1pcy1oZjNjd3dvMXBjNzFkLm5h">可以使用 is.na</span> () 函数：</p><pre><code>&gt; x &lt;- NA
&gt; is.na(x)
[1] TRUE
</code></pre><p>filter () 只能筛选出条件为 TRUE 的行；它会排除那些条件为 FALSE 和 NA 的行。如果想保留缺失值，可以明确指出：</p><pre><code>&gt; df &lt;- tibble(x = c(1, NA, 3))
&gt; filter(df, x &gt; 1)
# A tibble: 1 x 1
      x
  &lt;dbl&gt;
1     3
&gt; filter(df, is.na(x) | x &gt; 1)
# A tibble: 2 x 1
      x
  &lt;dbl&gt;
1    NA
2     3
</code></pre><h2 id="33-使用arrange排列行"><a class="anchor" href="#33-使用arrange排列行">#</a> 3.3 使用 arrange () 排列行</h2><p>arrange () 函数的工作方式与 filter () 函数非常相似，但前者不是选择行，而是改变行的顺序。它接受一个数据框和一组作为排序依据的列名（或者更复杂的表达式）作为参数。如果列名不只一个，那么就使用后面的列在前面排序的基础上继续排序：</p><pre><code>&gt; arrange(flights, year, month, day)
# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1      517            515         2
 2  2013     1     1      533            529         4
 3  2013     1     1      542            540         2
 4  2013     1     1      544            545        -1
 5  2013     1     1      554            600        -6
 6  2013     1     1      554            558        -4
 7  2013     1     1      555            600        -5
 8  2013     1     1      557            600        -3
 9  2013     1     1      557            600        -3
10  2013     1     1      558            600        -2
# ... with 336,766 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
#   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
#   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><p>使用 desc () 可以按列进行降序排序：</p><pre><code>&gt; arrange(flights, desc(arr_delay))
# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     9      641            900      1301
 2  2013     6    15     1432           1935      1137
 3  2013     1    10     1121           1635      1126
 4  2013     9    20     1139           1845      1014
 5  2013     7    22      845           1600      1005
 6  2013     4    10     1100           1900       960
 7  2013     3    17     2321            810       911
 8  2013     7    22     2257            759       898
 9  2013    12     5      756           1700       896
10  2013     5     3     1133           2055       878
# ... with 336,766 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
#   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
#   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><p>缺失值总是排在最后：</p><pre><code>&gt; df &lt;- tibble(x = c(5, 2, NA))
&gt; arrange(df, x)
# A tibble: 3 x 1
      x
  &lt;dbl&gt;
1     2
2     5
3    NA
</code></pre><h2 id="34-使用select选择列"><a class="anchor" href="#34-使用select选择列">#</a> 3.4 使用 select () 选择列</h2><p>如今，数据集有几百甚至几千个变量已经司空见惯。这种情况下，如何找出真正感兴趣的那些变量经常是我们面临的第一个挑战。通过基于变量名的操作，select () 函数可以让你快速生成一个有用的变量子集。</p><pre><code># 按名称选择列
&gt; select(flights, year, month, day)
# A tibble: 336,776 x 3
    year month   day
   &lt;int&gt; &lt;int&gt; &lt;int&gt;
 1  2013     1     1
 2  2013     1     1
 3  2013     1     1
 4  2013     1     1
 5  2013     1     1
 6  2013     1     1
 7  2013     1     1
 8  2013     1     1
 9  2013     1     1
10  2013     1     1
# ... with 336,766 more rows
# 选择“year”和“day”之间的所有列
&gt; select(flights, year:day)
# A tibble: 336,776 x 3
    year month   day
   &lt;int&gt; &lt;int&gt; &lt;int&gt;
 1  2013     1     1
 2  2013     1     1
 3  2013     1     1
 4  2013     1     1
 5  2013     1     1
 6  2013     1     1
 7  2013     1     1
 8  2013     1     1
 9  2013     1     1
10  2013     1     1
# ... with 336,766 more rows
# 选择不在“year”和“day”之间的列
&gt; select(flights, -(year:day))
# A tibble: 336,776 x 16
   dep_time sched_dep_time dep_delay arr_time sched_arr_time
      &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
 1      517            515         2      830            819
 2      533            529         4      850            830
 3      542            540         2      923            850
 4      544            545        -1     1004           1022
 5      554            600        -6      812            837
 6      554            558        -4      740            728
 7      555            600        -5      913            854
 8      557            600        -3      709            723
 9      557            600        -3      838            846
10      558            600        -2      753            745
# ... with 336,766 more rows, and 11 more variables:
#   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
#   time_hour &lt;dttm&gt;
</code></pre><p>还可以在 select () 函数中使用一些辅助函数。<br>・starts_with (&quot;abc&quot;)：匹配以 “abc” 开头的名称。<br>・ends_with (&quot;xyz&quot;)：匹配以 “xyz” 结尾的名称。<br>・contains (&quot;ijk&quot;)：匹配包含 “ijk” 的名称。<br>・matches (&quot;(.)\1&quot;)：选择匹配正则表达式的那些变量。这个正则表达式会匹配名称中有重复字符的变量。你将在第 10 章中学习到更多关于正则表达式的知识。<br>・num_range (&quot;x&quot;, 1:3)：匹配 x1、x2 和 x3。</p><p>使用 select () 函数的变体 rename () 函数来重命名变量，以保留所有未明确提及的变量：</p><pre><code>&gt; rename(flights, tail_num = tailnum)
# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1      517            515         2
 2  2013     1     1      533            529         4
 3  2013     1     1      542            540         2
 4  2013     1     1      544            545        -1
 5  2013     1     1      554            600        -6
 6  2013     1     1      554            558        -4
 7  2013     1     1      555            600        -5
 8  2013     1     1      557            600        -3
 9  2013     1     1      557            600        -3
10  2013     1     1      558            600        -2
# ... with 336,766 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tail_num &lt;chr&gt;,
#   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><p>另一种用法是将 select () 函数和 everything () 辅助函数结合起来使用。当想要将几个变量移到数据框开头时，这种用法非常奏效</p><pre><code>&gt; select(flights, time_hour, air_time, everything())
# A tibble: 336,776 x 19
   time_hour           air_time  year month   day dep_time
   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
 1 2013-01-01 05:00:00      227  2013     1     1      517
 2 2013-01-01 05:00:00      227  2013     1     1      533
 3 2013-01-01 05:00:00      160  2013     1     1      542
 4 2013-01-01 05:00:00      183  2013     1     1      544
 5 2013-01-01 06:00:00      116  2013     1     1      554
 6 2013-01-01 05:00:00      150  2013     1     1      554
 7 2013-01-01 06:00:00      158  2013     1     1      555
 8 2013-01-01 06:00:00       53  2013     1     1      557
 9 2013-01-01 06:00:00      140  2013     1     1      557
10 2013-01-01 06:00:00      138  2013     1     1      558
# ... with 336,766 more rows, and 13 more variables:
#   sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;,
#   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
#   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;
</code></pre><h2 id="35-使用mutate添加新变量"><a class="anchor" href="#35-使用mutate添加新变量">#</a> 3.5 使用 mutate () 添加新变量</h2><p>除了选择现有的列，我们还经常需要添加新列，新列是现有列的函数。这就是 mutate () 函数的作用。</p><p>mutate () 总是将新列添加在数据集的最后，因此我们需要先创建一个更狭窄的数据集，以便能够看到新变量。记住，当使用 RStudio 时，查看所有列的最简单的方法就是使用 View () 函数：</p><pre><code>flights_sml &lt;- select(flights,
                      year:day,
                      ends_with(&quot;delay&quot;),
                      distance,
                      air_time
)
mutate(flights_sml,
       gain = arr_delay - dep_delay,
       speed = distance / air_time * 60
)
# A tibble: 336,776 x 9
    year month   day dep_delay arr_delay distance air_time
   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
 1  2013     1     1         2        11     1400      227
 2  2013     1     1         4        20     1416      227
 3  2013     1     1         2        33     1089      160
 4  2013     1     1        -1       -18     1576      183
 5  2013     1     1        -6       -25      762      116
 6  2013     1     1        -4        12      719      150
 7  2013     1     1        -5        19     1065      158
 8  2013     1     1        -3       -14      229       53
 9  2013     1     1        -3        -8      944      140
10  2013     1     1        -2         8      733      138
# ... with 336,766 more rows, and 2 more variables:
#   gain &lt;dbl&gt;, speed &lt;dbl&gt;
</code></pre><p>一旦创建，新列就可以立即使用：</p><pre><code>&gt; mutate(flights_sml,
+        gain = arr_delay - dep_delay,
+        hours = air_time / 60,
+        gain_per_hour = gain / hours
+ )
# A tibble: 336,776 x 10
    year month   day dep_delay arr_delay distance air_time
   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
 1  2013     1     1         2        11     1400      227
 2  2013     1     1         4        20     1416      227
 3  2013     1     1         2        33     1089      160
 4  2013     1     1        -1       -18     1576      183
 5  2013     1     1        -6       -25      762      116
 6  2013     1     1        -4        12      719      150
 7  2013     1     1        -5        19     1065      158
 8  2013     1     1        -3       -14      229       53
 9  2013     1     1        -3        -8      944      140
10  2013     1     1        -2         8      733      138
# ... with 336,766 more rows, and 3 more variables:
#   gain &lt;dbl&gt;, hours &lt;dbl&gt;, gain_per_hour &lt;dbl&gt;
</code></pre><p>如果只想保留新变量，可以使用 transmute () 函数：</p><pre><code>&gt; transmute(flights,
+           gain = arr_delay - dep_delay,
+           hours = air_time / 60,
+           gain_per_hour = gain / hours
+ )
# A tibble: 336,776 x 3
    gain hours gain_per_hour
   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
 1     9 3.78           2.38
 2    16 3.78           4.23
 3    31 2.67          11.6
 4   -17 3.05          -5.57
 5   -19 1.93          -9.83
 6    16 2.5            6.4
 7    24 2.63           9.11
 8   -11 0.883        -12.5
 9    -5 2.33          -2.14
10    10 2.3            4.35
# ... with 336,766 more rows
</code></pre><h3 id="351-常用创建函数"><a class="anchor" href="#351-常用创建函数">#</a> 3.5.1 常用创建函数</h3><p>创建新变量的多种函数可供你同 mutate () 一同使用。最重要的一点是，这种函数必须是向量化的：它必须接受一个向量作为输入，并返回一个向量作为输出，而且输入向量与输出向量具有同样数目的分量。我们无法列出所有可能用到的创建函数，但可以介绍一下那些比较常用的。</p><p><strong>算术运算符：+、-、*、/、^</strong></p><p>它们都是向量化的，使用所谓的 “循环法则”。如果一个参数比另一个参数短，那么前者会自动扩展到同样的长度。当某个参数是单个数值时，这种方式是最有效的：air_time / 60、hours * 60 + minute 等。<br>算术运算符的另一用途是与我们后面将很快学到的聚集函数结合起来使用。例如，x /sum (x) 可以计算出各个分量在总数中的比例，y – mean (y) 可以计算出分量与均值之间的差值。</p><p><strong>模运算符：%/% 和 %%</strong><br>%/%（整数除法）和 %%（求余）满足 x == y * (x %/% y) + (x %% y)。模运算非常好用，因为它可以拆分整数。例如，在航班数据集中，你可以根据 dep_time 计算出 hour 和 minute：</p><pre><code>&gt; transmute(flights,
+           dep_time,
+           hour = dep_time %/% 100,
+           minute = dep_time %% 100
+ )
# A tibble: 336,776 x 3
   dep_time  hour minute
      &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;
 1      517     5     17
 2      533     5     33
 3      542     5     42
 4      544     5     44
 5      554     5     54
 6      554     5     54
 7      555     5     55
 8      557     5     57
 9      557     5     57
10      558     5     58
# ... with 336,766 more rows
</code></pre><p><strong>对数函数：log ()、log2 () 和 log10 ()</strong></p><p>​ 在处理取值范围横跨多个数量级的数据时，对数是特别有用的一种转换方式。它还可以将乘法转换成加法，我们将在本书的第四部分中介绍这个功能。<br>​ 其他条件相同的情况下，我推荐使用 log2 () 函数，因为很容易对其进行解释：对数标度的数值增加 1 个单位，意味着初始数值加倍；减少 1 个单位，则意味着初始数值减半。</p><p><strong>偏移函数</strong></p><p>​ lead () 和 lag</p><p>() 函数可以返回一个序列的领先值和滞后值。它们可以计算出序列的移动差值（如 x – lag (x)）或发现序列何时发生了变化（x != lag (x)）。它们与 group_by () 组合使用时特别有用，你很快就会学到 group_by () 这个函数：</p><pre><code>&gt; (x &lt;- 1:10)
 [1]  1  2  3  4  5  6  7  8  9 10
&gt; lag(x)
 [1] NA  1  2  3  4  5  6  7  8  9
&gt; lead(x)
 [1]  2  3  4  5  6  7  8  9 10 NA
</code></pre><p>** 累加和滚动聚合 **</p><p>R 提供了计算累加和、累加积、累加最小值和累加最大值的函数：cumsum ()、cumprod ()、commin () 和 cummax ()；dplyr 还提供了 cummean () 函数以计算累加均值。</p><pre><code>&gt; x
 [1]  1  2  3  4  5  6  7  8  9 10
&gt; cumsum(x)
 [1]  1  3  6 10 15 21 28 36 45 55
&gt; cummean(x)
 [1] 1.000000 1.000000 1.333333 1.750000 2.200000 2.666667
 [7] 3.142857 3.625000 4.111111 4.600000
</code></pre><p><strong>逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和！=</strong></p><p>如果需要进行一系列复杂的逻辑运算，那么最好将中间结果保存在新变量中，这样就可以检查是否每一步都符合预期。</p><p><strong>排秩</strong></p><p>排秩函数有很多，但你应该从 min_rank () 函数开始，它可以完成最常用的排秩任务（如第一、第二、第三、第四）。默认的排秩方式是，最小的值获得最前面的名次，使用 desc (x) 可以让最大的值获得最前面的名次</p><pre><code>&gt; y &lt;- c(1, 2, 2, NA, 3, 4)
&gt; min_rank(y)
[1]  1  2  2 NA  4  5
&gt; min_rank(desc(y))
[1]  5  3  3 NA  2  1
</code></pre><p>如果 min_rank () 无法满足需要，那么可以看一下其变体 row_number ()、dense_rank ()、percent_rank ()、cume_dist () 和 ntile ()。</p><pre><code>&gt; row_number(y)
[1]  1  2  3 NA  4  5
&gt; dense_rank(y)
[1]  1  2  2 NA  3  4
&gt; percent_rank(y)
[1] 0.00 0.25 0.25   NA 0.75 1.00
&gt; cume_dist(y)
[1] 0.2 0.6 0.6  NA 0.8 1.0
</code></pre><h2 id="36-使用summarize进行分组摘要"><a class="anchor" href="#36-使用summarize进行分组摘要">#</a> 3.6 使用 summarize () 进行分组摘要</h2><p>最后一个核心函数是 summarize ()，它可以将数据框折叠成一行。group_by () 可以将分析单位从整个数据集更改为单个分组。接下来，在分组后的数据框上使用 dplyr 函数时，它们会自动地应用到每个分组。例如，如果对按日期分组的一个数据框应用与上面完全相同的代码，那么我们就可以得到每日平均延误时间：</p><pre><code>&gt; by_day &lt;- group_by(flights, year, month, day)
&gt; summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
 1  2013     1     1 11.5
 2  2013     1     2 13.9
 3  2013     1     3 11.0
 4  2013     1     4  8.95
 5  2013     1     5  5.73
 6  2013     1     6  7.15
 7  2013     1     7  5.42
 8  2013     1     8  2.55
 9  2013     1     9  2.28
10  2013     1    10  2.84
# ... with 355 more rows
</code></pre><h3 id="361-使用管道组合多种操作"><a class="anchor" href="#361-使用管道组合多种操作">#</a> 3.6.1 使用管道组合多种操作</h3><p>假设我们想要研究每个目的地的距离和平均延误时间之间的关系。使用已经了解的 dplyr<br>包功能，你可能会写出以下代码：</p><pre><code>by_dest &lt;- group_by(flights, dest)
delay &lt;- summarize(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
)
delay &lt;- filter(delay, count &gt; 20, dest != &quot;HNL&quot;)
</code></pre><p>这样做不得不对每个中间数据框命名，会影响我们的分析速度。解决这个问题的另一种方法是使用管道，%&gt;%</p><pre><code>delays &lt;- flights %&gt;%
group_by(dest) %&gt;%
summarize(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %&gt;%
filter(count &gt; 20, dest != &quot;HNL&quot;)
</code></pre><p>使用这种方法时，x %&gt;% f (y) 会转换为 f (x, y)，x %&gt;% f (y) %&gt;% g (z) 会转换为 g (f (x,y), z)，以此类推。你可以使用管道重写多种操作，将其变为能够从左到右或从上到下阅读。</p><h3 id="362-缺失值"><a class="anchor" href="#362-缺失值">#</a> 3.6.2 缺失值</h3><p>在前面使用了参数 na.rm, 如果没有设置这个参数，会发生什么情况呢？</p><pre><code>&gt;by_day &lt;- group_by(flights, year, month, day)
&gt;summarize(by_day, delay = mean(dep_delay))
## 使用管道
&gt; flights %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(mean = mean(dep_delay))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day  mean
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
 1  2013     1     1    NA
 2  2013     1     2    NA
 3  2013     1     3    NA
 4  2013     1     4    NA
 5  2013     1     5    NA
 6  2013     1     6    NA
 7  2013     1     7    NA
 8  2013     1     8    NA
 9  2013     1     9    NA
10  2013     1    10    NA
# ... with 355 more rows
</code></pre><p>这是因为聚合函数遵循缺失值的一般规则：如果输入中有缺失值，那么输出也会是缺失值。好在所有聚合函数都有一个 na.rm 参数，它可以在计算前除去缺失值：</p><pre><code>&gt; flights %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(mean = mean(dep_delay,na.rm= TRUE))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day  mean
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
 1  2013     1     1 11.5
 2  2013     1     2 13.9
 3  2013     1     3 11.0
 4  2013     1     4  8.95
 5  2013     1     5  5.73
 6  2013     1     6  7.15
 7  2013     1     7  5.42
 8  2013     1     8  2.55
 9  2013     1     9  2.28
10  2013     1    10  2.84
# ... with 355 more rows
</code></pre><p>在这个示例中，缺失值表示取消的航班，我们也可以通过先去除取消的航班来解决缺失值<br>问题。保存这个数据集，以便我们可以在接下来的几个示例中继续使用：</p><pre><code>not_cancelled &lt;- flights %&gt;%
 filter(!is.na(dep_delay), !is.na(arr_delay))
&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(mean = mean(dep_delay))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day  mean
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
 1  2013     1     1 11.4
 2  2013     1     2 13.7
 3  2013     1     3 10.9
 4  2013     1     4  8.97
 5  2013     1     5  5.73
 6  2013     1     6  7.15
 7  2013     1     7  5.42
 8  2013     1     8  2.56
 9  2013     1     9  2.30
10  2013     1    10  2.84
# ... with 355 more rows
</code></pre><h3 id="363-计数"><a class="anchor" href="#363-计数">#</a> 3.6.3 计数</h3><p>聚合操作中包括一个计数（n ()）或非缺失值的计数（sum (!is_na ())）是个好主意。这样你就可以检查一下，以确保自己没有基于非常少量的数据作出结论。例如，我们查看一下具有最长平均延误时间的飞机（通过机尾编号进行识别）：</p><pre><code>delays &lt;- not_cancelled %&gt;%
  group_by(tailnum) %&gt;%
  summarize(
    delay = mean(arr_delay)
  )
ggplot(data = delays, mapping = aes(x = delay)) +
  geom_freqpoly(binwidth = 10)
</code></pre><p><img data-src="/img/posts/7.25/image-20200728200043781.png" alt="image-20200728200043781"></p><p>接下来，画一张航班数量和平均延误时间的散点图，以便获得更深刻的理解：</p><pre><code>delays &lt;- not_cancelled %&gt;%    
  group_by(tailnum) %&gt;%  #--根据tailnum对not_cancelled分组
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()  #--根据每个组求arr_delay的平均值并计数
  )
# A tibble: 4,037 x 3
   tailnum  delay     n
   &lt;chr&gt;    &lt;dbl&gt; &lt;int&gt;
 1 D942DN  31.5       4
 2 N0EGMQ   9.98    352
 3 N10156  12.7     145
 4 N102UW   2.94     48
 5 N103US  -6.93     46
 6 N104UW   1.80     46
 7 N10575  20.7     269
 8 N105UW  -0.267    45
 9 N107US  -5.73     41
10 N108UW  -1.25     60
# ... with 4,027 more rows
ggplot(data = delays, mapping = aes(x = n, y = delay)) +
  geom_point(alpha = 1/10)
</code></pre><p><img data-src="/img/posts/7.25/image-20200728200155245.png" alt="image-20200728200155245"></p><p>当航班数量非常少时，平均延误时间的变动特别大。这张图的形状非常能够说明问题：当绘制均值（或其他摘要统计量）和分组规模的关系时，你总能看到随着样本量的增加，变动在不断减小。</p><p>查看此类图形时，通常应该筛选掉那些观测数量非常少的分组，这样你就可以避免受到特<br>别小的分组中的极端变动的影响，进而更好地发现数据模式。</p><pre><code>&gt; delays %&gt;%
+   filter(n &gt; 25) %&gt;%
+   ggplot(mapping = aes(x = n, y = delay)) +
+   geom_point(alpha = 1/10)
</code></pre><p><img data-src="/img/posts/7.25/image-20200728201342274.png" alt="image-20200728201342274"></p><h3 id="364-常用的摘要函数"><a class="anchor" href="#364-常用的摘要函数">#</a> 3.6.4 常用的摘要函数</h3><p>只使用均值、计数和求和是远远不够的，R 中还提供了很多其他的常用的摘要函数。</p><p><strong>位置度量</strong></p><p>我们已经使用过 mean (x)，但 median (x) 也非常有用。均值是总数除以个数；中位数则<br>是这样一个值：50% 的 x 大于它，同时 50% 的 x 小于它。</p><pre><code>&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(
+     # 平均延误时间：
+     avg_delay1 = mean(arr_delay),
+     # 平均正延误时间：
+     avg_delay2 = mean(arr_delay[arr_delay &gt; 0])
+   )
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 5
# Groups:   year, month [12]
    year month   day avg_delay1 avg_delay2
   &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
 1  2013     1     1     12.7         32.5
 2  2013     1     2     12.7         32.0
 3  2013     1     3      5.73        27.7
 4  2013     1     4     -1.93        28.3
 5  2013     1     5     -1.53        22.6
 6  2013     1     6      4.24        24.4
 7  2013     1     7     -4.95        27.8
 8  2013     1     8     -3.23        20.8
 9  2013     1     9     -0.264       25.6
10  2013     1    10     -5.90        27.3
# ... with 355 more rows
</code></pre><p><strong>分散程度度量：sd (x)、IQR (x) 和 mad (x)</strong></p><p>均方误差（又称标准误差，standard deviation，sd）是分散程度的标准度量方式。四分位距 IQR () 和绝对中位差 mad (x) 基本等价，更适合有离群点的情况：</p><pre><code>&gt; # 为什么到某些目的地的距离比到其他目的地更多变？
&gt; not_cancelled %&gt;%
+   group_by(dest) %&gt;%
+   summarize(distance_sd = sd(distance)) %&gt;%
+   arrange(desc(distance_sd))
`summarise()` ungrouping output (override with `.groups` argument)
# A tibble: 104 x 2
   dest  distance_sd
   &lt;chr&gt;       &lt;dbl&gt;
 1 EGE         10.5
 2 SAN         10.4
 3 SFO         10.2
 4 HNL         10.0
 5 SEA          9.98
 6 LAS          9.91
 7 PDX          9.87
 8 PHX          9.86
 9 LAX          9.66
10 IND          9.46
# ... with 94 more rows
</code></pre><p><strong>秩的度量：min (x)、quantile (x, 0.25) 和 max (x)</strong></p><p>分位数是中位数的扩展。例如，quantile (x, 0.25) 会找出 x 中按从小到大顺序大于前 25% 而小于后 75% 的值：</p><pre><code>&gt; # 每天最早和最晚的航班何时出发？
&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(
+     first = min(dep_time),
+     last = max(dep_time)
+   )
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 5
# Groups:   year, month [12]
    year month   day first  last
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
 1  2013     1     1   517  2356
 2  2013     1     2    42  2354
 3  2013     1     3    32  2349
 4  2013     1     4    25  2358
 5  2013     1     5    14  2357
 6  2013     1     6    16  2355
 7  2013     1     7    49  2359
 8  2013     1     8   454  2351
 9  2013     1     9     2  2252
10  2013     1    10     3  2320
# ... with 355 more rows
</code></pre><p><strong>定位度量：first (x)、nth (x, 2) 和 last (x)</strong></p><p>这几个函数的作用与 x [1]、x [2] 和 x [length (x)] 相同，只是当定位不存在时（比如尝试从只有两个元素的分组中得到第三个元素），前者允许你设置一个默认值。例如，我们可以找出每天最早和最晚出发的航班：</p><pre><code>&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(
+     first_dep = first(dep_time),
+     last_dep = last(dep_time)
+   )
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 5
# Groups:   year, month [12]
    year month   day first_dep last_dep
   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
 1  2013     1     1       517     2356
 2  2013     1     2        42     2354
 3  2013     1     3        32     2349
 4  2013     1     4        25     2358
 5  2013     1     5        14     2357
 6  2013     1     6        16     2355
 7  2013     1     7        49     2359
 8  2013     1     8       454     2351
 9  2013     1     9         2     2252
10  2013     1    10         3     2320
# ... with 355 more rows
</code></pre><p><strong>计数</strong></p><p>已经使用过 n ()，它不需要任何参数，并返回当前分组的大小。如果想要计算出非缺失值的数量，可以使用 sum (!<span class="exturl" data-url="aHR0cDovL2lzLm5h">is.na</span> (x))。要想计算出唯一值的数量，可以使用 n_distinct (x)：</p><pre><code>&gt; # 哪个目的地具有最多的航空公司？
&gt; not_cancelled %&gt;%
+   group_by(dest) %&gt;%
+   summarize(carriers = n_distinct(carrier)) %&gt;%
+   arrange(desc(carriers))
`summarise()` ungrouping output (override with `.groups` argument)
# A tibble: 104 x 2
   dest  carriers
   &lt;chr&gt;    &lt;int&gt;
 1 ATL          7
 2 BOS          7
 3 CLT          7
 4 ORD          7
 5 TPA          7
 6 AUS          6
 7 DCA          6
 8 DTW          6
 9 IAD          6
10 MSP          6
# ... with 94 more rows
</code></pre><p>因为计数太常用了，所以 dplyr 提供了一个简单的辅助函数，用于只需要计数的情况：</p><pre><code>&gt; not_cancelled %&gt;%
+   count(dest)
# A tibble: 104 x 2
   dest      n
   &lt;chr&gt; &lt;int&gt;
 1 ABQ     254
 2 ACK     264
 3 ALB     418
 4 ANC       8
 5 ATL   16837
 6 AUS    2411
 7 AVL     261
 8 BDL     412
 9 BGR     358
10 BHM     269
# ... with 94 more rows
</code></pre><p>还可以选择提供一个加权变量。例如，你可以使用以下代码算出每架飞机飞行的总里程数（实际上就是求和）：</p><pre><code>&gt; not_cancelled %&gt;%
+   count(tailnum, wt = distance)
# A tibble: 4,037 x 2
   tailnum      n
   &lt;chr&gt;    &lt;dbl&gt;
 1 D942DN    3418
 2 N0EGMQ  239143
 3 N10156  109664
 4 N102UW   25722
 5 N103US   24619
 6 N104UW   24616
 7 N10575  139903
 8 N105UW   23618
 9 N107US   21677
10 N108UW   32070
# ... with 4,027 more rows
</code></pre><p><strong>逻辑值的计数和比例：sum (x&gt; 10) 和 mean (y == 0)</strong></p><p>当与数值型函数一同使用时，TRUE 会转换为 1，FALSE 会转换为 0。这使得 sum () 和 mean () 非常适用于逻辑值：sum (x) 可以找出 x 中 TRUE 的数量，mean (x) 则可以找出比例。</p><pre><code>&gt; # 多少架航班是在早上5点前出发的？（这通常表明前一天延误的航班数量）
&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(n_early = sum(dep_time &lt; 500))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day n_early
   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
 1  2013     1     1       0
 2  2013     1     2       3
 3  2013     1     3       4
 4  2013     1     4       3
 5  2013     1     5       3
 6  2013     1     6       2
 7  2013     1     7       2
 8  2013     1     8       1
 9  2013     1     9       3
10  2013     1    10       3
# ... with 355 more rows
</code></pre><pre><code>&gt; # 延误超过1小时的航班比例是多少？
&gt; not_cancelled %&gt;%
+   group_by(year, month, day) %&gt;%
+   summarize(hour_perc = mean(arr_delay &gt; 60))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day hour_perc
   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1    0.0722
 2  2013     1     2    0.0851
 3  2013     1     3    0.0567
 4  2013     1     4    0.0396
 5  2013     1     5    0.0349
 6  2013     1     6    0.0470
 7  2013     1     7    0.0333
 8  2013     1     8    0.0213
 9  2013     1     9    0.0202
10  2013     1    10    0.0183
# ... with 355 more rows
</code></pre><h3 id="365-按多个变量分组"><a class="anchor" href="#365-按多个变量分组">#</a> 3.6.5　按多个变量分组</h3><p>当使用多个变量进行分组时，每次的摘要统计会用掉一个分组变量。这样就可以轻松地对数据集进行循序渐进的分析</p><pre><code>&gt; daily &lt;- group_by(flights, year, month, day)
&gt; (per_day &lt;- summarize(daily, flights = n()))
`summarise()` regrouping output by 'year', 'month' (override with `.groups` argument)
# A tibble: 365 x 4
# Groups:   year, month [12]
    year month   day flights
   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
 1  2013     1     1     842
 2  2013     1     2     943
 3  2013     1     3     914
 4  2013     1     4     915
 5  2013     1     5     720
 6  2013     1     6     832
 7  2013     1     7     933
 8  2013     1     8     899
 9  2013     1     9     902
10  2013     1    10     932
# ... with 355 more rows

&gt; (per_month &lt;- summarize(per_day, flights = sum(flights)))
`summarise()` regrouping output by 'year' (override with `.groups` argument)
# A tibble: 12 x 3
# Groups:   year [1]
    year month flights
   &lt;int&gt; &lt;int&gt;   &lt;int&gt;
 1  2013     1   27004
 2  2013     2   24951
 3  2013     3   28834
 4  2013     4   28330
 5  2013     5   28796
 6  2013     6   28243
 7  2013     7   29425
 8  2013     8   29327
 9  2013     9   27574
10  2013    10   28889
11  2013    11   27268
12  2013    12   28135

#可以发现day分组已经消失
</code></pre><h3 id="366-取消分组"><a class="anchor" href="#366-取消分组">#</a> 3.6.6　取消分组</h3><p>如果想要取消分组，并回到未分组的数据继续操作，那么可以使用 ungroup () 函数：</p><pre><code>&gt; daily %&gt;%
+     ungroup() %&gt;% # 不再按日期分组
+     summarize(flights = n()) # 所有航班
# A tibble: 1 x 1
  flights
    &lt;int&gt;
1  336776
</code></pre><h2 id="37-分组新变量"><a class="anchor" href="#37-分组新变量">#</a> 3.7 分组新变量</h2><p>虽然与 summarize () 函数结合起来使用是最有效的，但分组也可以与 mutate () 和 filter () 函数结合，以完成非常便捷的操作。</p><p>找出每个分组中最差的成员：</p><pre><code>&gt; flights_sml %&gt;%
+     group_by(year, month, day) %&gt;%
+     filter(rank(desc(arr_delay)) &lt; 10)
# A tibble: 3,306 x 7
# Groups:   year, month, day [365]
    year month   day dep_delay arr_delay distance air_time
   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
 1  2013     1     1       853       851      184       41
 2  2013     1     1       290       338     1134      213
 3  2013     1     1       260       263      266       46
 4  2013     1     1       157       174      213       60
 5  2013     1     1       216       222      708      121
 6  2013     1     1       255       250      589      115
 7  2013     1     1       285       246     1085      146
 8  2013     1     1       192       191      199       44
 9  2013     1     1       379       456     1092      222
10  2013     1     2       224       207      550       94
# ... with 3,296 more rows
</code></pre><p>找出大于某个阈值的所有分组：</p><pre><code>&gt; popular_dests &lt;- flights %&gt;%
+   group_by(dest) %&gt;%
+   filter(n() &gt; 365)
&gt; popular_dests
# A tibble: 332,577 x 19
# Groups:   dest [77]
    year month   day dep_time sched_dep_time dep_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
 1  2013     1     1      517            515         2
 2  2013     1     1      533            529         4
 3  2013     1     1      542            540         2
 4  2013     1     1      544            545        -1
 5  2013     1     1      554            600        -6
 6  2013     1     1      554            558        -4
 7  2013     1     1      555            600        -5
 8  2013     1     1      557            600        -3
 9  2013     1     1      557            600        -3
10  2013     1     1      558            600        -2
# ... with 332,567 more rows, and 13 more variables:
#   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
#   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
#   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
</code></pre><p>对数据进行标准化以计算分组指标：</p><pre><code>&gt; popular_dests %&gt;%
+   filter(arr_delay &gt; 0) %&gt;%
+   mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;%
+   select(year:day, dest, arr_delay, prop_delay)
# A tibble: 131,106 x 6
# Groups:   dest [77]
    year month   day dest  arr_delay prop_delay
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
 1  2013     1     1 IAH          11  0.000111
 2  2013     1     1 IAH          20  0.000201
 3  2013     1     1 MIA          33  0.000235
 4  2013     1     1 ORD          12  0.0000424
 5  2013     1     1 FLL          19  0.0000938
 6  2013     1     1 ORD           8  0.0000283
 7  2013     1     1 LAX           7  0.0000344
 8  2013     1     1 DFW          31  0.000282
 9  2013     1     1 ATL          12  0.0000400
10  2013     1     1 DTW          16  0.000116
# ... with 131,096 more rows
</code></pre><hr><p>转载请注明<a href="www.zhouxiaozao.cn">周小钊的博客</a> &gt;&gt;<a href="www.zhouxiaozhao.cn/2020/07/22/R4ds2/">R4ds2</a></p><div class="tags"><a href="/tags/R-study/" rel="tag"><i class="ic i-tag"></i> R_study</a> <a href="/tags/R-For-Data-science/" rel="tag"><i class="ic i-tag"></i> R_For_Data_science</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-12-14 10:55:44" itemprop="dateModified" datetime="2022-12-14T10:55:44+08:00">2022-12-14</time> </span><span id="2020/07/25/2020-07-25-R4ds2/" class="item leancloud_visitors" data-flag-title="R 数据科学笔记：2" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="amane 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="amane 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>amane <i class="ic i-at"><em>@</em></i>小钊の笔记</li><li class="link"><strong>本文链接：</strong> <a href="https://www.zhouxiaozhao.cn/2020/07/25/2020-07-25-R4ds2/" title="R 数据科学笔记：2">https://www.zhouxiaozhao.cn/2020/07/25/2020-07-25-R4ds2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020/07/22/2020-07-22-R4ds1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img1.imgtp.com&#x2F;2023&#x2F;02&#x2F;01&#x2F;tzn2O8cD.jpg" title="R数据科学笔记：1"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> R</span><h3>R数据科学笔记：1</h3></a></div><div class="item right"><a href="/2020/07/27/2020-07-27-Symbiotic/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img1.imgtp.com&#x2F;2023&#x2F;02&#x2F;01&#x2F;Vghr1YDl.jpg" title="文献导读:菌虫共生真菌测序"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 文献导读</span><h3>文献导读:菌虫共生真菌测序</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">第二章 工作流：基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 代码基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 对象名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">2.3　函数调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BD%BF%E7%94%A8dplyr%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">第三章 使用 dplyr 进行数据转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1.1 准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312-nycflights13"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.1.2 nycflights13</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313-dplyr%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.1.3 dplyr 基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E4%BD%BF%E7%94%A8filter%E7%AD%9B%E9%80%89%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">3.2　使用 filter () 筛选行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.2.1 比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.2.2 逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323-%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.2.3 缺失值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E4%BD%BF%E7%94%A8arrange%E6%8E%92%E5%88%97%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 使用 arrange () 排列行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E4%BD%BF%E7%94%A8select%E9%80%89%E6%8B%A9%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 使用 select () 选择列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E4%BD%BF%E7%94%A8mutate%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%8F%98%E9%87%8F"><span class="toc-number">2.5.</span> <span class="toc-text">3.5 使用 mutate () 添加新变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#351-%E5%B8%B8%E7%94%A8%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">3.5.1 常用创建函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E4%BD%BF%E7%94%A8summarize%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E6%91%98%E8%A6%81"><span class="toc-number">2.6.</span> <span class="toc-text">3.6 使用 summarize () 进行分组摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#361-%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E7%BB%84%E5%90%88%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.1.</span> <span class="toc-text">3.6.1 使用管道组合多种操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#362-%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-number">2.6.2.</span> <span class="toc-text">3.6.2 缺失值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#363-%E8%AE%A1%E6%95%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">3.6.3 计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#364-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%91%98%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.4.</span> <span class="toc-text">3.6.4 常用的摘要函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#365-%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%86%E7%BB%84"><span class="toc-number">2.6.5.</span> <span class="toc-text">3.6.5　按多个变量分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#366-%E5%8F%96%E6%B6%88%E5%88%86%E7%BB%84"><span class="toc-number">2.6.6.</span> <span class="toc-text">3.6.6　取消分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%88%86%E7%BB%84%E6%96%B0%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.</span> <span class="toc-text">3.7 分组新变量</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020/07/22/2020-07-22-R4ds1/" rel="bookmark" title="R数据科学笔记：1">R数据科学笔记：1</a></li><li class="active"><a href="/2020/07/25/2020-07-25-R4ds2/" rel="bookmark" title="R数据科学笔记:2">R数据科学笔记:2</a></li><li><a href="/2020/08/10/2020-08-13-R4ds3/" rel="bookmark" title="R数据科学笔记:3">R数据科学笔记:3</a></li><li><a href="/2020/08/16/2020-08-16-R4ds4/" rel="bookmark" title="R数据科学笔记:4">R数据科学笔记:4</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="amane" data-src="/images/avatar.png"><p class="name" itemprop="name">amane</p><div class="description" itemprop="description">生物学在读博士</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">83</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Jpb2luZm9ybWF0aWNzLXJvb2tpZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Bioinformatics-rookie"><i class="ic i-github"></i></span> <a href="https://www.zhouxiaozhao.cn/about/" title="https:&#x2F;&#x2F;www.zhouxiaozhao.cn&#x2F;about&#x2F;" class="item about"><i class="ic i-address-card"></i></a> <span class="exturl item email" data-url="bWFpbHRvOnpob3VzaGl6aGFvQG1haWwua2liLmFjLmNu" title="mailto:zhoushizhao@mail.kib.ac.cn"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020/07/22/2020-07-22-R4ds1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2020/07/27/2020-07-27-Symbiotic/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Python/" title="分类于 Python">Python</a></div><span><a href="/2020/10/15/2020-10-15-python6/" title="马士兵教育Python入门基础:3.运算（2）">马士兵教育Python入门基础:3.运算（2）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/08/05/2020-08-05-WGCNA2/" title="WGCNA学习：WGCNA应用场景与实例解读">WGCNA学习：WGCNA应用场景与实例解读</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/R/" title="分类于 R">R</a></div><span><a href="/2020/08/16/2020-08-16-R4ds4/" title="R数据科学笔记:4">R数据科学笔记:4</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/11/10/2020-11-10-RNAvelocity(1)/" title="RNA速率：软件下载与loom文件准备">RNA速率：软件下载与loom文件准备</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/10/06/2020-10-06-ScRNAseq(4)/" title="单细胞实战(4)：STAR与cellranger结果比较">单细胞实战(4)：STAR与cellranger结果比较</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/09/06/2020-09-06-iTOL3/" title="进化树在线制作工具iTOL教程（3）：添加图片">进化树在线制作工具iTOL教程（3）：添加图片</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/11/28/2020-11-28-RNAseq(2)/" title="RNAseq教程(1.2)">RNAseq教程(1.2)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a> <i class="ic i-angle-right"></i> <a href="/categories/Bioinformation/Blog/" title="分类于 博客">博客</a></div><span><a href="/2020/07/09/2020-07-09-github+jekyll/" title="利用Github+Jekyll构建自己的博客">利用Github+Jekyll构建自己的博客</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/09/29/2020-09-29-ScRNAseq(1)/" title="单细胞实战(1)：原始测序数据下载">单细胞实战(1)：原始测序数据下载</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Bioinformation/" title="分类于 生信学习">生信学习</a></div><span><a href="/2020/09/01/2020-09-01-iTOL1/" title="进化树在线制作工具iTOL教程（1）：基本操作">进化树在线制作工具iTOL教程（1）：基本操作</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">amane @ Zhou Xiaozhao</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">344k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:13</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020/07/25/2020-07-25-R4ds2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->